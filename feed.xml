<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Jacek's C++ Blog</title>
        <link>https://blog.galowicz.de</link>
        <description><![CDATA[This blog is about C++]]></description>
        <atom:link href="https://blog.galowicz.de/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 17 Apr 2019 00:00:00 UT</lastBuildDate>
        <item>
    <title>Setting up a C++ project environment with nix</title>
    <link>https://blog.galowicz.de/2019/04/17/tutorial_nix_cpp_setup</link>
    <description><![CDATA[<p>This article explains how to quickly set up a C++ project environment with complete toolchain- and dependency management with <code>nix</code>. <a href="https://nixos.org/nix/"><code>nix</code></a> is a powerful package manager for Linux and other Unix systems (It is indeed a more powerful alternative to <a href="https://conan.io/"><code>conan</code></a> and <a href="https://www.docker.com/"><code>docker</code></a>) that makes package management reliable and reproducible. After setting up the project and playing around with it, we will <strong>parametrize</strong> the project description in order to automatically build it with different compilers and dependency library versions (GCC 7 &amp; 8, Clang 7 &amp; 8, lib <code>boost</code> 1.6.6 - 1.6.9, lib <code>poco</code> 1.9.0 &amp; 1.9.1).</p>
<!--more-->
<p>Let’s start with a fresh system where no C++ compiler and no development libraries are installed. The only tool that we require to be installed is <code>nix</code> (see the <a href="https://nixos.org/nix/download.html">installation guide on nixos.org</a> for installation instructions), because we are going to use it to perform the toolchain and dependency setup.</p>
<h2 id="creating-a-little-example-c-project">Creating a little example C++ Project</h2>
<p>Let’s write a C++ program with the following dependencies:</p>
<ul>
<li>C++ compiler, of course. That might be GCC or Clang.</li>
<li><code>boost</code> library (<a href="https://www.boost.org" class="uri">https://www.boost.org</a>)</li>
<li><code>poco</code> library (<a href="https://pocoproject.org" class="uri">https://pocoproject.org</a>)</li>
</ul>
<p>For the sake of having a simple example app, the program does nothing more than printing what compiler it was built with and which versions of <code>boost</code> and <code>poco</code> it is linked against.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co">#include &lt;boost/lexical_cast.hpp&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">#include &lt;Poco/Environment.h&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">#include &lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">#if defined(__clang__)</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">#define CC &quot;clang++&quot;</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">#elif defined (__GNUC__)</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">#define CC &quot;g++&quot;</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">#else</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">#define CC &quot;&lt;unknown compiler&gt;&quot;</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">#endif</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="ex">int</span> main() <span class="kw">{</span></a>
<a class="sourceLine" id="cb1-14" title="14">  <span class="ex">std</span>::cout <span class="op">&lt;&lt; &quot;Hello</span> <span class="ex">World</span>!\n<span class="st">&quot;</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="st">    &lt;&lt; &quot;</span>Compiler: <span class="st">&quot; &lt;&lt; CC &lt;&lt; &quot;</span> <span class="st">&quot; &lt;&lt; __VERSION__ &lt;&lt; &#39;\n&#39;</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="st">    &lt;&lt; &quot;</span>Boost: <span class="st">&quot; &lt;&lt; (BOOST_VERSION / 100000) &lt;&lt; &#39;.&#39;</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="st">                 &lt;&lt; (BOOST_VERSION / 100 % 1000) &lt;&lt; &#39;.&#39;</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="st">                 &lt;&lt; (BOOST_VERSION % 100) &lt;&lt; &#39;\n&#39;</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="st">    &lt;&lt; &quot;</span>POCO: <span class="st">&quot; &lt;&lt; (Poco::Environment::libraryVersion() &gt;&gt; 24) &lt;&lt; &#39;.&#39;</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="st">                &lt;&lt; (Poco::Environment::libraryVersion() &gt;&gt; 16 &amp; 0xff) &lt;&lt; &#39;.&#39;</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="st">                &lt;&lt; (Poco::Environment::libraryVersion() &gt;&gt; 8 &amp; 0xff)</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="st">                &lt;&lt; &#39;\n&#39;;</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="st">}</span></a></code></pre></div>
<p>We can either <em>install</em> a C++ compiler by running <code>nix-env</code> with the appropriate arguments, or just run a shell that exposes a C++ compiler in its <code>PATH</code> environment. Let us not clutter the system’s <code>PATH</code> environment with compilers from the beginning, because often people would use different compilers for each project anyway.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="ex">nix-shell</span> -p gcc</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">[<span class="ex">nix-shell</span>:~]$ c++ --version</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ex">g++</span> (GCC) <span class="ex">7.4.0</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="ex">Copyright</span> (C) <span class="ex">2017</span> Free Software Foundation, Inc.</a>
<a class="sourceLine" id="cb2-6" title="6"><span class="ex">This</span> is free software<span class="kw">;</span> <span class="ex">see</span> the source for copying conditions.  There is NO</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ex">warranty</span><span class="kw">;</span> <span class="ex">not</span> even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</a></code></pre></div>
<p>We are now in a shell that includes GCC’s C++ compiler in its <code>PATH</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">[<span class="ex">nix-shell</span>:~/src/nix_cmake_example]$ echo <span class="va">$PATH</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">...</span>:/nix/store/ghzg4kg0sjif58smj2lfm2bdvjwim85y-gcc-wrapper-7.4.0/bin:...</a></code></pre></div>
<p>I trimmed the rest of the path list. What’s important here: The path list is full of paths that begin with <code>/nix/store/...</code>. Each of them could be considered what one would call a <em>package</em> on typical Linux distributions. We can easily install multiple compilers with different versions, or even the same version with different sets of patches applied, next to each other in <code>/nix/store</code> and not have any of them collide during a project’s build, because <code>nix</code> does simply only map the packages into the current <code>PATH</code> that are needed.</p>
<blockquote>
<p><code>nix</code> does even more than just exposing packages via the <code>PATH</code> to the executing shell: For a running build process it does also hide all paths that are <em>not</em> listed in the dependencies of a package in order to avoid unknown dependencies lurking into the project. In order to achieve that, it uses <a href="https://en.wikipedia.org/wiki/Linux_namespaces"><em>namespaces</em></a>, similar to <a href="https://www.docker.com/">Docker</a>. See also: <a href="https://nixos.wiki/wiki/Nix#Sandboxing">nixos.wiki about <strong>sandboxing</strong></a>, and <a href="https://nixos.org/nix/manual/#conf-sandbox">nix manual: <code>sandbox</code> setting</a></p>
</blockquote>
<p>The full procedure of using <code>nix-shell</code> to setup the environment and building and running the app looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1">$ <span class="ex">nix-shell</span> -p gcc boost poco</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">$ <span class="ex">c++</span> -o main main.cpp -lPocoFoundation -lboost_system</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5">$ <span class="ex">./main</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="ex">POCO</span>: 1.9.0</a></code></pre></div>
<blockquote>
<p>Running the compiled binary can of course be done without <code>nix-shell</code>.</p>
</blockquote>
<p>One would typically add a file called <code>default.nix</code> to the project folder:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="ex">with</span> import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ex">stdenv.mkDerivation</span> {</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;my-app&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="ex">src</span> = ./.<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="ex">buildInputs</span> = [ boost poco ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="ex">buildPhase</span> = <span class="st">&quot;c++ -o main main.cpp -lPocoFoundation -lboost_system&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11">  <span class="ex">installPhase</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="fu">mkdir</span> -p <span class="va">$out</span>/bin</a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="fu">cp</span> main <span class="va">$out</span>/bin/</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb5-15" title="15">}</a></code></pre></div>
<p>This buys us that we can simply run <code>nix-build</code> to configure, build and package the project into the nix store with a single command. Developers would still use <code>nix-shell</code> for incremental builds between source modifications. <code>nix-shell</code> does also consult <code>default.nix</code> in order to setup the dependencies right, so we don’t need the <code>-p</code> parameter list any longer.</p>
<p>Very short overview over the most important lines:</p>
<ul>
<li><code>stdenv</code> is an object in the nix expression language that is imported from <code>&lt;nixpkgs&gt;</code>. <code>nixpkgs</code> is a globally available nix expression with all the packages. <code>stdenv</code> contains the compiler and other things needed to compile projects.</li>
<li><code>buildInputs</code> lists compile time and run time dependencies of the project.</li>
<li><code>buildPhase</code> is a shell hook that describes how to build the program.</li>
<li><code>installPhase</code> describes what files should be copied into the nix store.</li>
</ul>
<p>We’re covering how this works in detail only in minimal depth. More information about nix derivations:</p>
<ul>
<li><a href="https://nixos.org/nix/manual/#ssec-derivation"><code>nix</code> manual section about derivations</a></li>
<li><a href="https://nixos.wiki/wiki/C" class="uri">https://nixos.wiki/wiki/C</a></li>
</ul>
<blockquote>
<p>It looks like we’re using <code>nix</code> as a build system now - in fact, <code>mkDerivation</code> is a function that creates a so called “builder script” that is able to detect if we are using a Makefile based project (with or without autoconf), a CMake project, or a set of other build systems, and then executes the right steps according to the build system. One cool detail is that we would typically not touch <code>CMakeFile</code> or other files in order to use <code>nix</code> - this way users who do not want to or cannot use <code>nix</code> are able to use their own tools for dependency management.</p>
<p><code>mkDerivation</code> is a very versatile and complex helper: See the <a href="https://nixos.org/nix/manual/#ssec-derivation"><code>nix</code> manual section about derivations</a></p>
</blockquote>
<p>In this example we use no build system, hence need to use the <code>buildPhase</code> hook to define how our little application is compiled and linked.</p>
<p>Someone else who checks out this project and who has installed <code>nix</code> can now simply run:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">$ <span class="ex">nix-build</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ex">these</span> derivations will be built:</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="ex">/nix/store/dw9d2r7rykym08fzmdgf6v0ia2sn6hq9-my-app.drv</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ex">building</span> <span class="st">&#39;/nix/store/dw9d2r7rykym08fzmdgf6v0ia2sn6hq9-my-app.drv&#39;</span>...</a>
<a class="sourceLine" id="cb6-5" title="5"><span class="ex">unpacking</span> sources</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ex">unpacking</span> source archive /nix/store/8zwsvxdkpjnyxnm9qs33qw3bi12h9gbm-nix_simple</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="bu">source</span> root is nix_simple</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="ex">patching</span> sources</a>
<a class="sourceLine" id="cb6-9" title="9"><span class="ex">configuring</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="ex">no</span> configure script, doing nothing</a>
<a class="sourceLine" id="cb6-11" title="11"><span class="ex">building</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="ex">installing</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="ex">post-installation</span> fixup</a>
<a class="sourceLine" id="cb6-14" title="14"><span class="ex">shrinking</span> RPATHs of ELF executables and libraries in /nix/store/5ldpivphfbya4xw6kcss9vcdvp1mzrcf-my-app</a>
<a class="sourceLine" id="cb6-15" title="15"><span class="ex">shrinking</span> /nix/store/5ldpivphfbya4xw6kcss9vcdvp1mzrcf-my-app/bin/main</a>
<a class="sourceLine" id="cb6-16" title="16"><span class="fu">strip</span> is /nix/store/0y7jmqnj48ikjh37n3dl9kqw9hnn68nq-binutils-2.31.1/bin/strip</a>
<a class="sourceLine" id="cb6-17" title="17"><span class="ex">stripping</span> (with command strip and flags -S) <span class="kw">in</span> <span class="ex">/nix/store/5ldpivphfbya4xw6kcss9vcdvp1mzrcf-my-app/bin</span></a>
<a class="sourceLine" id="cb6-18" title="18"><span class="ex">patching</span> script interpreter paths in /nix/store/5ldpivphfbya4xw6kcss9vcdvp1mzrcf-my-app</a>
<a class="sourceLine" id="cb6-19" title="19"><span class="ex">checking</span> for references to /tmp/nix-build-my-app.drv-0/ in /nix/store/5ldpivphfbya4xw6kcss9vcdvp1mzrcf-my-app...</a>
<a class="sourceLine" id="cb6-20" title="20"><span class="ex">/nix/store/5ldpivphfbya4xw6kcss9vcdvp1mzrcf-my-app</span></a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22">$ <span class="ex">./result/bin/main</span></a>
<a class="sourceLine" id="cb6-23" title="23"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb6-24" title="24"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb6-25" title="25"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb6-26" title="26"><span class="ex">POCO</span>: 1.9.0</a></code></pre></div>
<p>The compiler, all libraries etc. are automatically downloaded and put into action. Much simpler than with <a href="https://conan.io/">conan</a>!</p>
<p>That is basically it: If the program grows, we will certainly switch to some build system - <code>nix</code> supports that without having to add nix-specific stuff into the build files (GNUMake, CMake, meson, etc. are supported. Have a look into the <a href="https://github.com/NixOS/nixpkgs/tree/master/pkgs/development/tools/build-managers"><code>nixpkgs</code> git repository folder for supported build systems</a>). If the number of dependencies grows, be that libraries or compile time tools, we can simply add them to the nix expression.</p>
<h2 id="building-the-code-with-different-dependency-versions">Building the code with different dependency versions</h2>
<p>The <code>default.nix</code> expression results in one so-called <em>derivation</em> that <code>nix</code> can materialize into a binary package in the nix storage. Let us now write another nix expression that takes multiple <code>boost</code> library versions, multiple <code>poco</code> library versions and multiple compilers, and that results in a <em>set</em> of derivations that nix can materialize using those.</p>
<p>We will use the following variety of dependency versions:</p>
<ul>
<li>GCC 7 &amp; 8</li>
<li>Clang 7 &amp; 8</li>
<li>lib <code>poco</code> 1.9.0 &amp; 1.9.1</li>
<li>lib <code>boost</code> 1.6.6 - 1.6.9</li>
</ul>
<p>…which results in <span class="math inline">2 * 2 * 2 * 4 = 32</span> different binaries.</p>
<p>Quick spoiler: The result of the nix expression that we are going to write will allow us to build and execute these 32 binaries with a single <code>nix-build release.nix</code> command.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1">$ <span class="kw">for</span> <span class="ex">path</span> in <span class="va">$(</span><span class="ex">nix-build</span> release.nix<span class="va">)</span><span class="kw">;</span> <span class="kw">do</span> <span class="kw">\</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="op">&gt;</span>   <span class="bu">echo</span> <span class="st">&quot;====&quot;</span><span class="kw">;</span> <span class="kw">\</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="op">&gt;</span>   <span class="bu">echo</span> <span class="st">&quot;Output of </span><span class="va">$path</span><span class="st">/bin/main:&quot;</span><span class="kw">;</span> <span class="kw">\</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="op">&gt;</span>   <span class="va">$path</span><span class="ex">/bin/main</span>; <span class="kw">\</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="op">&gt;</span> <span class="kw">done</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co"># trimmed a lot of build output...</span></a>
<a class="sourceLine" id="cb7-7" title="7">====</a>
<a class="sourceLine" id="cb7-8" title="8"><span class="ex">Output</span> of /nix/store/246an1m3rwwgz58qc8hfwvqh28899ckm-my-app-clang7-poco190-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-9" title="9"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-10" title="10"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-12" title="12"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-13" title="13">====</a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ex">Output</span> of /nix/store/cfh1cy03kly9wq6x6dzlza4d9kads6cd-my-app-clang7-poco190-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-15" title="15"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-16" title="16"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-17" title="17"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-18" title="18"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-19" title="19">====</a>
<a class="sourceLine" id="cb7-20" title="20"><span class="ex">Output</span> of /nix/store/jjbpj24x4gp2vpn355j0qsy117yrkhrd-my-app-clang7-poco190-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-21" title="21"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-22" title="22"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-23" title="23"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-24" title="24"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-25" title="25">====</a>
<a class="sourceLine" id="cb7-26" title="26"><span class="ex">Output</span> of /nix/store/f9fgwzpq9gn85abx9h1zr5c6j3bs4ks2-my-app-clang7-poco190-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-27" title="27"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-28" title="28"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-29" title="29"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-30" title="30"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-31" title="31">====</a>
<a class="sourceLine" id="cb7-32" title="32"><span class="ex">Output</span> of /nix/store/1wwff8p5rxjqjkhqifvhy833bl3mf8l3-my-app-clang7-poco191-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-33" title="33"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-34" title="34"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-35" title="35"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-36" title="36"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-37" title="37">====</a>
<a class="sourceLine" id="cb7-38" title="38"><span class="ex">Output</span> of /nix/store/3jdv2l0gp3za4q5rj8s4859bpiyscg0m-my-app-clang7-poco191-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-39" title="39"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-40" title="40"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-41" title="41"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-42" title="42"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-43" title="43">====</a>
<a class="sourceLine" id="cb7-44" title="44"><span class="ex">Output</span> of /nix/store/fcbypavfzrw8ajngaim7srvn9fylj7b3-my-app-clang7-poco191-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-45" title="45"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-46" title="46"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-47" title="47"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-48" title="48"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-49" title="49">====</a>
<a class="sourceLine" id="cb7-50" title="50"><span class="ex">Output</span> of /nix/store/a8d1mwqiay3qx60fzp6m70q89s0mpcwx-my-app-clang7-poco191-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-51" title="51"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-52" title="52"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 7.0.1 (tags/RELEASE_701/final)</a>
<a class="sourceLine" id="cb7-53" title="53"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-54" title="54"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-55" title="55">====</a>
<a class="sourceLine" id="cb7-56" title="56"><span class="ex">Output</span> of /nix/store/lhxdhmi9ficg9v9mkxv4zz9s4759r5z6-my-app-clang8-poco190-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-57" title="57"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-58" title="58"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-59" title="59"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-60" title="60"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-61" title="61">====</a>
<a class="sourceLine" id="cb7-62" title="62"><span class="ex">Output</span> of /nix/store/x4f34gi6p6ipa8lvqx2aj36nzipk2yv1-my-app-clang8-poco190-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-63" title="63"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-64" title="64"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-65" title="65"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-66" title="66"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-67" title="67">====</a>
<a class="sourceLine" id="cb7-68" title="68"><span class="ex">Output</span> of /nix/store/dqmy8gmkshi8glg2ldidpclzq2mrqbvw-my-app-clang8-poco190-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-69" title="69"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-70" title="70"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-71" title="71"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-72" title="72"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-73" title="73">====</a>
<a class="sourceLine" id="cb7-74" title="74"><span class="ex">Output</span> of /nix/store/s5qw1ff2qbx2aswnlvd7l7d60fdfyr0y-my-app-clang8-poco190-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-75" title="75"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-76" title="76"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-77" title="77"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-78" title="78"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-79" title="79">====</a>
<a class="sourceLine" id="cb7-80" title="80"><span class="ex">Output</span> of /nix/store/wf4ygk9lhkmfv98f9g05pndv4a0320j1-my-app-clang8-poco191-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-81" title="81"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-82" title="82"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-83" title="83"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-84" title="84"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-85" title="85">====</a>
<a class="sourceLine" id="cb7-86" title="86"><span class="ex">Output</span> of /nix/store/xg34s1bzr2h57hsbj6z0g93mwni7jcgk-my-app-clang8-poco191-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-87" title="87"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-88" title="88"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-89" title="89"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-90" title="90"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-91" title="91">====</a>
<a class="sourceLine" id="cb7-92" title="92"><span class="ex">Output</span> of /nix/store/bhjzyxr1wpjnkdr1wm72142l0hlndsnz-my-app-clang8-poco191-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-93" title="93"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-94" title="94"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-95" title="95"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-96" title="96"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-97" title="97">====</a>
<a class="sourceLine" id="cb7-98" title="98"><span class="ex">Output</span> of /nix/store/r1nd2gb7r45vpldnbiprdnyg7y29k08f-my-app-clang8-poco191-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-99" title="99"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-100" title="100"><span class="ex">Compiler</span>: clang++ 4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/final)</a>
<a class="sourceLine" id="cb7-101" title="101"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-102" title="102"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-103" title="103">====</a>
<a class="sourceLine" id="cb7-104" title="104"><span class="ex">Output</span> of /nix/store/3jfbck6mcrgjfpya8p8x293sfkqi0w5b-my-app-gcc7-poco190-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-105" title="105"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-106" title="106"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-107" title="107"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-108" title="108"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-109" title="109">====</a>
<a class="sourceLine" id="cb7-110" title="110"><span class="ex">Output</span> of /nix/store/cvlxdps8k666dgim3xp04xkm4qzbvkby-my-app-gcc7-poco190-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-111" title="111"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-112" title="112"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-113" title="113"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-114" title="114"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-115" title="115">====</a>
<a class="sourceLine" id="cb7-116" title="116"><span class="ex">Output</span> of /nix/store/ipk381rlahkv6wbwccmv7pibwghdbw7c-my-app-gcc7-poco190-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-117" title="117"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-118" title="118"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-119" title="119"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-120" title="120"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-121" title="121">====</a>
<a class="sourceLine" id="cb7-122" title="122"><span class="ex">Output</span> of /nix/store/pl9y9njmyc2ws4i4mgfnhdxxsbrzasj3-my-app-gcc7-poco190-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-123" title="123"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-124" title="124"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-125" title="125"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-126" title="126"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-127" title="127">====</a>
<a class="sourceLine" id="cb7-128" title="128"><span class="ex">Output</span> of /nix/store/svxr6826wm0sx9mm8sgy1v2aq2v1nx2p-my-app-gcc7-poco191-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-129" title="129"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-130" title="130"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-131" title="131"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-132" title="132"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-133" title="133">====</a>
<a class="sourceLine" id="cb7-134" title="134"><span class="ex">Output</span> of /nix/store/hfwv308iaykb4ygnjpjfxwy6xf1rr0s3-my-app-gcc7-poco191-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-135" title="135"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-136" title="136"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-137" title="137"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-138" title="138"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-139" title="139">====</a>
<a class="sourceLine" id="cb7-140" title="140"><span class="ex">Output</span> of /nix/store/2bxawcdkgjbvn756q93r65vym19b2jip-my-app-gcc7-poco191-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-141" title="141"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-142" title="142"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-143" title="143"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-144" title="144"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-145" title="145">====</a>
<a class="sourceLine" id="cb7-146" title="146"><span class="ex">Output</span> of /nix/store/zgzw1bbx935fm209lxnn01n14sv8f9a8-my-app-gcc7-poco191-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-147" title="147"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-148" title="148"><span class="ex">Compiler</span>: g++ 7.4.0</a>
<a class="sourceLine" id="cb7-149" title="149"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-150" title="150"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-151" title="151">====</a>
<a class="sourceLine" id="cb7-152" title="152"><span class="ex">Output</span> of /nix/store/jgsxmqgwmqqv2sbcmnx63abb3ymfsqc5-my-app-gcc8-poco190-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-153" title="153"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-154" title="154"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-155" title="155"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-156" title="156"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-157" title="157">====</a>
<a class="sourceLine" id="cb7-158" title="158"><span class="ex">Output</span> of /nix/store/3j9q4bn2id2iqza44n39mzi4cqzhqlz2-my-app-gcc8-poco190-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-159" title="159"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-160" title="160"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-161" title="161"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-162" title="162"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-163" title="163">====</a>
<a class="sourceLine" id="cb7-164" title="164"><span class="ex">Output</span> of /nix/store/7czfqh3fbjpslnar101b472kzlhxlcdc-my-app-gcc8-poco190-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-165" title="165"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-166" title="166"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-167" title="167"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-168" title="168"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-169" title="169">====</a>
<a class="sourceLine" id="cb7-170" title="170"><span class="ex">Output</span> of /nix/store/9vmwm0zzsgxqm6v5yxzjdjkhgxqqdnqr-my-app-gcc8-poco190-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-171" title="171"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-172" title="172"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-173" title="173"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-174" title="174"><span class="ex">POCO</span>: 1.9.0</a>
<a class="sourceLine" id="cb7-175" title="175">====</a>
<a class="sourceLine" id="cb7-176" title="176"><span class="ex">Output</span> of /nix/store/n34v5f23jhpcc20hyszdn270p9wyzfbz-my-app-gcc8-poco191-boost166/bin/main:</a>
<a class="sourceLine" id="cb7-177" title="177"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-178" title="178"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-179" title="179"><span class="ex">Boost</span>: 1.66.0</a>
<a class="sourceLine" id="cb7-180" title="180"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-181" title="181">====</a>
<a class="sourceLine" id="cb7-182" title="182"><span class="ex">Output</span> of /nix/store/bq9pijnw746ilp1ar8xwb7bl3v1ypy0y-my-app-gcc8-poco191-boost167/bin/main:</a>
<a class="sourceLine" id="cb7-183" title="183"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-184" title="184"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-185" title="185"><span class="ex">Boost</span>: 1.67.0</a>
<a class="sourceLine" id="cb7-186" title="186"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-187" title="187">====</a>
<a class="sourceLine" id="cb7-188" title="188"><span class="ex">Output</span> of /nix/store/pzqa2sraf1xhji9bk6namwg6x4ar9sgq-my-app-gcc8-poco191-boost168/bin/main:</a>
<a class="sourceLine" id="cb7-189" title="189"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-190" title="190"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-191" title="191"><span class="ex">Boost</span>: 1.68.0</a>
<a class="sourceLine" id="cb7-192" title="192"><span class="ex">POCO</span>: 1.9.1</a>
<a class="sourceLine" id="cb7-193" title="193">====</a>
<a class="sourceLine" id="cb7-194" title="194"><span class="ex">Output</span> of /nix/store/vb3ha6skwnj2h5k691jxcn7pxa8gs90i-my-app-gcc8-poco191-boost169/bin/main:</a>
<a class="sourceLine" id="cb7-195" title="195"><span class="ex">Hello</span> World!</a>
<a class="sourceLine" id="cb7-196" title="196"><span class="ex">Compiler</span>: g++ 8.3.0</a>
<a class="sourceLine" id="cb7-197" title="197"><span class="ex">Boost</span>: 1.69.0</a>
<a class="sourceLine" id="cb7-198" title="198"><span class="ex">POCO</span>: 1.9.1</a></code></pre></div>
<p>As the first step, let us first decompose the <code>default.nix</code> file into a file <code>derivation.nix</code> and another file <code>release.nix</code>.</p>
<p>The new <code>derivation.nix</code> file contains the pure package description without knowledge about where the dependencies come from:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">{</span> <span class="ex">boost</span>, poco, stdenv <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="ex">stdenv.mkDerivation</span> {</a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;my-app&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="ex">src</span> = ./.<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="ex">buildInputs</span> = [ boost poco ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="ex">buildPhase</span> = <span class="st">&quot;c++ -std=c++17 -o main main.cpp -lPocoFoundation -lboost_system&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11">  <span class="ex">installPhase</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="fu">mkdir</span> -p <span class="va">$out</span>/bin</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="fu">cp</span> main <span class="va">$out</span>/bin/</a>
<a class="sourceLine" id="cb8-14" title="14">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb8-15" title="15">}</a></code></pre></div>
<p>The first line states that the content of this file is a <em>function</em> that accepts a dictionary with the keys <code>boost</code>, <code>poco</code>, and <code>stdenv</code> as input arguments. It does then finally return a derivation. A derivation can be materialized into a package with the binary by <code>nix</code>.</p>
<p>This means that we can regard <code>derivation.nix</code> like a mathematical function<br />
<span class="math inline"><em>d</em><em>e</em><em>r</em><em>i</em><em>v</em>(<em>c</em><em>o</em><em>m</em><em>p</em><em>i</em><em>l</em><em>e</em><em>r</em>, <em>b</em><em>o</em><em>o</em><em>s</em><em>t</em>, <em>p</em><em>o</em><em>c</em><em>o</em>) → <em>d</em><em>e</em><em>r</em><em>i</em><em>v</em><em>a</em><em>t</em><em>i</em><em>o</em><em>n</em></span>.</p>
<p>The next step is then to use that function <span class="math inline"><em>d</em><em>e</em><em>r</em><em>i</em><em>v</em></span> and feed it with the cartesian product of all 32 input combinations. The file <code>release.nix</code> does just that:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource numberLines nix"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="ex">nixpkgs</span> ? <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span>,</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="ex">pkgs</span> ? import nixpkgs {<span class="kw">}</span></a>
<a class="sourceLine" id="cb9-4" title="4">}:</a>
<a class="sourceLine" id="cb9-5" title="5"></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="bu">let</span></a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="ex">compilers</span> = with pkgs<span class="kw">;</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="ex">gcc7</span> = stdenv<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-9" title="9">    <span class="ex">gcc8</span> = overrideCC stdenv gcc8<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="ex">clang7</span> = overrideCC stdenv clang_7<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-11" title="11">    <span class="ex">clang8</span> = overrideCC stdenv clang_8<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb9-13" title="13"></a>
<a class="sourceLine" id="cb9-14" title="14">  <span class="ex">pocoLibs</span> = {</a>
<a class="sourceLine" id="cb9-15" title="15">    <span class="ex">poco190</span> = pkgs.poco<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="ex">poco191</span> = pkgs.poco.overrideAttrs (oldAttrs: {</a>
<a class="sourceLine" id="cb9-17" title="17">      <span class="ex">name</span> = <span class="st">&quot;poco-1.9.1&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-18" title="18">      <span class="ex">src</span> = pkgs.fetchzip {</a>
<a class="sourceLine" id="cb9-19" title="19">        <span class="ex">url</span> = <span class="st">&quot;https://github.com/pocoproject/poco/archive/poco-1.9.1.zip&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-20" title="20">        <span class="ex">sha256</span> = <span class="st">&quot;0d5d6cxv5k0r0kcr2zjsxzjbpd8s1x8dmwzsjh04yq470i8jw9zz&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-21" title="21">      };</a>
<a class="sourceLine" id="cb9-22" title="22">    });</a>
<a class="sourceLine" id="cb9-23" title="23">  };</a>
<a class="sourceLine" id="cb9-24" title="24"></a>
<a class="sourceLine" id="cb9-25" title="25">  <span class="ex">boostLibs</span> = {</a>
<a class="sourceLine" id="cb9-26" title="26">    <span class="ex">inherit</span> (pkgs) <span class="ex">boost166</span> boost167 boost168 boost169<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-27" title="27">  };</a>
<a class="sourceLine" id="cb9-28" title="28"></a>
<a class="sourceLine" id="cb9-29" title="29">  <span class="ex">originalDerivation</span> = [ (pkgs.callPackage (import ./derivation.nix) {}) ];</a>
<a class="sourceLine" id="cb9-30" title="30"></a>
<a class="sourceLine" id="cb9-31" title="31">  <span class="ex">f</span> = libname: libs: derivs: with pkgs.lib<span class="kw">;</span></a>
<a class="sourceLine" id="cb9-32" title="32">    <span class="ex">concatMap</span> (deriv:</a>
<a class="sourceLine" id="cb9-33" title="33">      <span class="ex">mapAttrsToList</span> (libVers: lib:</a>
<a class="sourceLine" id="cb9-34" title="34">        <span class="kw">(</span><span class="ex">deriv.override</span> { <span class="st">&quot;</span><span class="va">${libname}</span><span class="st">&quot;</span> = lib<span class="kw">;</span> }<span class="kw">)</span><span class="ex">.overrideAttrs</span></a>
<a class="sourceLine" id="cb9-35" title="35">          <span class="kw">(</span><span class="ex">old</span>: { name = <span class="st">&quot;</span><span class="va">${old</span><span class="er">.name</span><span class="va">}</span><span class="st">-</span><span class="va">${libVers}</span><span class="st">&quot;</span><span class="kw">;</span> }<span class="kw">)</span></a>
<a class="sourceLine" id="cb9-36" title="36">      ) <span class="ex">libs</span></a>
<a class="sourceLine" id="cb9-37" title="37">    ) <span class="ex">derivs</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-38" title="38"></a>
<a class="sourceLine" id="cb9-39" title="39">  <span class="ex">overrides</span> = [</a>
<a class="sourceLine" id="cb9-40" title="40">    <span class="kw">(</span><span class="ex">f</span> <span class="st">&quot;stdenv&quot;</span> compilers<span class="kw">)</span></a>
<a class="sourceLine" id="cb9-41" title="41">    <span class="kw">(</span><span class="ex">f</span> <span class="st">&quot;poco&quot;</span>   pocoLibs<span class="kw">)</span></a>
<a class="sourceLine" id="cb9-42" title="42">    <span class="kw">(</span><span class="ex">f</span> <span class="st">&quot;boost&quot;</span>  boostLibs<span class="kw">)</span></a>
<a class="sourceLine" id="cb9-43" title="43">  ];</a>
<a class="sourceLine" id="cb9-44" title="44"><span class="kw">in</span></a>
<a class="sourceLine" id="cb9-45" title="45">  <span class="ex">pkgs.lib.foldl</span> (a: b: a // { <span class="st">&quot;</span><span class="va">${b</span><span class="er">.name</span><span class="va">}</span><span class="st">&quot;</span> = b<span class="kw">;</span> }) {} <span class="kw">(</span></a>
<a class="sourceLine" id="cb9-46" title="46">    <span class="ex">pkgs.lib.foldl</span> (a: f: f a<span class="kw">)</span> <span class="ex">originalDerivation</span> overrides</a>
<a class="sourceLine" id="cb9-47" title="47">  )</a></code></pre></div>
<p>This code looks a bit more complicated, but it does a lot of things:</p>
<ul>
<li>It defines the variety of compilers and libraries in the variables <code>compilers</code>, <code>pocoLibs</code>, and <code>boostLibs</code>.
<ul>
<li>note that <code>nixpkgs</code> already contains lib <code>poco</code> version 1.9.0, but not 1.9.1 - we simply override its package description to use the latest 1.9.1 source from poco’s github repository.</li>
</ul></li>
<li>Function <code>f</code> contains all the magic: It reapplies the original function <code>deriv</code> with one library input overloaded from a library list argument!</li>
<li>The list <code>overrides</code> contains the list of function <code>f</code> applications that shall be applied over the original derivation.</li>
<li>The last 2 lines of code apply all the transformations within a simple <code>fold</code></li>
</ul>
<p>This explanation is very brief. The whole code might look pretty much familiar to everyone who is not used to nix but has some experience with purely functional programming languages. Explaining the code in detail to developers who neither know <code>nix</code> nor any functional programming, would explode the scope of this article.</p>
<h2 id="summary">Summary</h2>
<p>We have seen how simple it is to quickly set up an ad-hoc C++ programming environment with a compiler and libraries, without cluttering the system.</p>
<p>We have “packaged” our little project with a roughly ~10 LOC short <code>default.nix</code> Users with solely <code>nix</code> installed can clone this project from git, run <code>nix-build</code> and get the binary. Simple as that.</p>
<p>With less than 50 LOC we implemented a nix expression that builds our application in 32 different variants with different compilers and library versions.</p>
<p>There is a git repository with all project files that is available for checkout: <a href="https://github.com/tfc/nix_cpp_cartesian_dependencies" class="uri">https://github.com/tfc/nix_cpp_cartesian_dependencies</a></p>
<h2 id="outlook">Outlook</h2>
<p>What else can be done from here? The advantages and strengths of <code>nix</code> have <em>by far</em> not been exhausted in this example.</p>
<h3 id="maximum-reproducibility-pinning-nixpkgs">Maximum Reproducibility: Pinning <code>nixpkgs</code></h3>
<p>Whenever we referenced packages, we got them from the magical nix expression <code>&lt;nixpkgs&gt;</code>. This package source is a <em>channel</em> that can be updated with <code>nix-channel --update</code>, which is similar to running <code>apt-get update</code> on Debian-like Linux distros. Of course, an update of the channel also updates the packages and thus might break the whole build.</p>
<p>With <code>nix</code>, we can simply <strong>pin</strong> the package list to a version that is known to work.</p>
<p>In the github repository of this example, i did so with <a href="https://github.com/tfc/nix_cpp_cartesian_dependencies/blob/master/nixpkgs.nix">nixpkgs.nix</a>.</p>
<p>Using this technique, one can be pretty confident, that the project will still work in all configurations in a few years, which makes our build procedure pretty reproducible.</p>
<h3 id="nix-ci-hydra">Nix CI: Hydra</h3>
<p>Since <code>nix</code> is simply a tool that can be installed on Linux, Mac, and other UNIX systems, it can also be run in different CIs.</p>
<p>The NixOS project does however come with its own CI: <a href="https://nixos.org/hydra/">Hydra</a>. I am running my own instance on <a href="https://hydra.kosmosgame.com" class="uri">https://hydra.kosmosgame.com</a> and installed this project as a jobset on it:</p>
<p><a href="https://hydra.kosmosgame.com/jobset/github/nix_cpp_cartesian_dependencies#tabs-jobs">This article’s project in hydra</a></p>
<p>The code does a bit more than covered in this article: I added a nix expression <a href="https://github.com/tfc/nix_cpp_cartesian_dependencies/blob/master/output.nix"><code>output.nix</code></a> that does not only build the application in all variants, but also executes them and stores their results in the nix store. This way they can be looked at in the browser like here: <a href="https://hydra.kosmosgame.com/build/265">example output</a></p>
<h3 id="fully-reproducible-automatic-integration-tests">Fully Reproducible, Automatic Integration Tests</h3>
<p>Nix expressions do not only allow for simple ad-hoc packaging of binaries: They are mighty enough to describe whole-system descriptions. In fact, the NixOS installer ISOs, the Virtualbox NixOS demo VM image, the Amazon AMIs, Microsoft Azure Blobs, etc. are all built from nix expressions.</p>
<p>I build a little more complicated example and put it on github: <a href="https://github.com/tfc/nix_cmake_example" class="uri">https://github.com/tfc/nix_cmake_example</a></p>
<p>In a nutshell, this repository contains a C++ server application that uses PostgreSQL as a database backend and a Python client application that provides a little web server interface to the same database. In order to test such an application one needs a host with a confiured and running PostgreSQL instance.</p>
<p>The C++ app is built in different configurations - all configurations are automatically tested in VMs that are automatically created, spun up, and destroyed afterwards.</p>
<figure>
<img src="https://github.com/tfc/nix_cmake_example/raw/master/doc/hydra_nix_example.png" alt="Hydra example output" /><figcaption>Hydra example output</figcaption>
</figure>
<p>The whole output can be inspected on <a href="https://hydra.kosmosgame.com/jobset/github/nix_cmake_example#tabs-jobs" class="uri">https://hydra.kosmosgame.com/jobset/github/nix_cmake_example#tabs-jobs</a></p>
<h3 id="cross-compilation">Cross Compilation</h3>
<p>Just touching this topic by dropping some links</p>
<ul>
<li><a href="https://nixos.wiki/wiki/Cross_Compiling" class="uri">https://nixos.wiki/wiki/Cross_Compiling</a></li>
<li><a href="https://matthewbauer.us/blog/beginners-guide-to-cross.html" class="uri">https://matthewbauer.us/blog/beginners-guide-to-cross.html</a></li>
</ul>]]></description>
    <pubDate>Wed, 17 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2019/04/17/tutorial_nix_cpp_setup</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Managing libraries with Nix</title>
    <link>https://blog.galowicz.de/2018/02/27/managing_libraries_with_nix</link>
    <description><![CDATA[<p>While learning Haskell and using its really smart library dependency management tools (<a href="https://www.haskell.org/cabal/"><code>cabal</code></a> and <a href="https://docs.haskellstack.org/en/stable/README/"><code>stack</code></a>), i realized that the C++ eco system has a problem: There are no handy <em>established</em> tools that let the developer declare which libraries (and versions) are required for a project which can then be automatically installed in a portable way. <a href="https://nixos.org/nix/"><code>Nix</code></a> however convinced me to be more versatile and powerful than <a href="https://www.conan.io/">Conan</a> and handier than <a href="https://www.docker.com/">Docker</a>, <a href="https://www.vagrantup.com/">Vagrant</a>, etc. (although it’s fair to say that i am mixing use cases here a little bit!) In this article, i am going to showcase this great tool a little bit.</p>
<!--more-->
<p>This article is rather long (mostly because of many command line excerpts). Feel free to jump to the end, where we will compile and run the same project with 3 different compilers just by changing the command line a bit.</p>
<h2 id="use-case-example">Use case example</h2>
<p>So i have been developing a little library to see if i can implement a handy parser library in C++ that models how you build parsers in Haskell using the <a href="https://hackage.haskell.org/package/parsec"><code>parsec</code> library</a>.</p>
<p>The project can be checked out on <a href="https://github.com/tfc/attoparsecpp">github.com/tfc/attoparsecpp</a>. It is however not important to look into it. This article is not at all about parsers, Haskell, or my specific library. My little project shall just serve as an example project that has unit tests and benchmarks.</p>
<p>For libraries it is important that they build warning-free with:</p>
<ul>
<li>different compilers</li>
<li>even different compiler versions</li>
</ul>
<p>In addition to that, it is a nice-to-have to also compare the benchmark numbers among those!</p>
<p>However, the library has the following dependencies:</p>
<ul>
<li><a href="https://github.com/catchorg/Catch2"><code>catch</code></a> for building the unit tests</li>
<li><a href="https://github.com/google/benchmark"><code>benchmark</code> (from Google)</a> for building the benchmarks</li>
</ul>
<p>That means: in order to build this project you need to install those. Some developers just install them the oldschool way or they pull them in as git submodules and then embedd them into the <code>Makefile</code> (or <code>cmake</code> pendants etc.). Some other developers would define Docker images (or Vagrant etc.). There is also the Conan package manager which enables the developer to just define which libraries are needed.</p>
<h2 id="installing-nix">Installing Nix</h2>
<p>Let us now completely concentrate on Nix. What is it? <a href="https://nixos.org/nix/">The Nix homepage</a> states:</p>
<blockquote>
<p>Nix is a powerful package manager for Linux and other Unix systems that makes package management reliable and reproducible. It provides atomic upgrades and rollbacks, side-by-side installation of multiple versions of a package, multi-user package management and easy setup of build environments. …</p>
</blockquote>
<p>Nix can be installed on Linux, Mac, and other Unixes. (I guess it can be installed in the Linux-Subsystem on Windows, but i am not sure as i am no Windows user). Just as a side note: There is even a <a href="https://nixos.org/">Linux distribution called “NixOS”</a>.</p>
<p>The installation of Nix is really simple. Please first study the content of <a href="https://nixos.org/nix/install"><code>https://nixos.org/nix/install</code></a> and then run the following command in the bash (Or run the parts of the script you like. It is interesting how about 90% of the critisizm on Nix concentrate on this shell command.):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1">$ <span class="ex">curl</span> https://nixos.org/nix/install <span class="kw">|</span> <span class="fu">sh</span></a></code></pre></div>
<p>The installation script will download and extract a large tarball into the <code>/nix</code> folder on your system. In addition to that, it will activate a build daemon and create some user accounts in order to isolate things while building packages. After the installation, there will never be any need to use <code>sudo</code> in combination with nix calls again. It is generally possible to install nix on systems where even creating <code>/nix</code> is not allowed (see the <a href="https://nixos.wiki/wiki/Nix_Installation_Guide">installation guide</a> for more details).</p>
<h2 id="installing-project-dependencies">Installing project dependencies</h2>
<p>After cloning the C++ project on a mac where only <code>git</code> and <code>clang++</code>, we will have trouble building the project without installing the libraries:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="bu">cd</span> test <span class="kw">&amp;&amp;</span> <span class="fu">make</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">c++</span> -O2 -std=c++14 -c main.cpp</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ex">main.cpp</span>:2:10: fatal error: <span class="st">&#39;catch/catch.hpp&#39;</span> file not found</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">#include &lt;catch/catch.hpp&gt;</span></a>
<a class="sourceLine" id="cb2-5" title="5">         ^<span class="ex">~~~~~~~~~~~~~~~~</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="ex">1</span> error generated.</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ex">make</span>: *** [main.o] Error 1</a></code></pre></div>
<p>For the unit tests, we only need the <code>catch</code> library. That’s easy, as the Nix repository has that.</p>
<blockquote>
<p>Another “catch” is that the <code>make</code> call ended up invoking <code>c++</code>, which is our Mac system compiler that is not really prepared to be used with Nix-installations of packages. This is part of some mechanics which the Nix docs cover much better.</p>
</blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="ex">nix-env</span> -qaP --description <span class="kw">|</span> <span class="fu">grep</span> catch</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="ex">nixpkgs.catch</span>               catch-1.9.6               A multi-paradigm automated test framework for C++ and Objective-C (and, maybe, C)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co"># ...</span></a></code></pre></div>
<p>So let’s build it with catch installed:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1">$ <span class="ex">nix-shell</span> -p clang -p catch</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">[<span class="ex">nix-shell</span>:~/project_dir]$ cd test <span class="kw">&amp;&amp;</span> <span class="fu">make</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="fu">clang</span>++ -O2 -std=c++14 -c main.cpp</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include -c test.cpp</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ex">test.cpp</span>:127:46: error: too many arguments provided to function-like macro invocation</a>
<a class="sourceLine" id="cb4-7" title="7">            <span class="ex">REQUIRE</span>( r-<span class="op">&gt;</span>first == vect_t{<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>});</a>
<a class="sourceLine" id="cb4-8" title="8">                                             ^</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="ex">/nix/store/gsklw95pxb9npyqpfpczagchk8kdsgzb-catch-1.9.6/include/catch</span>/catch.hpp:<span class="ex">11450</span>:9: note: macro <span class="st">&#39;REQUIRE&#39;</span> defined here</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">#define REQUIRE( expr ) INTERNAL_CATCH_TEST( &quot;REQUIRE&quot;, Catch::ResultDisposition::Normal, expr  )</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co"># ...</span></a></code></pre></div>
<p>Ok, the compiler can find the <code>catch.hpp</code> header, but it does not compile. The problem here is that i wrote the unit tests with <code>catch2</code> and the package in the Nix repo is a little bit too old. I learned Nix the hard way by doing the following:</p>
<h2 id="writing-our-own-nix-expressions">Writing our own Nix expressions</h2>
<p>The Nix ecosystem provides a rich database of packages for everything which does not only include libraries, but also applications. In this case however, the library is too old and we need a more current one.</p>
<p>While the <code>catch</code> library just consists of a single header that is really easy to download, it is also a really simple example for building a Nix derivation that automatically obtains it from github and provides it for building. So let’s do that here. We will also install a newer google benchmark library (which is a bit more complicated as it is not header-only) this way later.</p>
<p>A Nix derivation is kind of a cooking recipe that tells where to get what and what to do with it in order to make it useful. In order to get catch version 2.1.2, we create a file <code>catch.nix</code> in the project folder:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><a class="sourceLine" id="cb5-1" title="1"># file: catch.nix</a>
<a class="sourceLine" id="cb5-2" title="2">{ stdenv, fetchurl }:</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4">stdenv.mkDerivation rec {</a>
<a class="sourceLine" id="cb5-5" title="5">  name = &quot;catch-${version}&quot;;</a>
<a class="sourceLine" id="cb5-6" title="6">  version = &quot;2.1.2&quot;;</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8">  src = fetchurl {</a>
<a class="sourceLine" id="cb5-9" title="9">      url = &quot;https://github.com/catchorg/Catch2/releases/download/v2.1.2/catch.hpp&quot;;</a>
<a class="sourceLine" id="cb5-10" title="10">      sha256 = &quot;e8b8f3109716891aa99b1a8e29cd0d627419bdc4a8d2eeef0d8370aaf8d5e483&quot;;</a>
<a class="sourceLine" id="cb5-11" title="11">  };</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13">  # It is just the file. No unpacking needed. Seems like we need to create</a>
<a class="sourceLine" id="cb5-14" title="14">  # _some_ folder, otherwise we get errors.</a>
<a class="sourceLine" id="cb5-15" title="15">  unpackCmd = &quot;mkdir dummy_dir&quot;;</a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17">  installPhase = &#39;&#39;</a>
<a class="sourceLine" id="cb5-18" title="18">    mkdir -p $out/include/catch</a>
<a class="sourceLine" id="cb5-19" title="19">    cp ${src} $out/include/catch/catch.hpp</a>
<a class="sourceLine" id="cb5-20" title="20">  &#39;&#39;;</a>
<a class="sourceLine" id="cb5-21" title="21"></a>
<a class="sourceLine" id="cb5-22" title="22">  meta = {</a>
<a class="sourceLine" id="cb5-23" title="23">    description = &quot;A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later&quot;;</a>
<a class="sourceLine" id="cb5-24" title="24">    homepage = http://catch-lib.net;</a>
<a class="sourceLine" id="cb5-25" title="25">  };</a>
<a class="sourceLine" id="cb5-26" title="26">}</a></code></pre></div>
<p>There is a lot of <em>voodoo</em> going on here for anyone who does not know Nix. Nix is its own scripting language (a purely functional one), that is why it that script initially looks so complicated. The important parts are:</p>
<ul>
<li>lines 8-11, <code>fetchurl</code>:
<ul>
<li>Where to get the catch header file?</li>
<li>For control reasons we also define what hash it needs to have.</li>
</ul></li>
<li>lines 17-20, <code>installPhase</code>:
<ul>
<li>We define that <code>catch.hpp</code> needs to be installed into <code>$out/include/catch/catch.hpp</code>, wherever that is.</li>
</ul></li>
</ul>
<p>Let us bring <code>nix-shell</code> to use that file and install catch for us:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">$ <span class="ex">nix-shell</span> -p <span class="st">&#39;with (import &lt;nixpkgs&gt; {}); callPackage ./catch.nix {}&#39;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ex">these</span> derivations will be built:</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="ex">/nix/store/byy8sgy8crdhzyvjxzzbq4zhg8kbvhpp-catch.hpp.drv</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="ex">/nix/store/v75n72czr0vgqz4zacrzk2wsrr1jg1kc-catch-2.1.2.drv</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="ex">these</span> paths will be fetched (0.82 MiB download, 4.50 MiB unpacked)<span class="bu">:</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="ex">/nix/store/0cs9d2ml9cql18l1vsxrdmjliiz0p0rg-bash-4.4-p12-info</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="ex">/nix/store/0p2m9iz8w4551qkgzsqvl2vm2ilyb6ww-stdenv-darwin</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="ex">/nix/store/2pvbzmacxfhm1akl9a5shqrk47i53cpv-libssh2-1.8.0-dev</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="ex">/nix/store/cxz0drsrlbmdi1krr0n57zfcswjmrv5i-mirrors-list</span></a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="ex">/nix/store/czw3qnwsify74b5bljll1lmm8k6kk09h-curl-7.55.1-dev</span></a>
<a class="sourceLine" id="cb6-11" title="11">  <span class="ex">/nix/store/icm30zksjzx8546d02y9gi4vzdi42j2w-bash-4.4-p12-man</span></a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="ex">/nix/store/kwclw4knsrs6l4fi98wnzg713r8p0wls-openssl-1.0.2l-dev</span></a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="ex">/nix/store/n2aycrbi6myl9wqr6b7w2n578j505czd-curl-7.55.1-man</span></a>
<a class="sourceLine" id="cb6-14" title="14">  <span class="ex">/nix/store/w4m16gcmlxsgx468p7k3993vwf6i6hsx-bash-4.4-p12-dev</span></a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="ex">/nix/store/yw461g3iqihmq6i1mrjn6khbwn6gx0rl-bash-4.4-p12-doc</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb6-17" title="17"><span class="ex">building</span> path(s) ‘<span class="ex">/nix/store</span>/<span class="ex">62g4h135grzi5xn5y7hyrxg1r8ac408g-catch-2.1.2</span>’</a>
<a class="sourceLine" id="cb6-18" title="18"><span class="ex">unpacking</span> sources</a>
<a class="sourceLine" id="cb6-19" title="19"><span class="ex">unpacking</span> source archive /nix/store/4nx2d1j5jnnb9zqlmpl45g68msqycfjy-catch.hpp</a>
<a class="sourceLine" id="cb6-20" title="20"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="ex">patching</span> script interpreter paths in /nix/store/62g4h135grzi5xn5y7hyrxg1r8ac408g-catch-2.1.2</a></code></pre></div>
<p>There was a lot going on after firing that command: Nix even installed <code>curl</code> and all its dependencies, because it needs a tool to download the header file. The last line tells us that there is now something in <code>/nix/store/62g4h135grzi5xn5y7hyrxg1r8ac408g-catch-2.1.2</code>. Let’s have a look into it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1">[<span class="ex">nix-shell</span>:~/Desktop/p]$ ls -lsa /nix/store/62g4h135grzi5xn5y7hyrxg1r8ac408g-catch-2.1.2/include/catch/catch.hpp</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ex">428</span> -r--r--r-- 1 root wheel 435409 Jan  1  1970 /nix/store/62g4h135grzi5xn5y7hyrxg1r8ac408g-catch-2.1.2/include/catch/catch.hpp</a></code></pre></div>
<p>Ok, so whenever we add this strange path to the compiler command line using <code>-I/nix/store/...</code>, then our tests will compile.</p>
<p>Let’s again start the nix shell with our catch derivation and clang and GNU make and try again:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">$ <span class="ex">nix-shell</span> -p clang <span class="st">&#39;with (import &lt;nixpkgs&gt; {}); callPackage ./catch.nix {}&#39;</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3">[<span class="ex">nix-shell</span>:~/project_dir]$ cd test <span class="kw">&amp;&amp;</span> <span class="fu">make</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="fu">clang</span>++ -O2 -std=c++14 -c main.cpp</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include -c test.cpp</a>
<a class="sourceLine" id="cb8-6" title="6"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include -c math_expression.cpp</a>
<a class="sourceLine" id="cb8-7" title="7"><span class="fu">clang</span>++ -o main main.o test.o math_expression.o</a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9">[<span class="ex">nix-shell</span>:~/project_dir]$ ./main</a>
<a class="sourceLine" id="cb8-10" title="10">===============================================================================</a>
<a class="sourceLine" id="cb8-11" title="11"><span class="ex">All</span> tests passed (172 assertions in 11 test cases)</a></code></pre></div>
<p>Yes, that went well!</p>
<blockquote>
<p>(The <code>-I/nix/store/...</code> parameter was handled for us implicitly) by the Nix-installed compiler</p>
</blockquote>
<p>It is however pretty ugly to call <code>nix-shell</code> with all those arguments that are hard to memorize. For this purpose we can define a <code>default.nix</code> file that will be automatically sourced by Nix:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="co"># file: default.nix</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">{</span> <span class="ex">pkgs</span> ? import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {<span class="kw">}</span>, }:</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ex">rec</span> {</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="ex">myProject</span> = pkgs.stdenv.mkDerivation {</a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="ex">name</span> = <span class="st">&quot;attoparsecpp&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="ex">version</span> = <span class="st">&quot;dev-0.1&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="ex">buildInputs</span> = with pkgs<span class="kw">;</span><span class="bu"> [</span></a>
<a class="sourceLine" id="cb9-8" title="8">      (callPackage ./catch.nix { })</a>
<a class="sourceLine" id="cb9-9" title="9">    ];</a>
<a class="sourceLine" id="cb9-10" title="10">  };</a>
<a class="sourceLine" id="cb9-11" title="11">}</a></code></pre></div>
<p>There’s again some voodoo for Nix-novices, but the important part is that we call our package <code>catch.nix</code> in the context of a standard build environment (<code>stdenv</code>). With <code>stdenv</code> we don’t need to reference the compiler explicitly any longer.</p>
<p>Now, we can do the following:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1">$ <span class="ex">nix-shell</span> --command <span class="st">&quot;cd test &amp;&amp; make -B -j4 &amp;&amp; ./main&quot;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="fu">clang</span>++ -O2 -std=c++14 -c main.cpp</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include -c test.cpp</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include -c math_expression.cpp</a>
<a class="sourceLine" id="cb10-5" title="5"><span class="fu">clang</span>++ -o main main.o test.o math_expression.o</a>
<a class="sourceLine" id="cb10-6" title="6">===============================================================================</a>
<a class="sourceLine" id="cb10-7" title="7"><span class="ex">All</span> tests passed (172 assertions in 11 test cases)</a></code></pre></div>
<p>Nix finds our <code>default.nix</code> file and gets everything in order.</p>
<p>Ok, great. How about running benchmarks?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1">$ <span class="ex">nix-shell</span> --command <span class="st">&quot;cd benchmark &amp;&amp; make -B -j4 &amp;&amp; ./main&quot;</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include main.cpp -o main -lbenchmark -lpthread</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ex">main.cpp</span>:7:10: fatal error: <span class="st">&#39;benchmark/benchmark.h&#39;</span> file not found</a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co">#include &lt;benchmark/benchmark.h&gt;</span></a>
<a class="sourceLine" id="cb11-5" title="5">         ^<span class="ex">~~~~~~~~~~~~~~~~~~~~~~</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="ex">1</span> error generated.</a>
<a class="sourceLine" id="cb11-7" title="7"><span class="ex">make</span>: *** [Makefile:8: main] Error 1</a></code></pre></div>
<p>Seems like we need to install google benchmark, too. There is a <code>gbenchmark</code> package, but it’s again too old. Nothing we couldn’t fix with our own Nix expression, though:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><a class="sourceLine" id="cb12-1" title="1"># file googlebench.nix</a>
<a class="sourceLine" id="cb12-2" title="2">{ stdenv, fetchFromGitHub, cmake }:</a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4">stdenv.mkDerivation rec {</a>
<a class="sourceLine" id="cb12-5" title="5">  name = &quot;googlebench-${version}&quot;;</a>
<a class="sourceLine" id="cb12-6" title="6">  version = &quot;1.3.0&quot;;</a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8">  src = fetchFromGitHub {</a>
<a class="sourceLine" id="cb12-9" title="9">      owner = &quot;google&quot;;</a>
<a class="sourceLine" id="cb12-10" title="10">      repo = &quot;benchmark&quot;;</a>
<a class="sourceLine" id="cb12-11" title="11">      rev = &quot;v${version}&quot;;</a>
<a class="sourceLine" id="cb12-12" title="12">      sha256 = &quot;1qx2dp7y0haj6wfbbfw8hx8sxb8ww0igdfrmmaaxfl0vhckylrxh&quot;;</a>
<a class="sourceLine" id="cb12-13" title="13">  };</a>
<a class="sourceLine" id="cb12-14" title="14"></a>
<a class="sourceLine" id="cb12-15" title="15">  nativeBuildInputs = [ cmake ];</a>
<a class="sourceLine" id="cb12-16" title="16"></a>
<a class="sourceLine" id="cb12-17" title="17">  meta = {</a>
<a class="sourceLine" id="cb12-18" title="18">    description = &quot;google benchmark&quot;;</a>
<a class="sourceLine" id="cb12-19" title="19">  };</a>
<a class="sourceLine" id="cb12-20" title="20">}</a></code></pre></div>
<p>Building the benchmark library involves compiling it with <code>cmake</code>, as it is more than just headers. Luckily, the Nix expression language came with its own library installed. It has handy little helpers like <code>fetchFromGitHub</code> that accepts some arguments needed to construct a download link from it and automatically unpack it!</p>
<p>The line <code>nativeBuildInputs</code> instructs Nix to install <code>cmake</code> for building this package. Everything else is automatically deduced. After adding this Nix derivation to our <code>default.nix</code> file, it will build google benchmark for us before we can run our own makefile:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1">$ <span class="ex">nix-shell</span> --command <span class="st">&quot;cd benchmark &amp;&amp; make -B -j4 &amp;&amp; ./main&quot;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ex">these</span> derivations will be built:</a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="ex">/nix/store/vbi7a7kjxz24zmq7lwaa044735hdlmb3-benchmark-v1.3.0-src.drv</span></a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="ex">/nix/store/il7biicbp3pa39nl5ffkyi9b1wwkw0b1-googlebench-1.3.0.drv</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="ex">these</span> paths will be fetched (0.12 MiB download, 0.44 MiB unpacked)<span class="bu">:</span></a>
<a class="sourceLine" id="cb13-6" title="6">  <span class="ex">/nix/store/i1b5rym52fhqkdz2kzaqn1gnk6nhf0b7-unzip-6.0</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="fu">clang</span>++ -O2 -std=c++14 -I../include main.cpp -o main -lbenchmark -lpthread</a>
<a class="sourceLine" id="cb13-9" title="9"><span class="ex">Run</span> on (8 X 2300 MHz CPU s)</a>
<a class="sourceLine" id="cb13-10" title="10"><span class="ex">2018-02-27</span> 21:50:34</a>
<a class="sourceLine" id="cb13-11" title="11"><span class="ex">-----------------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ex">Benchmark</span>                                Time           CPU Iterations</a>
<a class="sourceLine" id="cb13-13" title="13"><span class="ex">-----------------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="ex">measure_word_parsing/10</span>                 55 ns         55 ns   12703483</a>
<a class="sourceLine" id="cb13-15" title="15"><span class="ex">measure_word_parsing/100</span>              1107 ns       1105 ns     654444</a>
<a class="sourceLine" id="cb13-16" title="16"><span class="ex">measure_word_parsing/1000</span>             6021 ns       6012 ns     125101</a>
<a class="sourceLine" id="cb13-17" title="17"><span class="ex">measure_word_parsing/10000</span>           47889 ns      47812 ns      13667</a>
<a class="sourceLine" id="cb13-18" title="18"><span class="ex">measure_word_parsing/100000</span>         481643 ns     480574 ns       1428</a>
<a class="sourceLine" id="cb13-19" title="19"><span class="ex">measure_word_parsing/1000000</span>       4865444 ns    4854115 ns        130</a>
<a class="sourceLine" id="cb13-20" title="20"><span class="ex">measure_word_parsing/10000000</span>     54049501 ns   53973846 ns         13</a>
<a class="sourceLine" id="cb13-21" title="21"><span class="ex">measure_word_parsing_BigO</span>             5.40 N       5.39 N</a>
<a class="sourceLine" id="cb13-22" title="22"><span class="ex">measure_word_parsing_RMS</span>                 2 %          2 %</a>
<a class="sourceLine" id="cb13-23" title="23"><span class="ex">measure_vector_filling/10</span>              457 ns        455 ns    1683712</a>
<a class="sourceLine" id="cb13-24" title="24"><span class="ex">measure_vector_filling/100</span>            2282 ns       2279 ns     305181</a>
<a class="sourceLine" id="cb13-25" title="25"><span class="co"># ...</span></a></code></pre></div>
<p>Yes, that’s some successful benchmark output! This time it even installed <code>unzip</code> in case we don’t have it, yet.</p>
<p>However, we do not have to care about anything library-related other than linking. The Makefile does not reflect any knowledge of Nix or the install location of our dependencies:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" title="1">$ <span class="fu">cat</span> benchmark/Makefile</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ex">default</span>: main</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="va">CXXFLAGS=</span>-O2 <span class="ex">-std</span>=c++14</a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="va">LDFLAGS=</span>-lbenchmark <span class="ex">-lpthread</span></a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="ex">main</span>: main.cpp ../include/parser.hpp ../include/math_expression.hpp</a>
<a class="sourceLine" id="cb14-9" title="9">	<span class="va">$(</span><span class="ex">CXX</span><span class="va">)</span> <span class="va">$(</span><span class="ex">CXXFLAGS</span><span class="va">)</span> <span class="ex">-I../include</span> main.cpp -o main <span class="va">$(</span><span class="ex">LDFLAGS</span><span class="va">)</span></a>
<a class="sourceLine" id="cb14-10" title="10"></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="ex">clean</span>:</a>
<a class="sourceLine" id="cb14-12" title="12">	<span class="fu">rm</span> -rf main *.o</a></code></pre></div>
<h2 id="compiling-and-running-tests-with-different-compilers">Compiling and running tests with different compilers</h2>
<p>So… when pulling in compilers and libraries is so simple with Nix - how about checking if our library compiles with all compilers and versions of those?</p>
<p>We need to add a little modification to the <code>default.nix</code> file in order to <em>parametrize</em> it:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><a class="sourceLine" id="cb15-1" title="1"># file default.nix</a>
<a class="sourceLine" id="cb15-2" title="2">{</a>
<a class="sourceLine" id="cb15-3" title="3">    pkgs   ? import &lt;nixpkgs&gt; {},</a>
<a class="sourceLine" id="cb15-4" title="4">    stdenv ? pkgs.stdenv</a>
<a class="sourceLine" id="cb15-5" title="5">}:</a>
<a class="sourceLine" id="cb15-6" title="6">rec {</a>
<a class="sourceLine" id="cb15-7" title="7">  myProject = stdenv.mkDerivation {</a>
<a class="sourceLine" id="cb15-8" title="8">    name = &quot;attoparsecpp&quot;;</a>
<a class="sourceLine" id="cb15-9" title="9">    version = &quot;dev-0.1&quot;;</a>
<a class="sourceLine" id="cb15-10" title="10">    buildInputs = with pkgs; [</a>
<a class="sourceLine" id="cb15-11" title="11">      (callPackage ./catch.nix { })</a>
<a class="sourceLine" id="cb15-12" title="12">      (callPackage ./googlebench.nix { stdenv = stdenv; })</a>
<a class="sourceLine" id="cb15-13" title="13">    ];</a>
<a class="sourceLine" id="cb15-14" title="14">  };</a>
<a class="sourceLine" id="cb15-15" title="15">}</a></code></pre></div>
<p>We applied the following changes:</p>
<ul>
<li>line 4: We added <code>stdenv</code> as a named parameter of this Nix derivation. <code>pkgs.stdenv</code> is its default value.</li>
<li>line 7: Now we use <code>stdenv.mkDerivation</code> instead of <code>pkgs.stdenv.mkDerivation</code>.</li>
<li>line 12: If our <code>stdenv</code> changes, this change is also forwarded into the <code>googlebench.nix</code> derivation. (Which then needs to be built just for this compiler, too)</li>
</ul>
<p>With this change, we can now build and execute our tests with different compilers just by changing varying <code>nix-shell</code> arguments. Let’s try GCC now:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb16-1" title="1">$ <span class="ex">nix-shell</span> \</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="op">&gt;</span>  --command <span class="st">&quot;</span><span class="dt">\$</span><span class="st">CXX --version &amp;&amp; cd test &amp;&amp; make -B -j4 &amp;&amp; ./main&quot;</span> \</a>
<a class="sourceLine" id="cb16-3" title="3"><span class="op">&gt;</span>  --arg stdenv <span class="st">&quot;with (import &lt;nixpkgs&gt; {}); gccStdenv&quot;</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="ex">these</span> derivations will be built:</a>
<a class="sourceLine" id="cb16-5" title="5">  <span class="ex">/nix/store/cs2r1wbz8n33fspdlqrcm5pf174qdgcj-googlebench-1.3.0.drv</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="ex">these</span> paths will be fetched (35.32 MiB download, 145.96 MiB unpacked)<span class="bu">:</span></a>
<a class="sourceLine" id="cb16-7" title="7">  <span class="ex">/nix/store/1krs71lr68pvwjf21fq3f8wbw4c460sh-gcc-6.4.0</span></a>
<a class="sourceLine" id="cb16-8" title="8">  <span class="ex">/nix/store/gya4nskw8khp28vy0f8m01lf4z8337cz-stdenv-darwin</span></a>
<a class="sourceLine" id="cb16-9" title="9">  <span class="ex">/nix/store/yn7m3qnp0m3kf1acpjyxwqxzf3b40jf8-gcc-wrapper-6.4.0</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="ex">g++</span> (GCC) <span class="ex">6.4.0</span></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="ex">Copyright</span> (C) <span class="ex">2017</span> Free Software Foundation, Inc.</a>
<a class="sourceLine" id="cb16-13" title="13"><span class="ex">This</span> is free software<span class="kw">;</span> <span class="ex">see</span> the source for copying conditions.  There is NO</a>
<a class="sourceLine" id="cb16-14" title="14"><span class="ex">warranty</span><span class="kw">;</span> <span class="ex">not</span> even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</a>
<a class="sourceLine" id="cb16-15" title="15"></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="ex">g++</span> -O2 -std=c++14 -c main.cpp</a>
<a class="sourceLine" id="cb16-17" title="17"><span class="ex">g++</span> -O2 -std=c++14 -I../include -c test.cpp</a>
<a class="sourceLine" id="cb16-18" title="18"><span class="ex">g++</span> -O2 -std=c++14 -I../include -c math_expression.cpp</a>
<a class="sourceLine" id="cb16-19" title="19"><span class="ex">g++</span> -o main main.o test.o math_expression.o</a>
<a class="sourceLine" id="cb16-20" title="20">===============================================================================</a>
<a class="sourceLine" id="cb16-21" title="21"><span class="ex">All</span> tests passed (172 assertions in 11 test cases)</a></code></pre></div>
<p>The magic <code>--arg stdenv "with (import &lt;nixpkgs&gt; {}); gccStdenv"</code> line pushed a GCC build environment into the <code>stdenv</code> variable. The <code>$CXX --version</code> command in the <code>--command</code> part of the command line shows that it’s really GCC 6.4.0 now (instead of clang).</p>
<p>We can do the same with GCC 7:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1">$ <span class="ex">nix-shell</span> \</a>
<a class="sourceLine" id="cb17-2" title="2">  --command <span class="st">&quot;</span><span class="dt">\$</span><span class="st">CXX --version &amp;&amp; cd test &amp;&amp; make -B -j4 &amp;&amp; ./main&quot;</span> \</a>
<a class="sourceLine" id="cb17-3" title="3">  --arg stdenv <span class="st">&quot;with (import &lt;nixpkgs&gt; {}); overrideCC gccStdenv gcc7&quot;</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="ex">these</span> derivations will be built:</a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="ex">/nix/store/860fz8zccpxnia4ahzmxcvygms29nn1y-stdenv-darwin.drv</span></a>
<a class="sourceLine" id="cb17-6" title="6">  <span class="ex">/nix/store/lnhid58mlkgcaqq6dg0mnaly7y2p1ap4-googlebench-1.3.0.drv</span></a>
<a class="sourceLine" id="cb17-7" title="7"><span class="ex">these</span> paths will be fetched (37.09 MiB download, 154.89 MiB unpacked)<span class="bu">:</span></a>
<a class="sourceLine" id="cb17-8" title="8">  <span class="ex">/nix/store/27mxffxnw9q070wqfzhpn3p32h0kafws-gcc-7.2.0-lib</span></a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="ex">/nix/store/nknfwhafb2cwlrrwxh5dcwbdznf1fzq1-gcc-7.2.0</span></a>
<a class="sourceLine" id="cb17-10" title="10">  <span class="ex">/nix/store/xxb7a4i2y7mn6y0mkkzgy2cgnd78hahp-gcc-wrapper-7.2.0</span></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="ex">g++</span> (GCC) <span class="ex">7.2.0</span></a>
<a class="sourceLine" id="cb17-13" title="13"><span class="ex">Copyright</span> (C) <span class="ex">2017</span> Free Software Foundation, Inc.</a>
<a class="sourceLine" id="cb17-14" title="14"><span class="ex">This</span> is free software<span class="kw">;</span> <span class="ex">see</span> the source for copying conditions.  There is NO</a>
<a class="sourceLine" id="cb17-15" title="15"><span class="ex">warranty</span><span class="kw">;</span> <span class="ex">not</span> even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</a>
<a class="sourceLine" id="cb17-16" title="16"></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="ex">g++</span> -O2 -std=c++14 -c main.cpp</a>
<a class="sourceLine" id="cb17-18" title="18"><span class="ex">g++</span> -O2 -std=c++14 -I../include -c test.cpp</a>
<a class="sourceLine" id="cb17-19" title="19"><span class="ex">g++</span> -O2 -std=c++14 -I../include -c math_expression.cpp</a>
<a class="sourceLine" id="cb17-20" title="20"><span class="ex">g++</span> -o main main.o test.o math_expression.o</a>
<a class="sourceLine" id="cb17-21" title="21">===============================================================================</a>
<a class="sourceLine" id="cb17-22" title="22"><span class="ex">All</span> tests passed (172 assertions in 11 test cases)</a></code></pre></div>
<p>Easy. It downloads <em>another</em> GCC and uses that for building.</p>
<p>Using the same strategy, we can also run our benchmarks with all these compilers. We could even write a Nix derivation that actually does this and generates a nice GNUPlot chart from all benchmark runs.</p>
<h2 id="fallout">Fallout</h2>
<p>While playing around, we installed at least 3 different compilers and recompiled the google benchmark library for each of them. A nice thing about this is that this all needs to be done only once. The resulting packages can then be used again on the next invocation of a <code>nix-shell</code> environment. Even better: if another project happens to need the same compiler/libraries, then they are in place already! These things are shared system wide now:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1">$ <span class="fu">find</span> /nix/store <span class="dt">\(</span> -name <span class="st">&quot;*googlebench*&quot;</span> -or -name <span class="st">&quot;*gcc*&quot;</span> -or -name <span class="st">&quot;*catch*&quot;</span> or -name <span class="st">&quot;*clang*&quot;</span> <span class="dt">\)</span> -type d -maxdepth 1</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="ex">/nix/store/62g4h135grzi5xn5y7hyrxg1r8ac408g-catch-2.1.2</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="ex">/nix/store/2bz86w853wz8q036armrqzds1wh41l2d-googlebench-1.3.0</span></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="ex">/nix/store/294rz6hxllqp5iqag01p2ymv37g25zhz-googlebench-1.3.0</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="ex">/nix/store/02hca1p50i735iimv28cj9l0lmdzwljn-googlebench-1.3.0</span></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="ex">/nix/store/5giskx5cy9q2qhv946svwmqw77vbr2iy-clang-4.0.1</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="ex">/nix/store/mx8870valpdhywaaq16sdiiajrpyj4q7-clang-wrapper-4.0.1</span></a>
<a class="sourceLine" id="cb18-8" title="8"><span class="ex">/nix/store/1krs71lr68pvwjf21fq3f8wbw4c460sh-gcc-6.4.0</span></a>
<a class="sourceLine" id="cb18-9" title="9"><span class="ex">/nix/store/1p5bg2c6pd2v1lgnf0823sxcilf73ydi-gcc-6.4.0-lib</span></a>
<a class="sourceLine" id="cb18-10" title="10"><span class="ex">/nix/store/yn7m3qnp0m3kf1acpjyxwqxzf3b40jf8-gcc-wrapper-6.4.0</span></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="ex">/nix/store/nknfwhafb2cwlrrwxh5dcwbdznf1fzq1-gcc-7.2.0</span></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="ex">/nix/store/27mxffxnw9q070wqfzhpn3p32h0kafws-gcc-7.2.0-lib</span></a>
<a class="sourceLine" id="cb18-13" title="13"><span class="ex">/nix/store/xxb7a4i2y7mn6y0mkkzgy2cgnd78hahp-gcc-wrapper-7.2.0</span></a></code></pre></div>
<p>So we can see that we have one version of clang, two versions of GCC, just one version of catch and three versions of googlebench. There is of course only one version of catch becasue it is just a header that does not need to be recompiled for different compilers.</p>
<p>But how does Nix know which googlebench installation belongs to which clang/GCC?</p>
<p>The long cryptic prefix of every package folder is the <em>hash of its build configuration</em>! The compiler choice is part of the build configuration, of course.</p>
<p>If another project has dependencies that overlap with ours in the sense that some dependency turns out to have the same configuraiton hash for the same package, then it will be shared. As soon as the configuration changes a little bit - another package is created.</p>
<p>We can now delete everything with one command:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" title="1">$ <span class="ex">nix-collect-garbage</span> -d</a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ex">removing</span> old generations of profile /nix/var/nix/profiles/per-user/tfc/profile</a>
<a class="sourceLine" id="cb19-3" title="3"><span class="ex">removing</span> old generations of profile /nix/var/nix/profiles/per-user/tfc/channels</a>
<a class="sourceLine" id="cb19-4" title="4"><span class="ex">finding</span> garbage collector roots...</a>
<a class="sourceLine" id="cb19-5" title="5"><span class="co"># ...</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="ex">deleting</span> unused links...</a>
<a class="sourceLine" id="cb19-7" title="7"><span class="ex">note</span>: currently hard linking saves 0.00 MiB</a>
<a class="sourceLine" id="cb19-8" title="8"><span class="ex">606</span> store paths deleted, 358.10 MiB freed</a></code></pre></div>
<p>That’s it. Our system is free of everything what was installed just for this project.</p>
<h2 id="purity">Purity</h2>
<p>By running <code>nix-shell --pure</code>, it is possible to <em>hide</em> everything which was not explicitly declared to be available:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1">$ <span class="ex">nix-shell</span> --pure -p gcc7</a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3">[<span class="ex">nix-shell</span>:~]$ clang++</a>
<a class="sourceLine" id="cb20-4" title="4"><span class="ex">bash</span>: clang++: command not found</a>
<a class="sourceLine" id="cb20-5" title="5"></a>
<a class="sourceLine" id="cb20-6" title="6">[<span class="ex">nix-shell</span>:~]$ exit</a>
<a class="sourceLine" id="cb20-7" title="7"></a>
<a class="sourceLine" id="cb20-8" title="8">$ <span class="ex">nix-shell</span> --pure -p clang</a>
<a class="sourceLine" id="cb20-9" title="9"></a>
<a class="sourceLine" id="cb20-10" title="10">[<span class="ex">nix-shell</span>:~]$ g++</a>
<a class="sourceLine" id="cb20-11" title="11"><span class="ex">bash</span>: g++: command not found</a></code></pre></div>
<p>Using <code>--pure</code>, we can check if our <code>default.nix</code> <em>really</em> contains the complete list of dependencies. That feature is something most other dependency management tools don’t do for us.</p>
<p>This way it cannot happen that a project builds on one computer, but not on the other, just because someone forgot to install something else that is implicitly needed.</p>
<h2 id="summary">Summary</h2>
<p>Nix just helped us with:</p>
<ul>
<li>fetching, compiling, and installing dependencies including compilers and libraries</li>
<li>easily changing the compiler and version between builds</li>
<li>managing all those dependencies without interference</li>
<li>getting rid of it again</li>
</ul>
<p>Maybe Conan would also have been able to do that (apart from the <code>--pure</code> feature). Nix however does not only work for C/C++ projects: It can be used for Rust, Haskell, Python, Ruby, etc. etc. - because it is a <em>universal</em> dependency manager.</p>
<p>Writing your own Nix derivations is only necessary if custom- or extremely new package versions are needed. It is also not hard to do. Existing packages can be rebuilt with different configurations, too.</p>
<p>Being completely amazed, i also installed NixOS on my laptop. What’s great there is that i am now able to configure the whole system with just one <code>.nix</code> configuration file. When that file changes, Nix automatically restarts only the affected services. If it does not work, then it is possible to roll the system back to a previous configuration. (Remember all the stuff in <code>/nix/store/...</code>? It’s still there until it’s garbage-collected!) The same system configuration could be used to clone the system elsewhere, etc.</p>
<p>This article is really just scratching the surface of Nix/NixOS’s possibilities.</p>]]></description>
    <pubDate>Tue, 27 Feb 2018 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2018/02/27/managing_libraries_with_nix</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Iterators are also part of the C++ zero cost abstractions</title>
    <link>https://blog.galowicz.de/2017/07/02/order2_iterator</link>
    <description><![CDATA[<p>This article picks up an example operating system kernel code snippet that is written in C++, but looks like “C with classes”. I think it is a great idea to implement Embedded projects/kernels in C++ instead of C and it’s nice to see that the number of embedded system developers that use C++ is rising. Unfortunately, I see stagnation in terms of modern programming in embedded/kernel projects in the industry. After diving through the context i demonstrate how to implement a nice iterator as a zero cost abstraction that helps tidy up the code.</p>
<!--more-->
<h2 id="the-real-life-story">The real life story</h2>
<blockquote>
<p>This context dive is rather long. If you dont care about the actual logic behind the code, just jump to the next section.</p>
</blockquote>
<p>As an intern at Intel Labs in 2012, I had my first contact with microkernel operating systems that were implemented in C++. This article concentrates on a recurring code pattern that I have seen very often in the following years also in other companies. I have the opinion that such code should be written <em>once</em> as a little library helper.</p>
<p>Let’s jump right into it: Most operating systems allow processes to share memory. Memory is then usually shared by one process that tells the operating system kernel to map a specific memory range into the address space of another process, possibly at some different address than where it is visible for the original process.</p>
<p>In those <a href="https://en.wikipedia.org/wiki/Microkernel">microkernel operating system</a> environments I have been working on, memory ranges were described in a very specific way: The beginning of a chunk is described by its <em>page number</em> in the virtual memory space. The size of a chunk is described by its <em>order</em>.</p>
<blockquote>
<p>Both these characteristics are then part of a <em>capability range descriptor</em> and are used by some microkernel operating systems to describe ranges of memory, I/O ports, kernel objects, etc. Capabilities are a <a href="https://en.wikipedia.org/wiki/Capability-based_security">security concept</a> i would like to ignore as much as possible for now, because the scope of this article is the maths behind capability range descriptors.</p>
</blockquote>
<p>Example: A memory range that is 4 memory pages large and begins at address <code>0x123000</code> is described by <code>(0x123, 2)</code>. We get from <code>0x123000</code> to <code>0x123</code>, because pages are 4096 bytes (0x1000 in hex) large. That means that we need to divide a virtual address pointer value by <code>0x1000</code> and get a virtual page number. From 4 pages we get to the order value <code>2</code>, because <span class="math inline">4 = 2<sup>2</sup></span>, so the order is 2.</p>
<p>Ok, that is simple. It stops being simple as soon as one describes real-life memory ranges. Such a <code>(base, order)</code> tuple is also called a <em>capability range descriptor</em>, and must follow the following rules:</p>
<ol type="1">
<li>Every memory capability’s size must be a power of 2. (By storing only the order, this rule is implicitly followed by design.)</li>
<li>Every capability’s base must be evenly divisible by its size.</li>
</ol>
<p>That means if we want to describe the memory range <code>[0x100, 0x107)</code> (the notation <code>[a, b)</code> means that the range goes from <code>a</code> to <code>b</code>, but does not contain <code>b</code>. Like it is the case for begin/end iterator pairs) following those rules, we would break it into multiple capability range descriptors:</p>
<ul>
<li><code>(0x100, 2)</code>, <span class="math inline">2<sup>2</sup> = 4</span> pages</li>
<li><code>(0x104, 1)</code>, <span class="math inline">2<sup>1</sup> = 2</span> pages</li>
<li><code>(0x106, 0)</code>, <span class="math inline">2<sup>0</sup> = 1</span> pages</li>
</ul>
<p>Let’s get towards actual code: Mapping such an example range to another process’s address space would then look like the following code, which maps its own range <code>[0x100, 0x107)</code> to <code>[0x200, 0x207)</code> in the namespace of the other process using a structure <code>map_helper</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1">map_helper.source_base = <span class="bn">0x100</span>;</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">map_helper.push_back(<span class="bn">0x200</span>, <span class="dv">2</span>); <span class="co">// 2^2 pages = 4 pages</span></a>
<a class="sourceLine" id="cb1-4" title="4">map_helper.push_back(<span class="bn">0x204</span>, <span class="dv">1</span>); <span class="co">// 2^1 pages = 2 page</span></a>
<a class="sourceLine" id="cb1-5" title="5">map_helper.push_back(<span class="bn">0x206</span>, <span class="dv">0</span>); <span class="co">// 2^0 pages = 1 page</span></a>
<a class="sourceLine" id="cb1-6" title="6">                                <span class="co">//       sum = 7 pages</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">map_helper.delegate(target_address_space);</a></code></pre></div>
<p>The <code>map_helper.delegate(...)</code> call results in a system call to the kernel which does the actual memory mapping. In order to not result in one system call per mapping, <code>map_helper</code> accepts a whole batch of mappings that are sent to the kernel in one run.</p>
<blockquote>
<p>This looks very complicated but it is necessary to keep the microkernel <em>micro</em>. When the kernel gets mapping requests preformatted like this, the kernel code that applies the mapping contains much less complicated logic. An operating system kernel with a reduced amount of complicated logic is a good thing to have because then it is easier to prove that it is <em>correct</em>.</p>
</blockquote>
<p>Ok, that is nearly everything about expressing memory mappings with the logic of capability range descriptors. There is one last quirk.</p>
<p>Imagine we want to map the range <code>[0x0, 0x10)</code>, which can be expressed as <code>(0x0, 4)</code> (<code>0x10 = 16</code>, and <span class="math inline">16 = 2<sup>4</sup></span>), to the range <code>[0x1, 0x11)</code> in the other process’s address space. That should be easy since they only have an offset of 1 page to each other. What is visible at address <code>0x1000</code> in the first process, will be visible at address <code>0x2000</code> in the other. Actually, it is not that easy, because the capability range descriptor <code>(0x0, 4)</code> can not simply be described as <code>(0x1, 4)</code> in the other process’s address space. It violates rule number 2 because <code>0x1</code> is not evenly divisible by <code>0x10</code>!</p>
<p>Frustratingly, this means that we need to break down the whole descriptor <code>(0x0, 4)</code> into 16 descriptors with order <code>0</code> because only such small ones have mappings that comply with the two rules in <strong>both</strong> address spaces.</p>
<p>This was already a worst-case example. Another less bad example is the following one: If we want to map <code>[0x0, 0x10)</code> to <code>[0x8, 0x18)</code> in the other process, we could do that with the two descriptors <code>(0, 3)</code> and <code>(8, 3)</code>, because both offsets <code>0x0</code> and <code>0x8</code> are evenly divisible by 8. That allows for larger chunks.</p>
<p>A generic function that maps <em>any</em> page range to another process’s address space could finally look like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> map(<span class="dt">word_t</span> base1, <span class="dt">word_t</span> base2, <span class="dt">word_t</span> size, <span class="dt">foo_t</span> target_address_space)</a>
<a class="sourceLine" id="cb2-2" title="2">{</a>
<a class="sourceLine" id="cb2-3" title="3">    map_helper.source_base = base1;</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">constexpr</span> <span class="dt">word_t</span> max_bit {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; (<span class="dv">8</span> * <span class="kw">sizeof</span>(max_bit) - <span class="dv">1</span>)};</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="cf">while</span> (size) {</a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="co">// take smaller order of both bases, as both must be divisible by it.</span></a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="at">const</span> <span class="dt">word_t</span> min_order {order_min(base1 | base2 | max_bit)};</a>
<a class="sourceLine" id="cb2-10" title="10">        <span class="co">// take largest possible order from actual size of unmapped rest</span></a>
<a class="sourceLine" id="cb2-11" title="11">        <span class="at">const</span> <span class="dt">word_t</span> max_order {order_max(size)};</a>
<a class="sourceLine" id="cb2-12" title="12">        <span class="co">// choose smaller of both</span></a>
<a class="sourceLine" id="cb2-13" title="13">        <span class="at">const</span> <span class="dt">word_t</span> order     {min(min_order, max_order)};</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15">        map_helper.push_back(base2, order);</a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17">        <span class="cf">if</span> (map_helper.full()) {</a>
<a class="sourceLine" id="cb2-18" title="18">            map_helper.delegate(target_address_space);</a>
<a class="sourceLine" id="cb2-19" title="19">            map_helper.reset();</a>
<a class="sourceLine" id="cb2-20" title="20">            map_helper.source_base = base1;</a>
<a class="sourceLine" id="cb2-21" title="21">        }</a>
<a class="sourceLine" id="cb2-22" title="22"></a>
<a class="sourceLine" id="cb2-23" title="23">        <span class="at">const</span> <span class="dt">word_t</span> step {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; order};</a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25">        base1 += step;</a>
<a class="sourceLine" id="cb2-26" title="26">        base2 += step;</a>
<a class="sourceLine" id="cb2-27" title="27">        size  -= step;</a>
<a class="sourceLine" id="cb2-28" title="28">    }</a>
<a class="sourceLine" id="cb2-29" title="29"></a>
<a class="sourceLine" id="cb2-30" title="30">    map_helper.delegate(target_address_space);</a>
<a class="sourceLine" id="cb2-31" title="31">}</a></code></pre></div>
<p>As a newcomer to such a project, you will soon understand the maths behind it. You will see it everywhere, because the same technique is used for sharing memory, I/O ports, and descriptors for kernel objects like threads, semaphores, etc. between processes.</p>
<p>After you have seen repeatedly exactly the same calculation with different <em>payload</em> code between it, you might get sick of it. Everywhere in the code base where this pattern is repeated, you have to follow the calculations thoroughly in order to see if it is <strong>really</strong> the same formula. If it is, you may wonder why no one writes some kind of library for it instead of duplicating the formula in code again and again. And if it is <em>not</em> the same formula - is that because it is wrong or is there an actual idea behind that? It is plainly annoying to write and read this from the ground on all the time.</p>
<h2 id="library-thoughts">Library thoughts</h2>
<p>Ok, let’s assume that this piece of math will be recurring very often and we want to provide a nice abstraction for it. This would have multiple advantages:</p>
<ul>
<li>Reduced code duplication.</li>
<li>Correctness: The library can be tested meticulously, and all user code will automatically profit from that. No one could ever do wrong descriptor calculations any longer if he/she just used the library.</li>
<li>Readability: User code will not be polluted by the same calculations again and again. Users do not even need to be able to implement the maths themselves.</li>
</ul>
<p>One possibility is to write a function <code>map_generic</code> that accepts a callback function that would get already calculated chunks as parameters and that would then do the payload magic:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">void</span> map_generic(<span class="dt">word_t</span> base1, <span class="dt">word_t</span> base2, <span class="dt">word_t</span> size, F f)</a>
<a class="sourceLine" id="cb3-3" title="3">{</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">constexpr</span> <span class="dt">word_t</span> max_bit {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; (<span class="dv">8</span> * <span class="kw">sizeof</span>(max_bit) - <span class="dv">1</span>)};</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="cf">while</span> (size) {</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="co">// take smallest order of both bases, as both must be divisible by it.</span></a>
<a class="sourceLine" id="cb3-8" title="8">        <span class="at">const</span> <span class="dt">word_t</span> min_order {order_min(base1 | base2 | max_bit)};</a>
<a class="sourceLine" id="cb3-9" title="9">        <span class="co">// take largest possible order from actual size of unmapped rest</span></a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="at">const</span> <span class="dt">word_t</span> max_order {order_max(size)};</a>
<a class="sourceLine" id="cb3-11" title="11">        <span class="co">// choose smallest of both</span></a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="at">const</span> <span class="dt">word_t</span> order     {min(min_order, max_order)};</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">        f(base1, base2, order);</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="at">const</span> <span class="dt">word_t</span> step {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; order};</a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18">        base1 += step;</a>
<a class="sourceLine" id="cb3-19" title="19">        base2 += step;</a>
<a class="sourceLine" id="cb3-20" title="20">        size  -= step;</a>
<a class="sourceLine" id="cb3-21" title="21">    }</a>
<a class="sourceLine" id="cb3-22" title="22">}</a>
<a class="sourceLine" id="cb3-23" title="23"></a>
<a class="sourceLine" id="cb3-24" title="24"><span class="dt">void</span> map(<span class="dt">word_t</span> base1, <span class="dt">word_t</span> base2, <span class="dt">word_t</span> size, <span class="dt">foo_t</span> target_address_space)</a>
<a class="sourceLine" id="cb3-25" title="25">{</a>
<a class="sourceLine" id="cb3-26" title="26">    map_helper.source_base = base1;</a>
<a class="sourceLine" id="cb3-27" title="27"></a>
<a class="sourceLine" id="cb3-28" title="28">    map_generic(base1, base2, size, </a>
<a class="sourceLine" id="cb3-29" title="29">        [&amp;map_helper](<span class="dt">word_t</span> b1, <span class="dt">word_t</span> b2, <span class="dt">word_t</span> order) {</a>
<a class="sourceLine" id="cb3-30" title="30">            map_helper.push_back(b2, order);</a>
<a class="sourceLine" id="cb3-31" title="31"></a>
<a class="sourceLine" id="cb3-32" title="32">            <span class="cf">if</span> (map_helper.full()) {</a>
<a class="sourceLine" id="cb3-33" title="33">                map_helper.delegate(target_address_space);</a>
<a class="sourceLine" id="cb3-34" title="34">                map_helper.reset();</a>
<a class="sourceLine" id="cb3-35" title="35">                map_helper.source_base = b1;</a>
<a class="sourceLine" id="cb3-36" title="36">            }</a>
<a class="sourceLine" id="cb3-37" title="37">        });</a>
<a class="sourceLine" id="cb3-38" title="38"></a>
<a class="sourceLine" id="cb3-39" title="39">    map_helper.delegate(target_address_space);</a>
<a class="sourceLine" id="cb3-40" title="40">}</a></code></pre></div>
<p>What we have is now the pure math of capability range composition of generic ranges in <code>map_generic</code> and actual memory mapping code in <code>map</code>. This is already much better but leaves us without control <em>how many</em> chunks we actually want to consume at a time. As soon as we start <code>map_generic</code>, it will shoot all the sub-ranges at our callback function. At this point, it is hard to stop. And if we were able to stop it (for example by returning <code>true</code> from the callback whenever it shall continue and returning <code>false</code> if it shall stop), it would be hard to resume from where we stopped it. It’s just hardly composable coding style.</p>
<h2 id="the-iterator-library">The iterator library</h2>
<p>After all, this is C++. Can’t we have some really nice and composable things here? Of course, we can. How about iterators? We could define an iterable range class which we can feed with our memory geometry. When such a range is iterated over, it emits the sub-ranges.</p>
<p>So let’s implement this in terms of an iterator. If you don’t know yet how to implement iterators, you might want to have a look at <a href="/2016/09/04/algorithms_in_iterators">my other article where i explain how to implement your own iterator</a>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span><span class="pp">   </span><span class="co">// uintptr_t</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span><span class="pp"> </span><span class="co">// min/max</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">using</span> <span class="dt">word_t</span> = <span class="dt">uintptr_t</span>;</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="at">static</span> <span class="dt">word_t</span> current_order(<span class="dt">word_t</span> base, <span class="dt">word_t</span> rest) {</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="at">const</span> <span class="dt">word_t</span> max_bit   {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; (<span class="dv">8</span> * <span class="kw">sizeof</span>(max_bit) - <span class="dv">1</span>)};</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="at">const</span> <span class="dt">word_t</span> min_order {order_min(base | max_bit)};</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="at">const</span> <span class="dt">word_t</span> max_order {order_max(rest)};</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="cf">return</span> <span class="bu">std::</span>min(min_order, max_order);</a>
<a class="sourceLine" id="cb4-12" title="12">}</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">// This class is iterable range and iterator at the same time</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="kw">struct</span> order_range</a>
<a class="sourceLine" id="cb4-16" title="16">{</a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="dt">word_t</span> base1;</a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="dt">word_t</span> base2;</a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="dt">word_t</span> size;</a>
<a class="sourceLine" id="cb4-20" title="20"></a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="co">// operator-Xs fulfill the iterator interface</span></a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="bu">std::</span>tuple&lt;<span class="dt">word_t</span>, <span class="dt">word_t</span>, <span class="dt">word_t</span>&gt; <span class="kw">operator</span>*() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb4-23" title="23">        <span class="cf">return</span> {base1, base2,</a>
<a class="sourceLine" id="cb4-24" title="24">                current_order(base1 | base2, size)};</a>
<a class="sourceLine" id="cb4-25" title="25">    }</a>
<a class="sourceLine" id="cb4-26" title="26"></a>
<a class="sourceLine" id="cb4-27" title="27">    order_range&amp; <span class="kw">operator</span>++() {</a>
<a class="sourceLine" id="cb4-28" title="28">        <span class="kw">auto</span> step (<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; current_order(base1 | base2, size));</a>
<a class="sourceLine" id="cb4-29" title="29">        base1 += step;</a>
<a class="sourceLine" id="cb4-30" title="30">        base2 += step;</a>
<a class="sourceLine" id="cb4-31" title="31">        size  -= step;</a>
<a class="sourceLine" id="cb4-32" title="32">        <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb4-33" title="33">    }</a>
<a class="sourceLine" id="cb4-34" title="34"></a>
<a class="sourceLine" id="cb4-35" title="35">    <span class="kw">class</span> it_sentinel {};</a>
<a class="sourceLine" id="cb4-36" title="36"></a>
<a class="sourceLine" id="cb4-37" title="37">    <span class="dt">bool</span> <span class="kw">operator</span>!=(it_sentinel) <span class="at">const</span> { <span class="cf">return</span> size; }</a>
<a class="sourceLine" id="cb4-38" title="38"></a>
<a class="sourceLine" id="cb4-39" title="39">    <span class="co">// begin/end functions fulfill the iterable range interface</span></a>
<a class="sourceLine" id="cb4-40" title="40">    order_range begin() <span class="at">const</span> { <span class="cf">return</span> *<span class="kw">this</span>; }</a>
<a class="sourceLine" id="cb4-41" title="41">    it_sentinel end()   <span class="at">const</span> { <span class="cf">return</span> {}; }</a>
<a class="sourceLine" id="cb4-42" title="42">};</a></code></pre></div>
<p>This looks a bit bloaty at first, but this is a one-time implementation after all. When we compare it with the initial <code>for</code>-loop version, we realize that all the calculations are in the function <code>current_order</code> and <code>operator++</code>. All the other code is just data storage and retrieval, as well as iterator interface compliance.</p>
<p>It might also at first look strange that the <code>begin()</code> function returns a copy of the <code>order_range</code> instance. The trick is that this class is at the same time a range and an iterator.</p>
<p>One nice perk of C++17 is, that the <em>end</em> iterator does not need to be of the same type as normal iterators any longer. This allows for a simpler abort condition (which is: <code>size == 0</code>).</p>
<p>With this tiny order 2 range iterator <em>“library”</em>, we can now do the following. (Let’s move away from the memory mapping examples to simple <code>printf</code> examples because we will compare them in <a href="https://gcc.godbolt.org">Godbolt</a> later)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> print_range(<span class="dt">word_t</span> base1, <span class="dt">word_t</span> base2, <span class="dt">word_t</span> size)</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span> &amp;[b1, b2, order] : order_range{base1, base2, size}) {</a>
<a class="sourceLine" id="cb5-4" title="4">        printf(<span class="st">&quot;%4zx -&gt; %4zx, order %2zu</span><span class="sc">\n</span><span class="st">&quot;</span>, b1, b2, order);</a>
<a class="sourceLine" id="cb5-5" title="5">    }</a>
<a class="sourceLine" id="cb5-6" title="6">}</a></code></pre></div>
<p>This code just contains <em>pure payload</em>. There is no trace of the mathematical obfuscation left.</p>
<p>Another differentiating feature from the callback function variant is that we can combine this iterator with STL data structures and algorithms!</p>
<h2 id="comparing-the-resulting-assembly">Comparing the resulting assembly</h2>
<p>What is the price of this abstraction? Let us see how the non-iterator-version of the same code would look like, and then compare it in the Godbolt assembly output view.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">void</span> print_range(<span class="dt">word_t</span> base1, <span class="dt">word_t</span> base2, <span class="dt">word_t</span> size)</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">constexpr</span> <span class="dt">word_t</span> max_bit {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; (<span class="dv">8</span> * <span class="kw">sizeof</span>(max_bit) - <span class="dv">1</span>)};</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="cf">while</span> (size) {</a>
<a class="sourceLine" id="cb6-6" title="6">        <span class="at">const</span> <span class="dt">word_t</span> min_order {order_min(base1 | base2 | max_bit)};</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="at">const</span> <span class="dt">word_t</span> max_order {order_max(size)};</a>
<a class="sourceLine" id="cb6-8" title="8">        <span class="at">const</span> <span class="dt">word_t</span> order     {<span class="bu">std::</span>min(min_order, max_order)};</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10">        printf(<span class="st">&quot;%4zx -&gt; %4zx, order %2zu</span><span class="sc">\n</span><span class="st">&quot;</span>, base1, base2, order);</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12">        <span class="at">const</span> <span class="dt">word_t</span> step {<span class="dv">1</span><span class="bu">ull</span> &lt;&lt; order};</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14">        base1 += step;</a>
<a class="sourceLine" id="cb6-15" title="15">        base2 += step;</a>
<a class="sourceLine" id="cb6-16" title="16">        size  -= step;</a>
<a class="sourceLine" id="cb6-17" title="17">    }</a>
<a class="sourceLine" id="cb6-18" title="18">}</a></code></pre></div>
<p>Interestingly, <code>clang++</code> sees exactly what we did there and emits exactly <strong>the same assembly</strong> in <strong>both</strong> cases. That means that this iterator is a real <strong>zero cost</strong> abstraction!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb7-1" title="1">print_range(unsigned long, unsigned long, unsigned long): </a>
<a class="sourceLine" id="cb7-2" title="2">        <span class="bu">push</span>    <span class="kw">r15</span></a>
<a class="sourceLine" id="cb7-3" title="3">        <span class="bu">push</span>    <span class="kw">r14</span></a>
<a class="sourceLine" id="cb7-4" title="4">        <span class="bu">push</span>    <span class="kw">r13</span></a>
<a class="sourceLine" id="cb7-5" title="5">        <span class="bu">push</span>    <span class="kw">r12</span></a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="bu">push</span>    <span class="kw">rbx</span></a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="bu">mov</span>     <span class="kw">r14</span>, <span class="kw">rdx</span></a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="bu">mov</span>     <span class="kw">r15</span>, <span class="kw">rsi</span></a>
<a class="sourceLine" id="cb7-9" title="9">        <span class="bu">mov</span>     <span class="kw">r12</span>, <span class="kw">rdi</span></a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="bu">test</span>    <span class="kw">r14</span>, <span class="kw">r14</span></a>
<a class="sourceLine" id="cb7-11" title="11">        <span class="bu">je</span>      .LBB0_<span class="dv">3</span></a>
<a class="sourceLine" id="cb7-12" title="12">        movabs  <span class="kw">r13</span>, <span class="dv">-9223372036854775808</span></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="fu">.LBB0_2:</span> # =&gt;This Inner <span class="bu">Loop</span> Header: Depth=<span class="dv">1</span></a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="bu">mov</span>     <span class="kw">rax</span>, <span class="kw">r12</span></a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="bu">or</span>      <span class="kw">rax</span>, <span class="kw">r15</span></a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="bu">or</span>      <span class="kw">rax</span>, <span class="kw">r13</span></a>
<a class="sourceLine" id="cb7-17" title="17">        <span class="bu">bsf</span>     <span class="kw">rbx</span>, <span class="kw">rax</span></a>
<a class="sourceLine" id="cb7-18" title="18">        <span class="bu">bsr</span>     <span class="kw">rax</span>, <span class="kw">r14</span></a>
<a class="sourceLine" id="cb7-19" title="19">        <span class="bu">cmp</span>     <span class="kw">rax</span>, <span class="kw">rbx</span></a>
<a class="sourceLine" id="cb7-20" title="20">        <span class="bu">cmovb</span>   <span class="kw">rbx</span>, <span class="kw">rax</span></a>
<a class="sourceLine" id="cb7-21" title="21">        <span class="bu">mov</span>     <span class="kw">edi</span>, .L.<span class="bu">str</span></a>
<a class="sourceLine" id="cb7-22" title="22">        <span class="bu">xor</span>     <span class="kw">eax</span>, <span class="kw">eax</span></a>
<a class="sourceLine" id="cb7-23" title="23">        <span class="bu">mov</span>     <span class="kw">rsi</span>, <span class="kw">r12</span></a>
<a class="sourceLine" id="cb7-24" title="24">        <span class="bu">mov</span>     <span class="kw">rdx</span>, <span class="kw">r15</span></a>
<a class="sourceLine" id="cb7-25" title="25">        <span class="bu">mov</span>     <span class="kw">rcx</span>, <span class="kw">rbx</span></a>
<a class="sourceLine" id="cb7-26" title="26">        <span class="bu">call</span>    printf</a>
<a class="sourceLine" id="cb7-27" title="27">        <span class="bu">mov</span>     <span class="kw">eax</span>, <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-28" title="28">        <span class="bu">mov</span>     <span class="kw">ecx</span>, <span class="kw">ebx</span></a>
<a class="sourceLine" id="cb7-29" title="29">        <span class="bu">shl</span>     <span class="kw">rax</span>, <span class="kw">cl</span></a>
<a class="sourceLine" id="cb7-30" title="30">        <span class="bu">add</span>     <span class="kw">r12</span>, <span class="kw">rax</span></a>
<a class="sourceLine" id="cb7-31" title="31">        <span class="bu">add</span>     <span class="kw">r15</span>, <span class="kw">rax</span></a>
<a class="sourceLine" id="cb7-32" title="32">        <span class="bu">sub</span>     <span class="kw">r14</span>, <span class="kw">rax</span></a>
<a class="sourceLine" id="cb7-33" title="33">        <span class="bu">jne</span>     .LBB0_<span class="dv">2</span></a>
<a class="sourceLine" id="cb7-34" title="34"><span class="fu">.LBB0_3:</span></a>
<a class="sourceLine" id="cb7-35" title="35">        <span class="bu">pop</span>     <span class="kw">rbx</span></a>
<a class="sourceLine" id="cb7-36" title="36">        <span class="bu">pop</span>     <span class="kw">r12</span></a>
<a class="sourceLine" id="cb7-37" title="37">        <span class="bu">pop</span>     <span class="kw">r13</span></a>
<a class="sourceLine" id="cb7-38" title="38">        <span class="bu">pop</span>     <span class="kw">r14</span></a>
<a class="sourceLine" id="cb7-39" title="39">        <span class="bu">pop</span>     <span class="kw">r15</span></a>
<a class="sourceLine" id="cb7-40" title="40">        <span class="bu">ret</span></a>
<a class="sourceLine" id="cb7-41" title="41"><span class="fu">.L.str:</span></a>
<a class="sourceLine" id="cb7-42" title="42">        .asciz  <span class="st">&quot;%4zx -&gt; %4zx, order %2zu\n&quot;</span></a></code></pre></div>
<p><a href="https://godbolt.org/g/hn3yix">See the whole example in gcc.godbolt.org.</a></p>
<p>When comparing the assembly of both variants with GCC, the result is a little bit disappointing at first: The <code>for</code>-loop version is 62 lines of assembly vs. 48 lines of assembly for the iterator version. When looking at how many lines of assembly are the actual loop part, it is still 25 lines for <strong>both</strong> implementations!</p>
<h2 id="summary">Summary</h2>
<p>Hardcore low-level/kernel hackers often claim that it’s disadvantageous to use abstractions like iterators and generic algorithms. Their code needs to be very small and fast because especially on hot paths, interrupt service routines, and other occasions, the kernel surely must not be bloaty and slow.</p>
<p>Unfortunately, one extreme kind of low-level hackers that keep their code tight and short just out of plain responsibility, are the ones that use the same reasons as an excuse for writing code that contains a lot of duplicates, is complex, hard to read (but surely makes you feel smart while being written), and difficult to test.</p>
<p>Code should be separated into composable libraric parts that serve isolated concerns. C++ allows combining the goals of reusable software, testable libraries, and logical decoupling with high performance and low binary size.</p>
<p>It is usually worth a try to implement a nice abstraction that turns out to be free with regard to assembly size and performance.</p>
<h2 id="related">Related</h2>
<p>I really enjoyed reading <a href="https://kristerw.blogspot.de/2017/06/a-look-at-range-v3-code-generation.html">Krister Waldfridsson’s article</a> where he primarily analyzes runtime performance of a piece of range-v3 code. What’s interesting about that article is that he also shows an innocently looking code snippet with a raw <code>for</code>-loop that is slower than equivalent code that uses an STL algorithm, because the STL algorithm helps the compiler optimizing the code.</p>
<p>Another thing that is worth a look and which fits the same topic: Jason Turner gave a <a href="https://www.youtube.com/watch?v=zBkNBP00wJE">great talk about using C++17 on tiny computers</a>. He demonstrates how modern C++ programming patterns that help writing better code do <strong>not</strong> lead to bloaty or slow code by compiling and showing the assembly in a Godbolt view. It actually runs on a real Commodore in the end.</p>]]></description>
    <pubDate>Sun, 02 Jul 2017 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2017/07/02/order2_iterator</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>C++17 STL Cookbook</title>
    <link>https://blog.galowicz.de/2017/06/30/cpp17_stl_cookbook</link>
    <description><![CDATA[<p>This article is about the <a href="https://www.packtpub.com/application-development/c17-stl-cookbook"><strong>C++17 STL Cookbook</strong></a>, which got published this week. After about 6 months of writing, I am happy that it is out the door and hope it helps and inspires its readers to write modern C++ code.</p>
<!--more-->
<p><img align="left" style="margin: 0px 30px 10px 0px;" src="/images/cpp17_stl_cookbook_cover.png"></p>
<h2 id="why-did-i-write-this-book">Why did I write this book?</h2>
<p>Some day in October 2016, I was messaged by an acquisition editor of the British publishing company <em>PACKT Publishing</em> via LinkedIn. He asked me if I was interested in writing a book with the title <em>“C++17 STL Cookbook”</em>.</p>
<p>Two months earlier, my former employer shut down the whole office site together with the project and team I have been working on/with. Having been still unemployed and on the search for a new nice job, I had plenty of time thinking about the possible content of the book.</p>
<p>The <em>frame/format</em> of the book was fixed already because it should be part of the <em>PACKT “Cookbook”</em> franchise. Such cookbooks contain a lot of short <em>recipes</em> that explain how to solve very practical problems. This makes a lot of sense, because many other books first teach all the important aspects of their topic, and then let the user puzzle together themselves how to combine these in real life.</p>
<h2 id="what-is-the-general-idea-behind-the-book">What is the general idea behind the book?</h2>
<p>I made the general observation, that most C++ programmers write code that could rather be called <em>C with classes</em> than C++. Such programmers are happy to use data structures like <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, and so on, but when it comes to implementing standard tasks like for example <em>filtering</em>, <em>accumulating</em>, and so on, they fall back to handcrafted <code>for</code> loops.</p>
<p>So in real life, people rather write code like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">int</span> sum = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; my_vector.length(); ++i) {</a>
<a class="sourceLine" id="cb1-3" title="3">    sum += my_vector[i];</a>
<a class="sourceLine" id="cb1-4" title="4">}</a></code></pre></div>
<p>… instead of this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> sum = accumulate(begin(my_vector), end(my_vector), <span class="dv">0</span>);</a></code></pre></div>
<p>The <code>for</code> loop variant is <em>not faster</em> and <em>not shorter</em>, but it comes with the disadvantage that it is hardwired to arrays and vectors. If one wanted to do the same with lists, it would be necessary to <em>rewrite</em> this piece of code. The <code>accumulate</code> function has a data structure agnostic interface and just <em>“does the right thing”</em>. (Since C++17, there is also <code>reduce(begin(my_vector), end(my_vector))</code>, which does the same thing.) In contrast to the <code>for</code> loop, one does not have to “mentally execute it” in order to understand it.</p>
<p>A very interesting perk of C++17 is that it adds <a href="http://en.cppreference.com/w/cpp/experimental/parallelism"><strong>execution policies</strong></a> to a lot of STL algorithms. That means that it is now possible to trivially parallelize code that already uses STL algorithms just with one extra parameter. It would, therefore, make sense if C++ programmers would finally get used to all the carefully crafted and already tested helpers the STL has already been providing for decades now.</p>
<p>I regret that many C++ programmers ignore the vast possibilities that the STL provides. Especially in the embedded C++ area, people regularly fall back to “C with classes”.</p>
<p>A very old, but ironically still very applicable quote that I read in <a href="http://wwwusers.di.uniroma1.it/~lpara/LETTURE/backus.pdf">John Backus’ publication “Can Programming Be Liberated from the von Neumann Style?”</a>:</p>
<blockquote>
<p>[…] programming […] must always start again at square one, writing “for i := …” and “for j := …” followed by assignment statements sprinkled with i’s and j’s.</p>
</blockquote>
<p>In 1977, he was talking about FORTRAN code, but his observation still applies to a lot of C++ code from today. Another very inspiring talk about the “C with classes” vs. “Modern C++” topic is <a href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">Sean Parent’s talk where he presents his <code>gather</code> algorithm which is only an STL two-liner</a>.</p>
<p>The <strong>C++17 STL Cookbook</strong> is obviously about <strong>C++17</strong> and the <strong>STL</strong>. While the first chapter concentrates solely on the most interesting new language features and syntax sugar that were introduced with the new C++17 standard, I aimed to spread a lot of <em>modern C++ philosophy</em> with the rest of the book:</p>
<p>All recipes try to solve problems <em>the STL way</em>.</p>
<h2 id="the-content">The content</h2>
<p>In roughly 500 pages, the book covers the following topics:</p>
<ol type="1">
<li><p><strong>The new C++17 features</strong></p>
<p>An overview of the most interesting new C++17 <em>language</em> features: <code>constexpr if</code>, structured bindings, initializers in <code>if</code> statements, fold expressions, etc.</p></li>
<li><p><strong>STL Containers</strong></p>
<p>A quick overview what kind of data structures we already have in the C++ STL, and what their characteristics are. The recipes show how to use them in C++17.</p></li>
<li><p><strong>Iterators</strong></p>
<p>This chapter explains the important concept of iterators in C++ and how to implement them. This includes the new perks introduced by C++17.</p></li>
<li><p><strong>Lambda expressions</strong></p>
<p>Lambda expressions were added in C++11 but evolved in every following standard. This chapter shows their current state and demonstrates what we can do with them. There is some functional programming style involved here.</p></li>
<li><p><strong>STL algorithm basics</strong></p>
<p>This chapter is a quick reintroduction to STL algorithms.</p></li>
<li><p><strong>Advanced use of STL algorithms</strong></p>
<p>After having reintroduced how standard algorithms work, this chapter demonstrates how to combine them in order to solve more complex tasks without reinventing the wheel (or <code>for</code> loop) all the time.</p></li>
<li><p><strong>Strings, stream classes, and regular expressions</strong></p></li>
</ol>
<ul>
<li>The streaming library is an ancient and large, but very important part of the STL. This chapter shows how to solve the typical I/O tasks.</li>
</ul>
<ol start="8" type="1">
<li><p><strong>Utility classes</strong></p>
<p>Time conversion, <code>std::optional</code>, <code>std::any</code>, <code>std::variant</code>, automatic memory management with smart pointers, and random number generation.</p></li>
<li><p><strong>Parallelism and concurrency</strong></p>
<p>It was always possible to write multicore programs with C++, but that was a rather operating system dependent task until C++11 introduced <code>std::task</code>, <code>std::future</code>, and a lot of synchronization classes. This chapter gives a lot of examples how to write portable multicore programs.</p></li>
<li><p><strong>Filesystem</strong></p>
<p>C++17 also introduced another sub-library that is solely about accessing and iterating file system structures in an operating system independent way. This chapter concentrates on example apps that can be implemented with this new addition to the C++ standard.</p></li>
</ol>
<h2 id="book-formatsordering">Book formats/Ordering</h2>
<p>The book will soon be available in <strong>printed form</strong>, but the <strong>ebook</strong> can be ordered already.</p>
<p>If you want a <strong>DRM-free</strong> version of it, you should order it <a href="https://www.packtpub.com/application-development/c17-stl-cookbook">directly from PACKT</a>. Of course, <a href="http://amzn.to/2hqAyFX">Amazon has the book</a>, too.</p>
<h2 id="thank-you">Thank you</h2>
<p>The best thing that can happen to you while writing a book is having <a href="https://arne-mertz.de/">Arne Mertz</a> as the reviewer! No book comes without mistakes, but he did a <strong>great job</strong> finding even the most subtle, but critical ones.</p>
<p>Not to forget the <a href="https://www.meetup.com/de-DE/C-User-Group-Hannover/">C++ user group Hannover</a>, where I got a lot of valuable feedback and inspiration.</p>]]></description>
    <pubDate>Fri, 30 Jun 2017 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2017/06/30/cpp17_stl_cookbook</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>A reinterpret_cast Trap</title>
    <link>https://blog.galowicz.de/2017/01/22/reinterpret_cast_trap</link>
    <description><![CDATA[<p>Sometimes, casting is just inevitable. And then there’s even not much science behind it, at least it seems so. Once some address is provided in a variable of the right size, a typed pointer can be casted out of it, and then the object can be accessed via its members and methods as usual. In some situations it is really easy to get the casting wrong, leading to interesting bugs. This article describes an example situation and a proper fix.</p>
<!--more-->
<p>Imagine we have a base class <code>C</code>, which inherits from <code>B</code>, which inherits from <code>A</code>. They all have one <code>int</code> member (4 Bytes each):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">struct</span> A     { <span class="dt">int</span> a; };</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">struct</span> B : A { <span class="dt">int</span> b; };</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">struct</span> C : B { <span class="dt">int</span> c; };</a></code></pre></div>
<p>Assuming that we have an instance of class <code>C</code> somewhere in memory at address <code>X</code>, we know that its member <code>a</code> which it inherited from struct <code>A</code> lies at exactly the same offset. Member <code>b</code> is located at <code>X + 4</code>, and <code>c</code> is located at <code>X + 8</code>.</p>
<p>If we are just interested in one of those specific members, we could simply calculate the offset, and then <code>reinterpret_cast</code>, just like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// Print c, assuming x is the address of an instance of struct C:</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="bu">std::</span>cout &lt;&lt; *<span class="kw">reinterpret_cast</span>&lt;<span class="dt">int</span>*&gt;(x + <span class="dv">8</span>) &lt;&lt; <span class="bu">std::</span>endl; </a></code></pre></div>
<p>Let’s assume we have some code, which <em>relies</em> on getting addresses of <code>struct A</code> typed addresses in integral form:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">struct</span> A {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="dt">int</span> a {<span class="bn">0xa</span>};</a>
<a class="sourceLine" id="cb3-3" title="3">};</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">struct</span> B : A {</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="dt">int</span> b {<span class="bn">0xb</span>};</a>
<a class="sourceLine" id="cb3-7" title="7">};</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">// Simple inheritance: A -&gt; B1 -&gt; C</span></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="kw">struct</span> C : B {</a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="dt">int</span> c {<span class="bn">0xc</span>};</a>
<a class="sourceLine" id="cb3-12" title="12">};</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="dt">void</span> print_a_from_address(<span class="bu">std::</span>uintptr_t addr)</a>
<a class="sourceLine" id="cb3-15" title="15">{</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="at">const</span> A *a {<span class="kw">reinterpret_cast</span>&lt;<span class="at">const</span> A*&gt;(addr)};</a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>hex &lt;&lt; a-&gt;a &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb3-18" title="18">}</a>
<a class="sourceLine" id="cb3-19" title="19"></a>
<a class="sourceLine" id="cb3-20" title="20"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb3-21" title="21">{</a>
<a class="sourceLine" id="cb3-22" title="22">    C c;</a>
<a class="sourceLine" id="cb3-23" title="23"> </a>
<a class="sourceLine" id="cb3-24" title="24">    print_a_from_address(<span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>uintptr_t&gt;(&amp;c));</a>
<a class="sourceLine" id="cb3-25" title="25"></a>
<a class="sourceLine" id="cb3-26" title="26">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-27" title="27">}</a></code></pre></div>
<p>That’s no good style, but this program works. The structures have standard definitions which initialize members <code>a</code>, <code>b</code>, and <code>c</code> to values <code>0xa</code>, <code>0xb</code>, and <code>0xc</code>.</p>
<p>The program will print <code>a</code> at run time, which is what we expect.</p>
<p>The inheritance chain wraps every inheriting member’s variables past the structure members in memory from which it is inheriting. So the memory layout of <code>c</code> looks like:</p>
<p>|Relative offset|Value|Structure Type Origin| |0x0|0xa|A| |0x4|0xb|B| |0x8|0xc|C|</p>
<p>(Every table row represents an integer in memory)</p>
<p>This program stops to work so nicely when changing the inheritance chain a bit:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">struct</span> A     { <span class="dt">int</span> a {<span class="bn">0xa</span>}; };</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">struct</span> B : A { <span class="dt">int</span> b {<span class="bn">0xb</span>}; };</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">struct</span> Foo {</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">int</span> f {<span class="bn">0xf</span>};</a>
<a class="sourceLine" id="cb4-6" title="6">};</a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">// Multiple inheritance: (Foo), (A, B) -&gt; C</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">struct</span> C : Foo, B {</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="dt">int</span> c {<span class="bn">0xc</span>};</a>
<a class="sourceLine" id="cb4-11" title="11">};</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="dt">void</span> print_a_from_address(<span class="bu">std::</span>uintptr_t addr)</a>
<a class="sourceLine" id="cb4-14" title="14">{</a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="at">const</span> A *a {<span class="kw">reinterpret_cast</span>&lt;<span class="at">const</span> A*&gt;(addr)};</a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>hex &lt;&lt; a-&gt;a &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb4-17" title="17">}</a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb4-20" title="20">{</a>
<a class="sourceLine" id="cb4-21" title="21">    C c;</a>
<a class="sourceLine" id="cb4-22" title="22"> </a>
<a class="sourceLine" id="cb4-23" title="23">    print_a_from_address(<span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>uintptr_t&gt;(&amp;c));</a>
<a class="sourceLine" id="cb4-24" title="24"></a>
<a class="sourceLine" id="cb4-25" title="25">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-26" title="26">}</a></code></pre></div>
<p>This program version will print <code>f</code>, and not <code>a</code>. This is, because we disturbed the memory layout by letting <code>C</code> first inherit from <code>Foo</code>, then from <code>B</code> (which still inherits from <code>A</code>).</p>
<p>|Relative offset|Value|Structure Type Origin| |0x0|0xf|Foo| |0x4|0xa|A| |0x8|0xb|B| |0xc|0xc|C|</p>
<p><code>reinterpret_cast</code> is just not the right tool for this, if we just assume that inheriting from <code>A</code> somehow shall do the magic. Before showing how to do it right, i first present another failing example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="co">/* Unchanged definition of struct A and B... */</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">struct</span> C : B {</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="dt">int</span> c {<span class="bn">0xd</span>};</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="kw">virtual</span> <span class="dt">void</span> f() {};</a>
<a class="sourceLine" id="cb5-7" title="7">};</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb5-10" title="10">{</a>
<a class="sourceLine" id="cb5-11" title="11">    C c;</a>
<a class="sourceLine" id="cb5-12" title="12"> </a>
<a class="sourceLine" id="cb5-13" title="13">    print_a_from_address(<span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>uintptr_t&gt;(&amp;c));</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-16" title="16">}</a></code></pre></div>
<p>In this case, the program <em>might</em> print <code>a</code>, but in many cases it will print <em>something</em>.</p>
<p>The only difference is, that we added a virtual function in struct <code>C</code>. This leads to this object containing another <em>pointer</em>. It points to a <strong>vtable</strong>. (That vtable itself is globally accessible at runtime and contains pointers to all virtual functions which that class contains. This is roughly how C++ implements polymorphy.) The vtable pointer can be located <em>somewhere</em> in the object. In the clang and GCC case, it is located at the beginning of the object, where we assumed the <code>a</code> member. And that is why it does not work.</p>
<h2 id="casting-done-right">Casting done right</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3">    C1 c1; <span class="co">// normal C B A inheritance</span></a>
<a class="sourceLine" id="cb6-4" title="4">    C2 c2; <span class="co">// Foo C B A inheritance</span></a>
<a class="sourceLine" id="cb6-5" title="5">    C3 c3; <span class="co">// virtual function added in class C</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7">    print_a_from_address(<span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>uintptr_t&gt;(<span class="kw">static_cast</span>&lt;<span class="at">const</span> A*&gt;(&amp;c1)));</a>
<a class="sourceLine" id="cb6-8" title="8">    print_a_from_address(<span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>uintptr_t&gt;(<span class="kw">static_cast</span>&lt;<span class="at">const</span> A*&gt;(&amp;c2)));</a>
<a class="sourceLine" id="cb6-9" title="9">    print_a_from_address(<span class="kw">reinterpret_cast</span>&lt;<span class="bu">std::</span>uintptr_t&gt;(<span class="kw">static_cast</span>&lt;<span class="at">const</span> A*&gt;(&amp;c3)));</a>
<a class="sourceLine" id="cb6-10" title="10">}</a></code></pre></div>
<p>I renamed the 3 variants of struct <code>C</code> to <code>C1</code>, <code>C2</code>, and <code>C3</code>. This program will now correctly print <code>a</code> in all these cases.</p>
<p>What is different here (But same in all cases!), is that the address of the objects are first <code>static_cast</code>ed to <code>const A*</code>, and <strong>then</strong> <code>reinterpret_cast</code>ed to <code>std::uintptr_t</code>.</p>
<p><code>static_cast</code> applies some magic to the pointer: As it knows from what to what we are casting (from type <code>C</code> to <code>A</code>), it can <em>modify</em> the actual pointer address. And it must do that, because if we want an <code>A</code>-typed pointer from the <code>C2</code> object (which first inherits from <code>Foo</code>, and then from <code>B</code>), then we must add 4 bytes to the address, in order to have an actual <code>A</code> pointer. (Because the <code>A</code> part lies 4 bytes behind the <code>Foo</code> part)</p>
<p>In the <code>C3</code> case (which adds a virtual function), the pointer must be fixed in the sense that the <code>A</code> part of the object lies behind (or in front of? That is compiler dependend, but <code>static_cast</code> will always get it right!) the vtable. So in this case, clang’s <code>static_cast</code> will add 8 bytes offset to the pointer, to make it an actual <code>A</code> typed pointer. (It’s 8 bytes, because a pointer is 8 bytes large on 64bit systems which we assume here)</p>
<p>Another nice feature is, that <code>static_cast</code> will refuse to compile, if the object is by no means related to type <code>A</code>. <code>reinterpret_cast</code> just ignores this and gives us no safety.</p>
<p>However, it was not possible to completely avoid <code>reinterpret_cast</code>, because of the <em>type erasing</em> cast from <code>A*</code> to <code>std::uintptr_t</code>, which <code>static_cast</code> would refuse to do. Although we could have used a union which overlays an <code>A</code> pointer with a <code>std::uintptr_t</code>.</p>
<h2 id="summary">Summary</h2>
<p>Only use <code>reinterpret_cast</code> when you are <em>1000000%</em> sure what type you have in front of you. And even if you could do the math of pointer offset correction yourself - don’t.</p>
<p>When casting, you should always first consider to <code>static_cast</code> to the type you need first. This will <em>fail</em> if you got the types wrong - this is useful in situations where you deal with templates or <code>auto</code> types) Do the <code>reinterpret_cast</code> only if it is really inevitable, and even then double check its correctness.</p>
<p><code>reinterpret_cast</code>-<code>static_cast</code> <em>chains</em> will not make your code prettier. As Stroustrup states in his original C++ books, the C++ style casts are <em>intentionally ugly</em>, because they are also potentionally <strong>dangerous</strong>.</p>
<p><em>EDIT on 2017-01-27: Changed the type from <code>uint64_t</code> to <code>std::uintptr_t</code>, as a comment on <a href="https://www.reddit.com/r/cpp/comments/5pju7q/a_reinterpret_cast_trap/">reddit.com/r/cpp</a> suggested. Thanks for the input!</em></p>]]></description>
    <pubDate>Sun, 22 Jan 2017 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2017/01/22/reinterpret_cast_trap</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Python Style printf for C++ with pprintpp</title>
    <link>https://blog.galowicz.de/2016/11/05/python_style_printf_for_cpp</link>
    <description><![CDATA[<p>The C++ STL comes with <em>stream</em> style character output, which is an alternative to the classic <code>printf</code> like format function collection of the C library. For different reasons, some C++ programmers still stick to <code>printf</code> like formatting. This article demonstrates the <code>pprintpp</code> <a href="https://github.com/tfc/pprintpp">(open source, and available on Github)</a> library, which tries to make <code>printf</code> use comfortable and safe while avoiding any runtime overhead.</p>
<!--more-->
<h2 id="c-streams-vs.-printf">C++ Streams vs. <code>printf</code></h2>
<p>So, I am presenting a <code>printf</code> frontend library which tries to enhance it. But what is wrong with <code>printf</code>? Let’s compare it with C++ stream style printing in different situations:</p>
<h3 id="round-1-inconvenience">Round 1: Inconvenience</h3>
<p>Consider the following simple program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb1-4" title="4">{</a>
<a class="sourceLine" id="cb1-5" title="5">    printf(<span class="st">&quot;</span><span class="sc">%u</span><span class="st">, </span><span class="sc">%x</span><span class="st">, %0.8f, %0.8lf, </span><span class="sc">%s\n</span><span class="st">&quot;</span>, <span class="dv">123</span><span class="bu">u</span>, <span class="bn">0x123</span><span class="bu">u</span>, <span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">2.0</span>, <span class="st">&quot;Hello World&quot;</span>); </a>
<a class="sourceLine" id="cb1-6" title="6">}</a></code></pre></div>
<p>It’s simply no fun to tell <code>printf</code> of which type all variables are. The compiler <em>knows</em> the types already, so why must the programmer type the type names <em>again</em>?</p>
<p>C++ streams fix this, as the <code>operator&lt;&lt;</code> is properly overloaded for any type, which selects the right formatting method automatically. Let’s have a look how to get exactly the same output with C++ streams:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb2-5" title="5">{</a>
<a class="sourceLine" id="cb2-6" title="6">    printf(<span class="st">&quot;</span><span class="sc">%u</span><span class="st">, </span><span class="sc">%x</span><span class="st">, %0.8f, %0.8lf, </span><span class="sc">%s\n</span><span class="st">&quot;</span>, <span class="dv">123</span><span class="bu">u</span>, <span class="bn">0x123</span><span class="bu">u</span>, <span class="fl">1.0</span><span class="bu">f</span>, <span class="fl">2.0</span>, <span class="st">&quot;Hello World&quot;</span>); </a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="bu">std::</span>cout &lt;&lt; <span class="dv">123</span><span class="bu">u</span> &lt;&lt; <span class="st">&quot;, &quot;</span></a>
<a class="sourceLine" id="cb2-9" title="9">              &lt;&lt; <span class="bu">std::</span>hex &lt;&lt; <span class="bn">0x123</span><span class="bu">u</span> &lt;&lt; <span class="st">&quot;, &quot;</span></a>
<a class="sourceLine" id="cb2-10" title="10">              &lt;&lt; <span class="bu">std::</span>fixed &lt;&lt; <span class="bu">std::</span>setprecision(<span class="dv">6</span>) &lt;&lt; <span class="fl">1.0</span><span class="bu">f</span> &lt;&lt; <span class="st">&quot;, &quot;</span></a>
<a class="sourceLine" id="cb2-11" title="11">              &lt;&lt; <span class="fl">2.0</span> &lt;&lt; <span class="st">&quot;, &quot;</span></a>
<a class="sourceLine" id="cb2-12" title="12">              &lt;&lt; <span class="st">&quot;Hello World&quot;</span> &lt;&lt; <span class="bu">std::</span>endl</a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14">}</a></code></pre></div>
<p>All type safety aside, at this point most likely everyone will agree that this is, from a readability and comfort perspective, <em>no</em> improvement over to <code>printf</code>.</p>
<blockquote>
<p>Although I must say that I do not format floating point numbers every day and had to guess here and there while being too lazy to look at the documentation. In order to see if the <code>printf</code> format works as I hoped, I had to run the program. At the same time, the C++ iostream format just did not compile when I did it wrong!</p>
</blockquote>
<h3 id="round-2-type-pitfalls">Round 2: Type Pitfalls</h3>
<p>When compiling the following program on a 64-bit machine, everything is fine:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">printf(<span class="st">&quot;</span><span class="sc">%ld\n</span><span class="st">&quot;</span>, <span class="kw">static_cast</span>&lt;<span class="dt">uint64_t</span>&gt;(<span class="dv">123</span>)); </a></code></pre></div>
<p>Compiling it on a 32-bit machine, the compiler quickly comes up with errors like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">error</span>: format <span class="st">&#39;%ld&#39;</span> expects argument of type <span class="st">&#39;long int&#39;</span>, but argument 2 has type <span class="st">&#39;uint64_t {aka long long unsigned int}&#39;</span> [-Werror=format=]</a></code></pre></div>
<p>So on 32bit systems, one should better have used <code>%lld</code>. This feels needlessly complicated because in both cases, the compiler knows the *@!#* type, but nevertheless the programmer has to deal with this now.</p>
<p>There is a portable solution: <code>PRIu64</code>. The header file <cinttypes> brings a lot of PRI macros. Using this here looks like the following:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1">printf(<span class="st">&quot;%&quot;</span> PRIu64 <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">static_cast</span>&lt;<span class="dt">uint64_t</span>&gt;(<span class="dv">123</span>)); </a></code></pre></div>
<p>All the <code>printf</code> fans who laughed at the ugliness of C++ streams, now again look a <em>little bit</em> like fools.</p>
<h3 id="round-3-repetition">Round 3: Repetition</h3>
<p>There are certain types which are a data composition of multiple values. A very typical example are <em>vectors</em> of data, e.g. geometric vectors:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">struct</span> vec3d {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="dt">double</span> x;</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="dt">double</span> y;</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="dt">double</span> z;</a>
<a class="sourceLine" id="cb6-5" title="5">};</a></code></pre></div>
<p>When printing some game state or similar, one usually wants to see vectors formatted like <code>(1.000, 2.000, 0.000)</code>.</p>
<p>Okay, easy:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1">printf(<span class="st">&quot;(%0.3lf, %0.3lf, %0.3lf)</span><span class="sc">\n</span><span class="st">&quot;</span>, v.x, v.y, v.z);</a></code></pre></div>
<p>What if there are a lot of vectors?</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1">printf(<span class="st">&quot;(%0.3lf, %0.3lf, %0.3lf), &quot;</span></a>
<a class="sourceLine" id="cb8-2" title="2">       <span class="st">&quot;(%0.3lf, %0.3lf, %0.3lf), &quot;</span></a>
<a class="sourceLine" id="cb8-3" title="3">       <span class="st">&quot;(%0.3lf, %0.3lf, %0.3lf)</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb8-4" title="4">       v1.x, v1.y, v1.z,</a>
<a class="sourceLine" id="cb8-5" title="5">       v2.x, v2.y, v2.z,</a>
<a class="sourceLine" id="cb8-6" title="6">       v2.x, v3.y, v3.z);</a></code></pre></div>
<p>Okay, it starts to get very repetitive.</p>
<blockquote>
<p>And we have a bug: I mistyped the <code>x</code> value of the third vector. Would you have seen it in a code review?</p>
</blockquote>
<p>C++ iostream users would just overload <code>operator&lt;&lt;</code> for <code>std::ostream</code> <strong>once</strong> and be done with this forever:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="bu">std::</span>ostream&amp; <span class="kw">operator</span>&lt;&lt;(<span class="bu">std::</span>ostream &amp;os, <span class="at">const</span> vec3d &amp;v) {</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="cf">return</span> os &lt;&lt; <span class="st">&quot;(&quot;</span> </a>
<a class="sourceLine" id="cb9-3" title="3">              &lt;&lt; <span class="bu">std::</span>setprecision(<span class="dv">4</span>) </a>
<a class="sourceLine" id="cb9-4" title="4">              &lt;&lt; v.x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v.z </a>
<a class="sourceLine" id="cb9-5" title="5">              &lt;&lt; <span class="st">&quot;)&quot;</span>;</a>
<a class="sourceLine" id="cb9-6" title="6">}</a></code></pre></div>
<p>Printing multiple vectors now looks like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="bu">std::</span>cout &lt;&lt; v1 &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v3 &lt;&lt; <span class="bu">std::</span>endl;</a></code></pre></div>
<p><code>printf</code> users may start defining helpful macros:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="pp">#define PRIvec3d       </span><span class="st">&quot;(%0.3lf, %0.3lf, %0.3lf)&quot;</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="pp">#define UNPACKvec3d</span>(v)<span class="pp"> </span>(v).x,<span class="pp"> </span>(v).y,<span class="pp"> </span>(v).z</a></code></pre></div>
<p>…and print their vectors like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1">printf(PRIvec3d <span class="st">&quot;, &quot;</span> PRIvec3d <span class="st">&quot;, &quot;</span> PRIvec3d <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>, </a>
<a class="sourceLine" id="cb12-2" title="2">       UNPACKvec3d(v1), UNPACKvec3d(v2), UNPACKvec3d(v3));</a></code></pre></div>
<p>In my opinion, C++ streams clearly win at this point.</p>
<h2 id="being-stuck-with-printf.-for-reasons.">Being Stuck with <code>printf</code>. For Reasons.</h2>
<p>Situations exist, where developers really can’t use stream printing. The reasons for those situations might be technical, but there are also social reasons: What are you going to do if you work in a team with <code>printf</code> dinosaurs, who <strong>just like it</strong>, and then it becomes a project convention to use <code>printf</code>? Right, nothing.</p>
<p>I found myself in such a situation. And I made format string mistakes all the time, which led me to think about how to <em>fix</em> <code>printf</code> by removing a whole class of bug sources. Bjarne Stroustrupi’s C++ book proposes a type safe <code>printf</code> (Section 28.6.1), which is implemented using variadic templates. My team did not find this solution acceptable because it generates <em>custom code</em> for every <code>printf</code> invocation.</p>
<h2 id="the-idea">The Idea</h2>
<p>When using <code>printf</code>, the programmer asks himself “What is the type of the variable I am going to print?”, and as soon as that question is answered, the next question is “What is the right <code>%</code> format string for this type?”. The compiler can easily answer these questions. The next thing is: How to make the compiler do that, without generating additional runtime code?</p>
<p>In the past, I wrote about <a href="/2016/05/08/compile_time_type_lists">type lists which can be used as compile-time data structures for metaprograms</a>. And building on top of that, I wrote about <a href="/2016/05/14/converting_between_c_strings_and_type_lists">transforming string literals to type lists, doing something with them and transforming back to string literals</a>. Understanding the ideas from those articles is crucial for understanding the code of this library.</p>
<p>After a lot of inspiring discussions with my colleagues, we iterated towards the idea of having a compile time function, which takes a simplified format string, and a list of the types of the parameters the user provided. The syntax of the simplified format string was inspired by Python style printing. In Python, you can do the following:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">python shell <span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;some </span><span class="sc">{}</span><span class="st"> with some var </span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="st">&quot;string&quot;</span>, <span class="dv">123</span>)</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">&#39;some string with some var 123&#39;</span></a></code></pre></div>
<p>Being inspired from that, I hoped to be able to come up with something like…</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1">printf(metaprog_result(<span class="st">&quot;some {} with some var {}&quot;</span>, </a>
<a class="sourceLine" id="cb14-2" title="2">                       typelist&lt;<span class="at">const</span> <span class="dt">char</span> *, <span class="dt">int</span>&gt;), </a>
<a class="sourceLine" id="cb14-3" title="3">       <span class="st">&quot;string&quot;</span>, <span class="dv">123</span>);</a></code></pre></div>
<p>…which collapses to the following during compile time:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1">printf(<span class="st">&quot;some </span><span class="sc">%s</span><span class="st"> with some var </span><span class="sc">%d</span><span class="st">&quot;</span>, <span class="st">&quot;string&quot;</span>, <span class="dv">123</span>);</a></code></pre></div>
<p>With this design, it is also possible to use the meta-program as a frontend for not only <code>printf</code>, but also <code>sprintf</code>, <code>fprintf</code>, etc.</p>
<h3 id="first-step-defining-an-autoformat-macro">First Step: Defining an <code>autoformat</code> Macro</h3>
<p>The first problem is, that the parameters <code>"string", 123</code> need to be both present in the <code>printf</code> function call as parameters, and at the same time, a type list <code>&lt;const char*, int&gt;</code> needs to be extracted out of them. The only way I was able to come up with was a preprocessor macro:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="pp">#define AUTOFORMAT</span>(fmtstr,<span class="pp"> </span>...)<span class="pp"> </span>\</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="pp">    </span>({<span class="pp"> </span>\</a>
<a class="sourceLine" id="cb16-3" title="3"><span class="pp">        </span><span class="kw">using</span><span class="pp"> </span>paramtypes<span class="pp"> </span>=<span class="pp"> </span>create_typelist_from_params(<span class="ot">__VA_ARGS__</span>));<span class="pp"> </span>\</a>
<a class="sourceLine" id="cb16-4" title="4"><span class="pp">        </span>return_preprocessed_format_str(fmtstr,<span class="pp"> </span>paramtypes);<span class="pp"> </span>\</a>
<a class="sourceLine" id="cb16-5" title="5"><span class="pp">    </span>})</a>
<a class="sourceLine" id="cb16-6" title="6"></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="pp">#define pprintf</span>(fmtstr,<span class="pp"> </span>...)<span class="pp"> </span>\</a>
<a class="sourceLine" id="cb16-8" title="8"><span class="pp">    </span>printf(AUTOFORMAT(fmtstr,<span class="pp"> </span><span class="ot">__VA_ARGS__</span>),<span class="pp"> </span>__VA_ARGS)</a></code></pre></div>
<p>This way it is possible to extract a type list with all the parameter types, feed it into a metaprogram which preprocesses and transforms the simplified format string, and then puts a <code>printf</code> compatible result into <code>printf</code>. And that would then happen without adding any portion of additional runtime code.</p>
<p>Unfortunately, in C++ (even including C++17) there is currently no other way to do this without C preprocessor macros.</p>
<h3 id="second-step-obtaining-the-type-list">Second Step: Obtaining the Type List</h3>
<p>What we have: <code>"some string", 123</code>. What we want: <code>const char*, int</code>.</p>
<p>In the <code>AUTOFORMAT</code> macro, the parameters, separated by commas, are available via <code>__VA_ARGS__</code>. These can be put into a template function call, which deduces the types:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> ... Ts&gt;</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="dt">make_t</span>&lt;Ts...&gt; tie_types(Ts...);</a></code></pre></div>
<p>This function does not even need to be defined because it is only used in a <code>decltype</code> environment. No runtime code will lever call it. Within the <code>pprintf</code> macro, it can now be used the following way:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">using</span> paramtypes = <span class="kw">decltype</span>(tie_types(__VA_ARGS__));</a></code></pre></div>
<p><code>paramtypes</code> is now a type list. <code>make_t&lt;const char*, int&gt;</code> evaluates to <code>tl&lt;const char*, tl&lt;int, null_t&gt;&gt;</code> (Read more about how this in particular works in the <a href="/2016/05/08/compile_time_type_lists">type list article</a>).</p>
<h3 id="third-step-transforming-the-simplified-format-string">Third Step: Transforming the Simplified Format String</h3>
<p>Having the simplified format string with <code>{}</code> braces, and the list of types the user provided as <code>printf</code> arguments, this can be fed to some algorithm which constructs a <code>printf</code> compatible format string.</p>
<p>The following statement will run the metaprogram function <code>autoformat_t</code>, which results in a struct with a static member function <code>str()</code>, which returns the <code>printf</code> compatible result string:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">autoformat_t</span>&lt;strprov, paramtypes&gt;::str();</a></code></pre></div>
<p>What <code>autoformat_t</code> does, is basically:</p>
<ol type="1">
<li>Iterate through the simplified format string.</li>
<li>For every opening <code>{</code> brace, find the closing <code>}</code> brace.</li>
<li>For every pair of braces, take the right argument type from the type list.</li>
<li>Map from <code>type</code> to <code>%foo</code> format string (There is a lookup table of those), and substitute the braces by the format string piece.</li>
</ol>
<p>The brace match search algorithm looks really similar to the <a href="/2016/06/16/cpp_template_compile_time_brainfuck_interpreter">function of the compile-time brainfuck interpreter, which searches for matching <code>[]</code> pairs</a>.</p>
<h3 id="detail-features">Detail Features</h3>
<p>Just looking for <code>{}</code> braces and substituting them by format string pieces is not enough. There are different cases and use cases which must be handled:</p>
<h4 id="printing-strings">Printing Strings</h4>
<p>When a programmer writes <code>pprintf("Buffer address: {}\n", some_char_buffer);</code>, it is <strong>not</strong> wise to substitute the <code>{}</code> with <code>%s</code>. As the example already suggests, the parameter is of type <code>char*</code>, but it is not a null terminated string.</p>
<p>Different implementation strategies can be applied:</p>
<ol type="1">
<li>Let the user cast the parameter to <code>void*</code>, then <code>autoformat_t</code> will substitute the braces with <code>%p</code> to print the address of the buffer.</li>
<li>Let the user additionally type <code>{s}</code> between the braces, so <code>autoformat_t</code> knows that the user <strong>really</strong> wants to print it as a string.</li>
</ol>
<p>I chose method <em>2</em>. Printing a string now looks like this:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1">pprintf(<span class="st">&quot;Some string: {s}&quot;</span>, <span class="st">&quot;Hello World&quot;</span>);</a></code></pre></div>
<h4 id="formatting-integers-as-hex-numbers">Formatting Integers as Hex Numbers</h4>
<p>When a programmer writes <code>pprintf("Some hex number: {}", 0x123);</code>, there must be some possibility to express “I want this integer printed as hex number instead of a decimal number”.</p>
<p>I chose to let the user provide this information between the braces by writing <code>{x}</code>. This way any integer of any size will be printed correctly as <code>%x</code>, or <code>%lx</code>, or <code>%llx</code>.</p>
<p><strong>Example</strong>: <code>pprintf("{x}", 0x123);</code> results in <code>printf("%x", 0x123);</code></p>
<h4 id="adding-additional-format-info">Adding Additional Format Info</h4>
<p>What if the user wants to print a <code>double</code> variable, but also needs to specify the precision?</p>
<p>In that case, <code>autoformat_t</code> will just take anything which is not an <code>x</code> or <code>s</code> (as used as a special specifier for string or hex number formatting) and put it between the <code>%</code> and the <code>f</code> or <code>lf</code> for doubles. This works for any type.</p>
<p>This strategy is applied to all types. This way it is possible to tamper with the indentation, precision, etc. whatever <code>printf</code> supports for which type.</p>
<p><strong>Example</strong>: <code>pprintf("{0.3}", 1.23);</code> results in <code>printf("%0.3lf", 1.23);</code></p>
<h4 id="printing-actual-braces">Printing Actual <code>{}</code> Braces</h4>
<p>If the user wants to print actual <code>{}</code> braces, it must be possible to mask them somehow.</p>
<p>If <code>autoformat_t</code> runs over an opening brace but finds it masked with <code>\</code>, it will ignore it. The closing brace is ignored already because the closing brace search function is not called.</p>
<p>However, there are actually 2 backslashes needed because <code>\</code> alone does not result in an actual "" string part. The backslash must be masked itself, so only <code>\\{</code> will result in the <code>autoformat_t</code> function seeing a <code>\{</code>.</p>
<p><strong>Example</strong>: <code>pprintf("var in braces: \\{ {} }", 123);</code> results in <code>printf("var in braces: { %d }", 123);</code> #### Catching Brace Mismatches</p>
<p>The meta-program refuses to compile if…</p>
<ul>
<li>it does not find a closing brace for an opening one.</li>
<li>it finds nested braces <code>{ {} }</code>, in which case it looks probable that the user wanted to mask the outer pair.</li>
<li>it finds more <code>{}</code> placeholders than parameters provided by the user.</li>
<li>it finds less <code>{}</code> placeholders than parameters provided by the user.</li>
</ul>
<h3 id="the-type-to-format-string-lookup-table">The Type-to-Format-String Lookup Table</h3>
<p>All types are cleaned from any <code>const</code> etc. noise, and then fed into the <code>type2fmt</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span> type2fmt;</a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co">// Integral types</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">char</span>&gt;                { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;c&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-5" title="5"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">short</span>&gt;               { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;d&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-6" title="6"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">int</span>&gt;                 { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;d&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-7" title="7"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">long</span> <span class="dt">int</span>&gt;            { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;d&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-8" title="8"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span>&gt;       { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;d&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-9" title="9"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">unsigned</span> <span class="dt">char</span>&gt;       { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;u&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-10" title="10"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">unsigned</span> <span class="dt">short</span>&gt;      { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;u&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-11" title="11"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">unsigned</span>&gt;            { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;u&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-12" title="12"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">unsigned</span> <span class="dt">long</span>&gt;       { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;u&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-13" title="13"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span>&gt;  { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;u&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15"><span class="co">// Floating point</span></a>
<a class="sourceLine" id="cb21-16" title="16"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">float</span>&gt;  { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;f&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-17" title="17"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="dt">double</span>&gt; { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;f&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-18" title="18"></a>
<a class="sourceLine" id="cb21-19" title="19"><span class="co">// Pointers</span></a>
<a class="sourceLine" id="cb21-20" title="20"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span> type2fmt&lt;<span class="bu">std::</span>nullptr_t&gt; { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;p&#39;</span>&gt;; };</a>
<a class="sourceLine" id="cb21-21" title="21"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span> type2fmt&lt;T*&gt;   { <span class="kw">using</span> type = <span class="dt">char_tl_t</span>&lt;<span class="ch">&#39;p&#39;</span>&gt;; };</a></code></pre></div>
<p><code>type2fmt</code> will then return a character type list, which can be used to compose the right format string for <code>printf</code>.</p>
<p>Note that the 32bit/64bit safety comes from here. For 64bit systems, <code>uint64_t</code> is an <code>unsigned long</code>, while it is an <code>unsigned long long</code> on 32bit systems. When the user writes <code>pprintf("Some 64bit unsigned: {}", uint64_t(123));</code>, the compiler will go through all the typedef aliases, and boil the type down to <code>unsigned long</code>, or <code>unsigned long long</code>, depending on what platform the code is compiled for. Because of this, <code>type2fmt</code> will automatically translate the <code>uint64_t</code> to the right format string: <code>%lu</code> or <code>%llu</code>. No <code>PRIu64</code> necessary.</p>
<h2 id="no-runtime-overhead">No Runtime Overhead</h2>
<p>What’s with the “no runtime overhead” and “no additional runtime code” promise?</p>
<p>Compiling the program…</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="pp">#include </span><span class="im">&lt;pprintpp.hpp&gt;</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb22-5" title="5">{</a>
<a class="sourceLine" id="cb22-6" title="6">    pprintf(<span class="st">&quot;{} hello {s}! {}</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="dv">1</span>, <span class="st">&quot;world&quot;</span>, <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb22-7" title="7">}</a></code></pre></div>
<p>…leads to the following <code>main</code> function in the binary:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb23-1" title="1"><span class="fu">bash</span> $ objdump -d example</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="ex">...</span></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="ex">0000000000400450</span> <span class="op">&lt;</span>main<span class="op">&gt;</span>:</a>
<a class="sourceLine" id="cb23-4" title="4">  <span class="ex">400450</span>:       48 83 ec 08             sub    <span class="va">$0</span>x8,%rsp</a>
<a class="sourceLine" id="cb23-5" title="5">  <span class="ex">400454</span>:       41 b8 02 00 00 00       mov    <span class="va">$0</span>x2,%r8d</a>
<a class="sourceLine" id="cb23-6" title="6">  <span class="ex">40045a</span>:       b9 04 06 40 00          mov    <span class="va">$0</span>x400604,%ecx <span class="co"># &lt;-- &quot;world&quot;</span></a>
<a class="sourceLine" id="cb23-7" title="7">  <span class="ex">40045f</span>:       ba 01 00 00 00          mov    <span class="va">$0</span>x1,%edx</a>
<a class="sourceLine" id="cb23-8" title="8">  <span class="ex">400464</span>:       be 10 06 40 00          mov    <span class="va">$0</span>x400610,%esi <span class="co"># &lt;-- &quot;%d hello world %s!...&quot;</span></a>
<a class="sourceLine" id="cb23-9" title="9">  <span class="ex">400469</span>:       bf 01 00 00 00          mov    <span class="va">$0</span>x1,%edi</a>
<a class="sourceLine" id="cb23-10" title="10">  <span class="ex">40046e</span>:       31 c0                   xor    %eax,%eax</a>
<a class="sourceLine" id="cb23-11" title="11">  <span class="ex">400470</span>:       e8 bb ff ff ff          callq  400430 <span class="op">&lt;</span>__printf_chk@plt<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb23-12" title="12">  <span class="ex">400475</span>:       31 c0                   xor    %eax,%eax</a>
<a class="sourceLine" id="cb23-13" title="13">  <span class="ex">400477</span>:       48 83 c4 08             add    <span class="va">$0</span>x8,%rsp</a>
<a class="sourceLine" id="cb23-14" title="14">  <span class="ex">40047b</span>:       c3                      retq</a>
<a class="sourceLine" id="cb23-15" title="15"><span class="ex">...</span></a></code></pre></div>
<p>Excerpt of the data section where the strings which are loaded reside:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" title="1"><span class="fu">bash</span> $ objdump -s -j .rodata example</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ex">...</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="ex">Contents</span> of section .rodata:</a>
<a class="sourceLine" id="cb24-4" title="4"> <span class="ex">400600</span> 01000200 776f726c 64000000 00000000  ....world.......</a>
<a class="sourceLine" id="cb24-5" title="5"> <span class="ex">400610</span> 25642068 656c6c6f 20257321 2025640a  %d hello %s! %d.</a>
<a class="sourceLine" id="cb24-6" title="6"> <span class="ex">400620</span> 00                                   .</a></code></pre></div>
<p>The string looks exactly as if one had written <code>printf("%d hello %s! %d\n", /* ... */);</code>.</p>
<p>Having exactly that string embedded in the binary does <strong>not</strong> rely on optimization. It <em>may</em> happen, that the <code>str()</code> function which statically returns this string, is still called in an unoptimized binary. But this function does <em>nothing</em> else than returning this string, which is already composed in the binary.</p>
<h2 id="limitations">Limitations</h2>
<p>The <code>autoformat_t</code> meta-program does only substitute generic placeholders with the right <code>%</code> format strings, which are compatible with <code>printf</code>.</p>
<p>It does <strong>not</strong> extend <code>printf</code> with more formatting capabilities. This way it is also not possible to print custom types because it is not possible to put some custom <code>%</code> format string into <code>printf</code>, which the original <code>printf</code> implementation does not know.</p>
<p>Of course, it is possible to extend the type knowledge of the <code>type2fmt</code> meta function, in order to feed custom implementations of <code>printf</code> like functions with additional type format strings.</p>
<p>There are libraries like <a href="https://github.com/fmtlib/fmt">libfmt</a> out there, which provide rich formatting capabilities. However, all such libraries add additional runtime overhead to the resulting program.</p>
<h2 id="compilation-performance">Compilation Performance</h2>
<p>Heavy template meta-programs tend to be slow. I invested a lot of time in measuring different type list implementations, in order to make this <code>printf</code> frontend <em>fast</em>.</p>
<p>In another blog article, I <a href="/2016/06/25/cpp_template_type_list_performance">measured the performance of type lists</a> using variadic template parameters, and recursive type lists. This library builds on the faster list implementation.</p>
<p>The resulting compile time overhead is <em>rarely</em> in measurable timing regions, which makes it useful for real life projects.</p>
<h2 id="summary">Summary</h2>
<p>I wrapped the code into a repository called <code>pprintpp</code> and published it on GitHub under the MIT license. (<a href="https://github.com/tfc/pprintpp">Link to the repository</a>)</p>
<p>This library is in production use for some time now and helped get rid of a lot of typos and variable-type accidents while being very comfortable at the same time.</p>
<p>I’d be happy to hear that it is useful to others outside of my projects, too!</p>]]></description>
    <pubDate>Sat, 05 Nov 2016 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2016/11/05/python_style_printf_for_cpp</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Do Not Fear Recursion</title>
    <link>https://blog.galowicz.de/2016/09/11/dont_fear_recursion</link>
    <description><![CDATA[<p>There are a lot of algorithms which can be implemented using <em>recursive</em> or <em>iterative</em> style. Actually, <strong>everything</strong> can be implemented in both styles. For a lot of algorithms, the recursive version is simpler to read, write, and understand. But nevertheless, programmers know, that recursive functions burden a lot of memory consumption, because there is usually a <code>call</code> instruction per recursive call, which puts another call frame on the stack. Interestingly, this is not true for some special cases.</p>
<!--more-->
<p>The idea to write this article came into my mind when I thought about a discussion which I listened to many years ago. At that time I worked at a company as a freelancer, before I started studying at university. The whole discussion was very open, but I felt a bit disturbed when a colleague said, that C/C++ is very limited in their optimization potential. One example for that point was, that languages like <em>Scala</em> can eliminate the stack growth in some recursion cases. I was very unexperienced, so I didn’t know better. Not too much later, I learned at university, that this special kind of recursion is called <a href="https://en.wikipedia.org/wiki/Tail_call"><strong>tail recursion</strong></a>. I was pretty happy when I realized that the optimization potential which that brings, is not a question of the language, but more a question of the compiler implementation.</p>
<p>As of today, this topic came to my attention multiple times. Since C++11, it is possible to let the compiler execute <em>normal</em> functions (instead of template meta code) at compile time, and get a guarantee that the result will be embedded in the binary, reducing execution time. Such functions are called <code>constexpr</code> functions. However, those functions had to be implemented recursively, as it is not possible to define variables and loops in <code>constexpr</code> functions in C++11. (This is fixed and allowed in C++14) At this occasion (and because of template meta-programming and learning Haskell) I got some more practice in thinking recursion aware.</p>
<h2 id="tail-recursion">Tail Recursion</h2>
<p>Some algorithms are very short and pretty, when implemented recursively. However, because of the fear that they would be inefficient, coders often just think how to implement them iteratively. Iterative versions do not increase the stack size, so they feel better.</p>
<p>Alternatively, by thinking of a <strong>tail</strong> recursive version, both simplicity of recursion, and performance of iterative style can be combined.</p>
<p>First: What <em>is</em> tail recursion?</p>
<p>Tail recursion occurs, when the result of a recursive function call completely depends on the same function call, just with other parameters.</p>
<p>Example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">int</span> f(<span class="dt">int</span> a, <span class="dt">int</span> b)</a>
<a class="sourceLine" id="cb1-2" title="2">{</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="co">// Some nonsense-algorithm which shows tail recursion</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="cf">if</span> (a == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="cf">return</span> b;</a>
<a class="sourceLine" id="cb1-6" title="6">    }</a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="cf">return</span> f(a * b, b - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb1-8" title="8">}</a></code></pre></div>
<p>In this case, only the parameters need to be refreshed with the values the next recursion call shall get. Then, instead of <code>call</code>ing the function (which jumps to the function beginning again, but also adds the return address on the stack), it can just be <code>jmp</code>ed at, which completely preserves the stack. (At this point I am talking about the <em>assembler</em> instructions <code>call</code> and <code>jmp</code>, which work similarly for most processor architectures, but may have slightly different names.)</p>
<p>An example case in which this would not work:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">int</span> f(<span class="dt">int</span> a, <span class="dt">int</span> b)</a>
<a class="sourceLine" id="cb2-2" title="2">{</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="cf">if</span> (a == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb2-4" title="4">        <span class="cf">return</span> b;</a>
<a class="sourceLine" id="cb2-5" title="5">    }</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="cf">return</span> <span class="dv">1</span> + f(a * b, b - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb2-7" title="7">}</a></code></pre></div>
<p>In this case, the <code>1 +</code> part needs to be executed for <em>every</em> recursive call, which happens <strong>after</strong> the recursive call. And for that, real function calls instead of tail jumps are assembled by the compiler. That can be fixed, however:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">int</span> f(<span class="dt">int</span> a, <span class="dt">int</span> b, <span class="dt">int</span> sum = <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">{</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">if</span> (a == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="cf">return</span> b + sum;</a>
<a class="sourceLine" id="cb3-5" title="5">    }</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="cf">return</span> f(a * b, b - <span class="dv">1</span>, sum + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb3-7" title="7">}</a></code></pre></div>
<p>This way, we pushed the information of that “post-adding 1” into the parameter variables and transformed the nonoptimal recursion into a tail recursion. (At this point, this algorithm does not look nicer than an iterative implementation using a loop. However, other algorithms do.)</p>
<p>That was just a cheap example. There are actually nice and very generic rules in literature, which describe how to transform between the different coding styles. (See also the Wikipedia article about tail recursion)</p>
<h2 id="gcd-example">GCD Example</h2>
<p>In order to proof the point of tail recursion, and to motivate people to use more recursion for tidy, but still fast code, I chose the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">GCD (<em>Greatest Common Divisor</em>)</a> algorithm, and the two typical different implementations of it:</p>
<p>The recursive version, which looks very similar to a math formula (at least in terms of C syntax):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">unsigned</span> gcd_rec(<span class="dt">unsigned</span> a, <span class="dt">unsigned</span> b)</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="cf">return</span> b ? gcd_rec(b, a % b) : a;</a>
<a class="sourceLine" id="cb4-4" title="4">}</a></code></pre></div>
<p>… and the iterative version, which would have a better performance, if the compiler did not know about tail recursion:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">unsigned</span> gcd_itr(<span class="dt">unsigned</span> a, <span class="dt">unsigned</span> b)</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="cf">while</span> (b) {</a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="dt">unsigned</span> tmp {b};</a>
<a class="sourceLine" id="cb5-5" title="5">        b = a % b;</a>
<a class="sourceLine" id="cb5-6" title="6">        a = tmp;</a>
<a class="sourceLine" id="cb5-7" title="7">    }</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="cf">return</span> a;</a>
<a class="sourceLine" id="cb5-9" title="9">}</a></code></pre></div>
<p>In my opinion, the recursive version looks much cleaner. What I particularly dislike when regarding the iterative version, is the fact that it is telling the compiler how exactly to temporarily save the value of <code>b</code>, in order to refresh <code>a</code> with it after the modulo operation. This is as primitive as “Well, do <code>a % b</code>, but I want <code>b</code> saved <strong>here</strong> and then written back <strong>there</strong>”, which is something which has nothing to do with the <em>actual</em> problem (calculating a GCD).</p>
<h2 id="comparing-compiler-output">Comparing compiler output</h2>
<p>Putting those two functions into a <code>.cpp</code> file and compiling it with <code>clang++ -c main.cpp -O2</code> reveals something interesting:</p>
<p>First, having a look at the recursive version shows, that it does indeed not contain any <code>call</code> instructions because it is implemented using solely jumps (conditional <code>je</code> and <code>jne</code> instructions). This shows, that this recursive version of the GCD algorithm can never lead to steep stack growth.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb6-1" title="1"><span class="dv">0000000000000000</span> &lt;_Z7gcd_recjj&gt;:</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="fu">   0:</span>	<span class="dv">89</span> f2                	<span class="bu">mov</span>    %<span class="kw">esi</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="fu">   2:</span>	<span class="dv">89</span> f8                	<span class="bu">mov</span>    %<span class="kw">edi</span>,%<span class="kw">eax</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="fu">   4:</span>	<span class="dv">85</span> d2                	<span class="bu">test</span>   %<span class="kw">edx</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="fu">   6:</span>	<span class="dv">74</span> <span class="dv">17</span>                	<span class="bu">je</span>     1f &lt;_Z7gcd_recjj+<span class="bn">0x1f</span>&gt;</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="fu">   8:</span>	0f 1f <span class="dv">84</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span> 	nopl   <span class="bn">0x0</span>(%<span class="kw">rax</span>,%<span class="kw">rax</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="fu">   f:</span>	<span class="dv">00</span> </a>
<a class="sourceLine" id="cb6-8" title="8"><span class="fu">  10:</span>	<span class="dv">89</span> d1                	<span class="bu">mov</span>    %<span class="kw">edx</span>,%<span class="kw">ecx</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="fu">  12:</span>	<span class="dv">31</span> d2                	<span class="bu">xor</span>    %<span class="kw">edx</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="fu">  14:</span>	f7 f1                	<span class="bu">div</span>    %<span class="kw">ecx</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="fu">  16:</span>	<span class="dv">85</span> d2                	<span class="bu">test</span>   %<span class="kw">edx</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="fu">  18:</span>	<span class="dv">89</span> c8                	<span class="bu">mov</span>    %<span class="kw">ecx</span>,%<span class="kw">eax</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="fu">  1a:</span>	<span class="dv">75</span> f4                	<span class="bu">jne</span>    <span class="dv">10</span> &lt;_Z7gcd_recjj+<span class="bn">0x10</span>&gt;</a>
<a class="sourceLine" id="cb6-14" title="14"><span class="fu">  1c:</span>	<span class="dv">89</span> c8                	<span class="bu">mov</span>    %<span class="kw">ecx</span>,%<span class="kw">eax</span></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="fu">  1e:</span>	c3                   	retq   </a>
<a class="sourceLine" id="cb6-16" title="16"><span class="fu">  1f:</span>	c3                   	retq   </a></code></pre></div>
<p>However, looking at the iterative version shows, that both versions are completely <strong>identical</strong>. This is pretty cool, because this way we can profit from the performance of iterative code, although our C++ code is a slick and tidy recursive implementation!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb7-1" title="1"><span class="dv">0000000000000020</span> &lt;_Z7gcd_itrjj&gt;:</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">  20:</span>	<span class="dv">89</span> f2                	<span class="bu">mov</span>    %<span class="kw">esi</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="fu">  22:</span>	<span class="dv">89</span> f8                	<span class="bu">mov</span>    %<span class="kw">edi</span>,%<span class="kw">eax</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">  24:</span>	<span class="dv">85</span> d2                	<span class="bu">test</span>   %<span class="kw">edx</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="fu">  26:</span>	<span class="dv">74</span> <span class="dv">17</span>                	<span class="bu">je</span>     3f &lt;_Z7gcd_itrjj+<span class="bn">0x1f</span>&gt;</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="fu">  28:</span>	0f 1f <span class="dv">84</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span> 	nopl   <span class="bn">0x0</span>(%<span class="kw">rax</span>,%<span class="kw">rax</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-7" title="7"><span class="fu">  2f:</span>	<span class="dv">00</span> </a>
<a class="sourceLine" id="cb7-8" title="8"><span class="fu">  30:</span>	<span class="dv">89</span> d1                	<span class="bu">mov</span>    %<span class="kw">edx</span>,%<span class="kw">ecx</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="fu">  32:</span>	<span class="dv">31</span> d2                	<span class="bu">xor</span>    %<span class="kw">edx</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="fu">  34:</span>	f7 f1                	<span class="bu">div</span>    %<span class="kw">ecx</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="fu">  36:</span>	<span class="dv">85</span> d2                	<span class="bu">test</span>   %<span class="kw">edx</span>,%<span class="kw">edx</span></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="fu">  38:</span>	<span class="dv">89</span> c8                	<span class="bu">mov</span>    %<span class="kw">ecx</span>,%<span class="kw">eax</span></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="fu">  3a:</span>	<span class="dv">75</span> f4                	<span class="bu">jne</span>    <span class="dv">30</span> &lt;_Z7gcd_itrjj+<span class="bn">0x10</span>&gt;</a>
<a class="sourceLine" id="cb7-14" title="14"><span class="fu">  3c:</span>	<span class="dv">89</span> c8                	<span class="bu">mov</span>    %<span class="kw">ecx</span>,%<span class="kw">eax</span></a>
<a class="sourceLine" id="cb7-15" title="15"><span class="fu">  3e:</span>	c3                   	retq   </a>
<a class="sourceLine" id="cb7-16" title="16"><span class="fu">  3f:</span>	c3                   	retq   </a>
<a class="sourceLine" id="cb7-17" title="17"></a></code></pre></div>
<h2 id="summary">Summary</h2>
<p>The GCD algorithm is a very short example for the behaviour of telling the compiler much more than needed to solve the actual problem, because imperative programming is all about telling the computer <em>what</em> to do, and <em>how</em> to do it. On the level of writing assembler code, it is pretty normal that the question “<em>what</em> data?” is pretty much the same as “which memory <em>address</em>/register and size?”, because there is no abstraction from the hardware implementation nature (a <em>von Neumann</em> machine with untyped memory).</p>
<p>When using languages like C++, a lot of abstraction can be gained with <em>no cost</em>, which is a favorable thing. <em>Tail recursion</em> is a nice step towards such simplifying abstractions, and can be used for free, which is pretty much worth knowing about it.</p>]]></description>
    <pubDate>Sun, 11 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2016/09/11/dont_fear_recursion</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Wrapping Algorithms into Iterators</title>
    <link>https://blog.galowicz.de/2016/09/04/algorithms_in_iterators</link>
    <description><![CDATA[<p>Sometimes there is the requirement to generate a range of numbers from some algorithm. Be it a simple range of increasing numbers, or only odd numbers, or only primes, or whatever. Some calculations can be optimized by <em>memorizing</em> some values for the calculation of the next number, just as this applies for <strong>fibonacci numbers</strong>. This article shows how to wrap such calculations into <strong>iterators</strong> in order to have performant, and nicely encapsulated algorithms.</p>
<!--more-->
<h1 id="fibonacci-numbers">Fibonacci Numbers</h1>
<p>The fibonacci number sequence is widely known. Generating those numbers is often used as a typical example for recursions, but at least in standard imperative programming languages, the iterative version is more performant:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">size_t</span> fib(<span class="dt">size_t</span> n)</a>
<a class="sourceLine" id="cb1-2" title="2">{</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dt">size_t</span> a {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="dt">size_t</span> b {<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="cf">for</span> (<span class="dt">size_t</span> i {<span class="dv">0</span>}; i &lt; n; ++i) {</a>
<a class="sourceLine" id="cb1-7" title="7">        <span class="at">const</span> <span class="dt">size_t</span> old_b {b};</a>
<a class="sourceLine" id="cb1-8" title="8">        b += a;</a>
<a class="sourceLine" id="cb1-9" title="9">        a  = old_b;</a>
<a class="sourceLine" id="cb1-10" title="10">    }</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="cf">return</span> b;</a>
<a class="sourceLine" id="cb1-13" title="13">}</a></code></pre></div>
<p>This way it is easy to generate any fibonacci number. But if all fibonacci numbers up to a certain limit need to be generated for some purpose, this implementation is not too handy any longer. When counting fibonacci number <code>N</code>, and then <code>N+1</code>, the content of the variables <code>a</code> and <code>b</code> could be reused, because the next fibonacci number is just the sum of the last two fibonacci numbers.</p>
<p>In this sense, it would be useful to have a class, which manages some <em>fibonacci state</em> in order to be able to quickly calculate just the next number.</p>
<p>A lot of people would just implement a class <code>fibonacci_number</code> which has some <code>next()</code> method and a <code>current()</code> method and use that. This is fine, but i propose to go a step further by realizing that this is how <strong><em>iterators</em></strong> work. By implementing this functionality in terms of iterators, it can be used in combination with the STL, boosting up the code readability.</p>
<h1 id="iterators">Iterators</h1>
<p>What do we need in order to implement the simplest possible iterator?</p>
<p>Let us have a look at what the C++ compiler asks for if we want to iterate over a container class:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span> &amp;item : vector) {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co">/* loop body */</span></a>
<a class="sourceLine" id="cb2-3" title="3">}</a></code></pre></div>
<p>This kind of loop declaration exists since C++11. The compiler will expand this to the following equivalent code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">{</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">auto</span> it  (<span class="bu">std::</span>begin(vector));</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">auto</span> end (<span class="bu">std::</span>end(vector));</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">for</span> (; it != end; ++it) {</a>
<a class="sourceLine" id="cb3-6" title="6">        <span class="at">const</span> <span class="kw">auto</span> &amp;item (*it);</a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="co">/* loop body */</span></a>
<a class="sourceLine" id="cb3-8" title="8">    }</a>
<a class="sourceLine" id="cb3-9" title="9">}</a></code></pre></div>
<p>Looking at the expanded loop, it is pretty obvious what needs to be implemented. First, we need to distinguish between two kinds of objects: <code>vector</code> is the <strong>iterable range</strong>, and <code>it</code> is the <strong>iterator</strong>.</p>
<p>The <strong>iterable range</strong> needs to implement a <code>begin()</code> and an <code>end()</code> function. These functions return iterator objects.</p>
<blockquote>
<p>Note that this code sample does not call <code>vector.begin()</code> and <code>vector.end()</code>, but <code>std::begin(vector)</code> and <code>std::end(vector)</code>. Those STL functions do actually call <code>vector.begin()</code> and <code>end()</code>, but they are more generic, i.e. they also work on raw arrays and automatically do the right thing in order to obtain begin/end iterators.</p>
</blockquote>
<p>The <strong>iterator</strong> class needs to implement the following:</p>
<ul>
<li>operator <code>*</code>, which works like dereferencing a pointer (pointers are also valid iterators!)</li>
<li>operator <code>++</code> (prefix), which increments the iterator to the next item</li>
<li>operator <code>!=</code>, which is necessary in order to check if the loop shall terminate because <code>it</code> reached the same position as <code>end</code> denotes.</li>
</ul>
<p>In order to implement any kind of algorithm-generated range, we would first implement an iterator which basically hides variables and the algorithm itself in the <code>operator++</code> implementation. An iterable class would then just provide a begin and end iterator as needed, in order to enable for C++11 style <code>for</code> loops.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> iterator</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="co">// ... state variables ...</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="co">// Constructor</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8">    iterator&amp; <span class="kw">operator</span>++() { <span class="co">/* increment */</span> <span class="cf">return</span> *<span class="kw">this</span>; }</a>
<a class="sourceLine" id="cb4-9" title="9"></a>
<a class="sourceLine" id="cb4-10" title="10">    T <span class="kw">operator</span>*() <span class="at">const</span> { <span class="co">/* return some value or reference */</span> }</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="dt">bool</span> <span class="kw">operator</span>!= <span class="at">const</span> (<span class="at">const</span> iterator&amp; o) { <span class="co">/* compare states */</span> }</a>
<a class="sourceLine" id="cb4-13" title="13">}</a></code></pre></div>
<p>The simplest iterator ever would be a counting iterator: It would just wrap an integer variable, increment it in <code>operator++</code> and return the integer in <code>operator*</code>. <code>operator!=</code> would then just compare this number with the number of another iterator.</p>
<p>But now let us continue with the fibonacci iterator.</p>
<h1 id="fibonacci-iterator">Fibonacci Iterator</h1>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> fibit</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="dt">size_t</span> i {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="dt">size_t</span> a {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="dt">size_t</span> b {<span class="dv">1</span>};</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="kw">constexpr</span> fibit() = <span class="cf">default</span>;</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="kw">constexpr</span> fibit(<span class="dt">size_t</span> <span class="va">b_</span>, <span class="dt">size_t</span> <span class="va">a_</span>, <span class="dt">size_t</span> <span class="va">i_</span>)</a>
<a class="sourceLine" id="cb5-11" title="11">        : i{<span class="va">i_</span>}, a{<span class="va">a_</span>}, b{<span class="va">b_</span>}</a>
<a class="sourceLine" id="cb5-12" title="12">    {}</a>
<a class="sourceLine" id="cb5-13" title="13"></a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="dt">size_t</span> <span class="kw">operator</span>*() <span class="at">const</span> { <span class="cf">return</span> b; }</a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="kw">constexpr</span> fibit&amp; <span class="kw">operator</span>++() {</a>
<a class="sourceLine" id="cb5-17" title="17">        <span class="at">const</span> <span class="dt">size_t</span> old_b {b};</a>
<a class="sourceLine" id="cb5-18" title="18">        b += a;</a>
<a class="sourceLine" id="cb5-19" title="19">        a  = old_b;</a>
<a class="sourceLine" id="cb5-20" title="20">        ++i;</a>
<a class="sourceLine" id="cb5-21" title="21">        <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb5-22" title="22">    }</a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24">    <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> fibit &amp;o) <span class="at">const</span> { <span class="cf">return</span> i != o.i; }</a>
<a class="sourceLine" id="cb5-25" title="25">};</a></code></pre></div>
<p>Using this iterator, it is already possible to iterate over fibonacci numbers:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">fibit it;</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">// As the comparison operator only compares the &quot;i&quot; variable,</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">// define an iterator with everything zeroed, but &quot;i&quot; set</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">// to 20, in order to have an iteration terminator</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="at">const</span> fibit end {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>};</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="cf">while</span> (it != end) {</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="bu">std::</span>cout &lt;&lt; *it &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb6-10" title="10">    ++it;</a>
<a class="sourceLine" id="cb6-11" title="11">}</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="co">// Or do it the elegant STL way: (include &lt;iterator&gt; first)</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="bu">std::</span>copy(it, end, <span class="bu">std::</span>ostream_iterator&lt;<span class="dt">size_t</span>&gt;{<span class="bu">std::</span>cout,<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>});</a></code></pre></div>
<p>In order to do it the nice C++11 way, we need an iterable class:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> fib_range</a>
<a class="sourceLine" id="cb7-2" title="2">{</a>
<a class="sourceLine" id="cb7-3" title="3">    fibit  begin_it;</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="dt">size_t</span> end_n;</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="kw">constexpr</span> fib_range(<span class="dt">size_t</span> <span class="va">end_n_</span>, <span class="dt">size_t</span> begin_n = <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb7-8" title="8">        : begin_it{fibit_at(begin_n)}, end_n{<span class="va">end_n_</span>}</a>
<a class="sourceLine" id="cb7-9" title="9">    {}</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11">    fibit begin() <span class="at">const</span> { <span class="cf">return</span> begin_it; }</a>
<a class="sourceLine" id="cb7-12" title="12">    fibit end()   <span class="at">const</span> { <span class="cf">return</span> {<span class="dv">0</span>, <span class="dv">0</span>, end_n}; }</a>
<a class="sourceLine" id="cb7-13" title="13">};</a></code></pre></div>
<p>We can now write…</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="cf">for</span> (<span class="at">const</span> <span class="dt">size_t</span> num : fib_range(<span class="dv">10</span>)) {</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="bu">std::</span>cout &lt;&lt; num &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb8-3" title="3">}</a></code></pre></div>
<p>… which will print the first 10 fibonacci numbers.</p>
<p>What does the function <code>fibit_at</code> do? This function is a <code>constexpr</code> function, which advances a fibonacci iterator at <em>compile time</em> if possible, in order to push the iterator towards the fibonacci number which the user wants:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">constexpr</span> fibit fibit_at(<span class="dt">size_t</span> n)</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">    fibit it;</a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="cf">for</span> (<span class="dt">size_t</span> i {<span class="dv">0</span>}; i &lt; n; ++i) {</a>
<a class="sourceLine" id="cb9-5" title="5">        ++it;</a>
<a class="sourceLine" id="cb9-6" title="6">    }</a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="cf">return</span> it;</a>
<a class="sourceLine" id="cb9-8" title="8">}</a></code></pre></div>
<p>This function enables us to for example iterate from the 100th fibonacci number to the 105th, without having to calculate the first 100 fibonacci numbers at run time, because we can make the compiler prepare everything at compile time.</p>
<blockquote>
<p>When using C++17, <code>fibit_at</code> is useless, as it can be substituted by <code>std::next(fibit{}, n)</code>, because in the C++17 STL <code>std::next</code> is a <code>constexpr</code> function.</p>
</blockquote>
<p>In order to guarantee, that the 100th fibonacci number is already calculated, when the compiler writes the binary program to disk, we can just put the range into a <code>constexpr</code> variable:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">constexpr</span> <span class="at">const</span> fib_range hundred_to_hundredfive {<span class="dv">105</span>, <span class="dv">100</span>};</a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="cf">for</span> (<span class="dt">size_t</span> num : hundred_to_hundredfive) {</a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="co">// Do whatever</span></a>
<a class="sourceLine" id="cb10-5" title="5">}</a></code></pre></div>
<h1 id="combine-the-fibonacci-iterator-with-stl-algorithms">Combine the Fibonacci Iterator with STL algorithms</h1>
<p>Imagine we need a vector with the first 1000 fibonacci numbers. Having the fibonacci algorithm already wrapped into a handy iterator class, we can now use it with any STL algorithm from namespace <code>std</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="bu">std::</span>vector&lt;<span class="dt">size_t</span>&gt; fib_nums;</a>
<a class="sourceLine" id="cb11-2" title="2">fib_nums.resize(<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">constexpr</span> <span class="at">const</span> fib_range first1000 {<span class="dv">1000</span>};</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="bu">std::</span>copy(<span class="bu">std::</span>begin(first1000), <span class="bu">std::</span>end(first1000), <span class="bu">std::</span>begin(fib_nums));</a></code></pre></div>
<p>This is pretty neat and useful. However, with the current example code provided as is, this will not compile (yet), because we did not provide an iterator tag. Providing it is simple: Just make <code>fibit</code> publicly inherit from <code>std::iterator&lt;std::forward_iterator_tag, size_t&gt;</code>.</p>
<p><code>std::iterator</code> as a base class for our <code>fibit</code> class will only add some typedefs which help STL algorithms identify which kind of iterator this is. For certain iterator types in certain situations, the STL algorithms have different implementations which contain performance optimizations (Which is elegantly hidden from the user!).</p>
<p>The <code>std::forward_iterator</code> tag states, that this is an iterator which can just be advanced step by step, and that it only advances forward, not backward.</p>
<h1 id="summary">Summary</h1>
<p>A lot of algorithms which generate numeric ranges, can be implemented in terms of iterators, which is a natural fit. C++ provides nice syntax sugar for iterators, which makes them a natural interface for abstractions.</p>
<p>In combination with STL algorithms and any STL compatible data structures, they promote for easy to read, easy to test, easy to maintain, and performant code.</p>
<p>This article described a kind of iterator, which is not a plain pointer to <em>data</em>. It is an algorithm implementation in the sense, that the <em>increment</em> step does actually calculate something more complex than just a new internal pointer position to some next item. Interestingly, this way one can instantiate some kind of <em>iterable</em> object, which defines a range, which involves a lot of computation - but that computation is not executed until someone actually asks for the result (And the code which asks for the result does not even need to know what kind of algorithm it is implicitly executing, as this is all hidden behind a simple iterator interface). This kind of programming style goes towards <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>, which is a powerful and elegant principle known from purely functional programming languages.</p>]]></description>
    <pubDate>Sun, 04 Sep 2016 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2016/09/04/algorithms_in_iterators</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Type List Compile Time Performance</title>
    <link>https://blog.galowicz.de/2016/06/25/cpp_template_type_list_performance</link>
    <description><![CDATA[<p>Soon, after writing my first meta programs with C++ templates, i realized, that certain programming patterns lead to sky rocketing compile times. I came up with rules of thumb like “<em>Prefer pattern matching over if_else_t</em>”, and “<em>Prefer nested type lists over variadic type lists</em>”. But i did not know how much faster which pattern is, i just knew about tendencies. Finally, i sat down to write some compile time benchmarks, and this blog posts presents the results.</p>
<!--more-->
<h1 id="creating-lists">Creating Lists</h1>
<p>A fundamental thing to measure are <strong>lists</strong>. Everything else which can grow to arbitrary sizes, will somehow be implemented using lists. There are different possible ways to implement lists. I present measurements of nested and variadic type lists. This article does not explain how to implement them, but there is an <a href="/2016/05/08/compile_time_type_lists">article about C++ template type lists</a> already.</p>
<p>The first benchmark just creates lists of rising sizes, and measures how much time that takes. The lists are generated from integer sequences, just like those from <a href="/2016/06/24/integer_sequences_at_compile_time">this article which explains how to generate integer sequences at compile time</a>.</p>
<p>I present graphs for doing this inside <a href="http://metashell.org/">Metashell</a>, and also using real compilers. Metashell is a great tool for debugging meta programs, or playing around with expressions. It is basically what <code>ghci</code> is to Haskell, an interactive shell for programming.</p>
<p>Since Metashell does also provide a profiling feature, it is tempting to measure performance with it. This turns out to be a bad idea when comparing such performance numbers with real compiler performance: Not only are compilers significantly faster than meta shell, but they also do generate <em>completely different</em> numbers.</p>
<p>It is generally fine, that Metashell instantiates templates slower than compilers do. Metashell is meant as a development tool, and not as a high performance compiler. However, using it to compare the performance of different algorithms can result in very misleading numbers.</p>
<h2 id="metashell">Metashell</h2>
<figure>
<img src="/images/compile_time_type_list_creation_benchmark_metashell.png" alt="Metashell: Compile time benchmark measuring creation time of integer sequence nested vs. variadic type lists" /><figcaption>Metashell: Compile time benchmark measuring creation time of integer sequence nested vs. variadic type lists</figcaption>
</figure>
<p>The graphs both have fitted polygonal function overlays. The runtime of generating lists, both nested and variadic types, is obviously within <span class="math inline">𝒪(<em>n</em><sup>2</sup>)</span>. This is usually something which would be considered having <em>linear</em> runtime, because the lists grow linearly.</p>
<p>These numbers turn out to be completely different when measured on real compilers like Clang and GCC:</p>
<h2 id="compilers">Compilers</h2>
<p>To my knowledge it is not possible to measure only the actual template instantiation time when using a compiler. Hence i just measured how long it takes the compiler to start, instantiate the template code, and exit again. These numbers are inherently more noisy than the metashell numbers.</p>
<figure>
<img src="/images/compile_time_type_list_creation_benchmark_compilers.png" alt="GCC/Clang: Compile time benchmark measuring creation time of integer sequence nested vs. variadic type lists" /><figcaption>GCC/Clang: Compile time benchmark measuring creation time of integer sequence nested vs. variadic type lists</figcaption>
</figure>
<p>Both GCC and Clang are much faster in instantiating large variadic lists, compared to Metashell. But what is most obvious on this graph, is that nested type lists in turn are <strong>much</strong> faster than variadic type lists.</p>
<p>Variadic type lists are easier to read and write for programmers, but this performance penalty makes their use inpractiable for algorithms. Hence, variadic type lists can nicely be used as input/output interface to the user (the coder). But inbetween, they should be converted to type lists, in order to work efficiently on the data they convey. <a href="/2016/05/14/converting_between_c_strings_and_type_lists">This article explains how to convert between different type list formats</a>.</p>
<p>The performance numbers of GCC and Clang when instantiating nested type lists, look really similar in this diagram. They actually are, and i do not provide another diagram showing only these two graphs. A comparison between them based on this data would not be too fair, as these graphs are really noisy. It would be easier to compare with even larger type lists, but i experienced compiler <em>crashes</em> with even higher numbers.</p>
<h1 id="filtering-lists">Filtering Lists</h1>
<p>The next thing to measure after creating lists, is applying operations on them. I chose to measure how long it takes to apply a <strong>filter</strong> on a list. The filter itself is rather cheap: I implemented functions which take a list of integer sequences, and return a list of integer sequences, but inbetween <em>remove</em> all <em>even</em> numbers.</p>
<p>I wrote one benchmark measuring different implementations (a code snippet appendix follows at the end of the article):</p>
<ul>
<li>Filtering the even numbers out using the <code>if_else_t</code> construct</li>
<li>Filtering the even numbers out using <em>pattern matching</em></li>
<li>Generating lists which do not contain even numbers from the beginning</li>
</ul>
<p>Comparing the same algorithm using <code>if_else_t</code> vs. <em>pattern matching</em> is interesting, because there are obvious performance differences.</p>
<p>I tried to do a <em>fair</em> comparison between filtering nested and variadic type lists. To ensure this, i implemented the if-else/pattern-matching variants <em>once</em> in a way that the same implementation works on both kinds of lists.</p>
<p>All these algorithms are applied to both nested and variadic type lists. As the list creation benchmark already suggests, the nested variants of these algorithms will be faster. This time, the differences between Clang and GCC are more significant when looking at the nested variants, hence i present another diagram plotting only these.</p>
<figure>
<img src="/images/compile_time_type_list_filter_benchmark.png" alt="GCC/Clang: Compile time benchmark measuring list filter performance of integer sequence nested vs. variadic type lists" /><figcaption>GCC/Clang: Compile time benchmark measuring list filter performance of integer sequence nested vs. variadic type lists</figcaption>
</figure>
<p>There are three obvious clusters in this diagram:</p>
<h3 id="variadic-list-operations-on-gcc">Variadic list operations on GCC</h3>
<p>This cluster shows very nicely, that the performance using <code>if_else_t</code> for filtering items is worst, compared to all other variants. Applying pattern matching is indeed faster.</p>
<p>The most performant variant is assembling an already filtered list. This effectively removes the overhead of at first generating a full sequence, and filtering it afterwards.</p>
<h3 id="variadic-list-operations-on-clang">Variadic list operations on Clang</h3>
<p>Here, we see a generally similar pattern compared to the variadic-GCC-cluster before, but it is a bit faster with this compiler. Clang handles variadic type lists faster than GCC does.</p>
<p>Apart from that, the pattern matching style filter operation on the type list is faster, than creating an already filtered list. For some reason. I don’t know.</p>
<h3 id="nested-list-operations-on-clanggcc">Nested list operations on Clang/GCC</h3>
<p>All of these transformations on nested type lists are <strong>generally</strong> faster, and they are <strong>much</strong> faster.</p>
<p>Because the differences are not obvious on the first diagram, they are extracted and plotted on a nested-only diagram:</p>
<figure>
<img src="/images/compile_time_type_list_filter_benchmark_recursive_only.png" alt="GCC/Clang: Compile time benchmark measuring list filter performance of integer sequence nested type lists" /><figcaption>GCC/Clang: Compile time benchmark measuring list filter performance of integer sequence nested type lists</figcaption>
</figure>
<p>These numbers are very noisy, because they are near to the general process start time of the compiler executable in the shell.</p>
<p>Apart from that, the two different implementations of list filter operations, and manual filtered list creation have the same performance characteristics like before, when compared to each other.</p>
<p>Interestingly, clang seems to be slower for small type lists, because the time it takes to launch and return to shell is larger. For large type lists (which means they contain about 500 and more items), clang takes over and compiles faster.</p>
<p>The most important observation here is, that the runtime of these algorithms on nested type lists seems to be within <span class="math inline">𝒪(<em>n</em>)</span>. Creating variadic type lists alone is already <span class="math inline">𝒪(<em>n</em><sup>2</sup>)</span>.</p>
<h1 id="the-implementations">The Implementations</h1>
<p>This section shows the implementations of <em>what</em> i actually measured. There’s not much explanation how this works, because i wrote other articles covering that:</p>
<ul>
<li>To understand basics like <code>if_else_t</code>, and pattern matching, have a look at <a href="/2016/05/05/template_meta_programming_basics">the template meta programming basics 101 article</a>.</li>
<li>To understand, how type lists work, please have a look at <a href="/2016/05/08/compile_time_type_lists">the type list article</a>.</li>
</ul>
<p>Both list filter implementations remove even numbers from the input type list. They are implemented in a way that they can handle both variadic and nested type lists.</p>
<p>Only for creating already filtered lists, there are two different implementations for the different types of type lists.</p>
<p>For all functions, at the very <em>bottom</em> of every example, there is an <code>odds_t</code> using clause, which represents the actual user interface.</p>
<h2 id="if_else_t">if_else_t</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">struct</span> odds</a>
<a class="sourceLine" id="cb1-3" title="3">{</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">int</span>  val    {<span class="dt">head_t</span>&lt;List&gt;::value};</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">bool</span> is_odd {(val % <span class="dv">2</span>) != <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">using</span> next = <span class="kw">typename</span> odds&lt;<span class="dt">tail_t</span>&lt;List&gt;&gt;::type;</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="co">// If odd, prepend value to list. Else, skip it:</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">using</span> type = <span class="dt">if_else_t</span>&lt;is_odd, </a>
<a class="sourceLine" id="cb1-10" title="10">                    <span class="dt">prepend_t</span>&lt;next, <span class="dt">head_t</span>&lt;List&gt;&gt;, </a>
<a class="sourceLine" id="cb1-11" title="11">                    next</a>
<a class="sourceLine" id="cb1-12" title="12">                 &gt;;</a>
<a class="sourceLine" id="cb1-13" title="13">};</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">// Recursion terminator for nested type lists</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="kw">template</span> &lt;&gt;</a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">struct</span> odds&lt;rec_tl::<span class="dt">null_t</span>&gt;</a>
<a class="sourceLine" id="cb1-18" title="18">{</a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="kw">using</span> type = rec_tl::<span class="dt">null_t</span>;</a>
<a class="sourceLine" id="cb1-20" title="20">};</a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="co">// Recursion terminator for variadic type lists</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="kw">template</span> &lt;&gt;</a>
<a class="sourceLine" id="cb1-24" title="24"><span class="kw">struct</span> odds&lt;var_tl::tl&lt;&gt;&gt;</a>
<a class="sourceLine" id="cb1-25" title="25">{</a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="kw">using</span> type = var_tl::tl&lt;&gt;;</a>
<a class="sourceLine" id="cb1-27" title="27">};</a>
<a class="sourceLine" id="cb1-28" title="28"></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="kw">template</span> &lt;<span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb1-30" title="30"><span class="kw">using</span> <span class="dt">odds_t</span> = <span class="kw">typename</span> odds&lt;List&gt;::type;</a></code></pre></div>
<h2 id="pattern-matching">Pattern Matching</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// is_odd = true: Prepend item to list</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">// This is not a template specialization, but there is a template</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">// specialization afterwards, which assumes is_odd=false.</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">// Hence, this is an implicit specialization on is_odd=true cases.</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">template</span> &lt;<span class="dt">bool</span> is_odd, <span class="kw">typename</span> Head, <span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">struct</span> odds</a>
<a class="sourceLine" id="cb2-7" title="7">{</a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="kw">using</span> next = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb2-9" title="9">                            (<span class="dt">head_t</span>&lt;List&gt;::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb2-10" title="10">                            <span class="dt">head_t</span>&lt;List&gt;, </a>
<a class="sourceLine" id="cb2-11" title="11">                            <span class="dt">tail_t</span>&lt;List&gt;&gt;::type;</a>
<a class="sourceLine" id="cb2-12" title="12">    <span class="kw">using</span> type = <span class="dt">prepend_t</span>&lt;next, Head&gt;;</a>
<a class="sourceLine" id="cb2-13" title="13">};</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co">// is_odd = false: Skip item</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head, <span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb2-17" title="17"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Head, List&gt;</a>
<a class="sourceLine" id="cb2-18" title="18">{</a>
<a class="sourceLine" id="cb2-19" title="19">    <span class="kw">using</span> type = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb2-20" title="20">                            (<span class="dt">head_t</span>&lt;List&gt;::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb2-21" title="21">                            <span class="dt">head_t</span>&lt;List&gt;, </a>
<a class="sourceLine" id="cb2-22" title="22">                            <span class="dt">tail_t</span>&lt;List&gt;&gt;::type;</a>
<a class="sourceLine" id="cb2-23" title="23">};</a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25"><span class="co">// Recursion terminator for nested type lists</span></a>
<a class="sourceLine" id="cb2-26" title="26"><span class="co">// Last element: is_odd = true</span></a>
<a class="sourceLine" id="cb2-27" title="27"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb2-28" title="28"><span class="kw">struct</span> odds&lt;<span class="kw">true</span>, Head, rec_tl::<span class="dt">null_t</span>&gt;</a>
<a class="sourceLine" id="cb2-29" title="29">{</a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="kw">using</span> type = rec_tl::tl&lt;Head, rec_tl::<span class="dt">null_t</span>&gt;;</a>
<a class="sourceLine" id="cb2-31" title="31">};</a>
<a class="sourceLine" id="cb2-32" title="32"></a>
<a class="sourceLine" id="cb2-33" title="33"><span class="co">// Recursion terminator for nested type lists</span></a>
<a class="sourceLine" id="cb2-34" title="34"><span class="co">// Last element: is_odd = false</span></a>
<a class="sourceLine" id="cb2-35" title="35"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb2-36" title="36"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Head, rec_tl::<span class="dt">null_t</span>&gt;</a>
<a class="sourceLine" id="cb2-37" title="37">{</a>
<a class="sourceLine" id="cb2-38" title="38">    <span class="kw">using</span> type = rec_tl::<span class="dt">null_t</span>;</a>
<a class="sourceLine" id="cb2-39" title="39">};</a>
<a class="sourceLine" id="cb2-40" title="40"></a>
<a class="sourceLine" id="cb2-41" title="41"><span class="co">// Recursion terminator for variadic type lists</span></a>
<a class="sourceLine" id="cb2-42" title="42"><span class="co">// Last element: is_odd = true</span></a>
<a class="sourceLine" id="cb2-43" title="43"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb2-44" title="44"><span class="kw">struct</span> odds&lt;<span class="kw">true</span>, Head, var_tl::tl&lt;&gt;&gt;</a>
<a class="sourceLine" id="cb2-45" title="45">{</a>
<a class="sourceLine" id="cb2-46" title="46">    <span class="kw">using</span> type = var_tl::tl&lt;Head&gt;;</a>
<a class="sourceLine" id="cb2-47" title="47">};</a>
<a class="sourceLine" id="cb2-48" title="48"></a>
<a class="sourceLine" id="cb2-49" title="49"><span class="co">// Recursion terminator for variadic type lists</span></a>
<a class="sourceLine" id="cb2-50" title="50"><span class="co">// Last element: is_odd = false</span></a>
<a class="sourceLine" id="cb2-51" title="51"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb2-52" title="52"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Head, var_tl::tl&lt;&gt;&gt;</a>
<a class="sourceLine" id="cb2-53" title="53">{</a>
<a class="sourceLine" id="cb2-54" title="54">    <span class="kw">using</span> type = var_tl::tl&lt;&gt;;</a>
<a class="sourceLine" id="cb2-55" title="55">};</a>
<a class="sourceLine" id="cb2-56" title="56"></a>
<a class="sourceLine" id="cb2-57" title="57"><span class="kw">template</span> &lt;<span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb2-58" title="58"><span class="kw">using</span> <span class="dt">odds_t</span> = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb2-59" title="59">                            (<span class="dt">head_t</span>&lt;List&gt;::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb2-60" title="60">                            <span class="dt">head_t</span>&lt;List&gt;, </a>
<a class="sourceLine" id="cb2-61" title="61">                            <span class="dt">tail_t</span>&lt;List&gt;&gt;::type;</a></code></pre></div>
<h2 id="filtered-list-generation">Filtered List Generation</h2>
<p>Nested:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">template</span> &lt;<span class="dt">bool</span> is_odd, <span class="kw">typename</span> Head, <span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">struct</span> odds;</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head, <span class="kw">typename</span> TailHead, <span class="kw">typename</span> TailTail&gt;</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">struct</span> odds&lt;<span class="kw">true</span>, Head, rec_tl::tl&lt;TailHead, TailTail&gt;&gt;</a>
<a class="sourceLine" id="cb3-6" title="6">{</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">using</span> next = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb3-8" title="8">                            (TailHead::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb3-9" title="9">                            TailHead, </a>
<a class="sourceLine" id="cb3-10" title="10">                            TailTail&gt;::type;</a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="kw">using</span> type = rec_tl::tl&lt;Head, next&gt;</a>
<a class="sourceLine" id="cb3-12" title="12">};</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head, <span class="kw">typename</span> TailHead, <span class="kw">typename</span> TailTail&gt;</a>
<a class="sourceLine" id="cb3-15" title="15"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Head, rec_tl::tl&lt;TailHead, TailTail&gt;&gt;</a>
<a class="sourceLine" id="cb3-16" title="16">{</a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="kw">using</span> type = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb3-18" title="18">                            (TailHead::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb3-19" title="19">                            TailHead, </a>
<a class="sourceLine" id="cb3-20" title="20">                            TailTail&gt;::type;</a>
<a class="sourceLine" id="cb3-21" title="21">};</a>
<a class="sourceLine" id="cb3-22" title="22"></a>
<a class="sourceLine" id="cb3-23" title="23"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb3-24" title="24"><span class="kw">struct</span> odds&lt;<span class="kw">true</span>, Head, rec_tl::<span class="dt">null_t</span>&gt;</a>
<a class="sourceLine" id="cb3-25" title="25">{</a>
<a class="sourceLine" id="cb3-26" title="26">    <span class="kw">using</span> type = rec_tl::tl&lt;Head, rec_tl::<span class="dt">null_t</span>&gt;;</a>
<a class="sourceLine" id="cb3-27" title="27">};</a>
<a class="sourceLine" id="cb3-28" title="28"></a>
<a class="sourceLine" id="cb3-29" title="29"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb3-30" title="30"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Head, rec_tl::<span class="dt">null_t</span>&gt;</a>
<a class="sourceLine" id="cb3-31" title="31">{</a>
<a class="sourceLine" id="cb3-32" title="32">    <span class="kw">using</span> type = rec_tl::<span class="dt">null_t</span>;</a>
<a class="sourceLine" id="cb3-33" title="33">};</a>
<a class="sourceLine" id="cb3-34" title="34"></a>
<a class="sourceLine" id="cb3-35" title="35"><span class="kw">template</span> &lt;<span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb3-36" title="36"><span class="kw">using</span> <span class="dt">odds_t</span> = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb3-37" title="37">                            (<span class="dt">head_t</span>&lt;List&gt;::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb3-38" title="38">                            <span class="dt">head_t</span>&lt;List&gt;, </a>
<a class="sourceLine" id="cb3-39" title="39">                            <span class="dt">tail_t</span>&lt;List&gt;&gt;::type;</a></code></pre></div>
<p>Variadic:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">template</span> &lt;<span class="dt">bool</span> is_odd, <span class="kw">typename</span> Current, <span class="kw">typename</span> InList, <span class="kw">typename</span> OutList&gt;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">struct</span> odds;</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">template</span> &lt;<span class="kw">typename</span> Current, <span class="kw">typename</span> InHead, </a>
<a class="sourceLine" id="cb4-5" title="5">          <span class="kw">typename</span> ... InTail, <span class="kw">typename</span> ... Outs&gt;</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">struct</span> odds&lt;<span class="kw">true</span>, Current, var_tl::tl&lt;InHead, InTail...&gt;, var_tl::tl&lt;Outs...&gt;&gt;</a>
<a class="sourceLine" id="cb4-7" title="7">{</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">using</span> type = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb4-9" title="9">                            (InHead::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb4-10" title="10">                            InHead, </a>
<a class="sourceLine" id="cb4-11" title="11">                            var_tl::tl&lt;InTail...&gt;, </a>
<a class="sourceLine" id="cb4-12" title="12">                            var_tl::tl&lt;Outs..., Current&gt;&gt;::type;</a>
<a class="sourceLine" id="cb4-13" title="13">};</a>
<a class="sourceLine" id="cb4-14" title="14"></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="kw">template</span> &lt;<span class="kw">typename</span> Current, <span class="kw">typename</span> InHead, </a>
<a class="sourceLine" id="cb4-16" title="16">          <span class="kw">typename</span> ... InTail, <span class="kw">typename</span> ... Outs&gt;</a>
<a class="sourceLine" id="cb4-17" title="17"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Current, var_tl::tl&lt;InHead, InTail...&gt;, var_tl::tl&lt;Outs...&gt;&gt;</a>
<a class="sourceLine" id="cb4-18" title="18">{</a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="kw">using</span> type = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb4-20" title="20">                            (InHead::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb4-21" title="21">                            InHead, </a>
<a class="sourceLine" id="cb4-22" title="22">                            var_tl::tl&lt;InTail...&gt;, </a>
<a class="sourceLine" id="cb4-23" title="23">                            var_tl::tl&lt;Outs...&gt;&gt;::type;</a>
<a class="sourceLine" id="cb4-24" title="24">};</a>
<a class="sourceLine" id="cb4-25" title="25"></a>
<a class="sourceLine" id="cb4-26" title="26"><span class="kw">template</span> &lt;<span class="kw">typename</span> Current, <span class="kw">typename</span> ... Outs&gt;</a>
<a class="sourceLine" id="cb4-27" title="27"><span class="kw">struct</span> odds&lt;<span class="kw">true</span>, Current, var_tl::tl&lt;&gt;, var_tl::tl&lt;Outs...&gt;&gt;</a>
<a class="sourceLine" id="cb4-28" title="28">{</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="kw">using</span> type = var_tl::tl&lt;Outs..., Current&gt;;</a>
<a class="sourceLine" id="cb4-30" title="30">};</a>
<a class="sourceLine" id="cb4-31" title="31"></a>
<a class="sourceLine" id="cb4-32" title="32"><span class="kw">template</span> &lt;<span class="kw">typename</span> Current, <span class="kw">typename</span> ... Outs&gt;</a>
<a class="sourceLine" id="cb4-33" title="33"><span class="kw">struct</span> odds&lt;<span class="kw">false</span>, Current, var_tl::tl&lt;&gt;, var_tl::tl&lt;Outs...&gt;&gt;</a>
<a class="sourceLine" id="cb4-34" title="34">{</a>
<a class="sourceLine" id="cb4-35" title="35">    <span class="kw">using</span> type = var_tl::tl&lt;Outs...&gt;;</a>
<a class="sourceLine" id="cb4-36" title="36">};</a>
<a class="sourceLine" id="cb4-37" title="37"></a>
<a class="sourceLine" id="cb4-38" title="38"><span class="kw">template</span> &lt;<span class="kw">typename</span> List&gt;</a>
<a class="sourceLine" id="cb4-39" title="39"><span class="kw">using</span> <span class="dt">odds_t</span> = <span class="kw">typename</span> odds&lt;</a>
<a class="sourceLine" id="cb4-40" title="40">                        (<span class="dt">head_t</span>&lt;List&gt;::value % <span class="dv">2</span>) != <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb4-41" title="41">                        <span class="dt">head_t</span>&lt;List&gt;, </a>
<a class="sourceLine" id="cb4-42" title="42">                        <span class="dt">tail_t</span>&lt;List&gt;, </a>
<a class="sourceLine" id="cb4-43" title="43">                        var_tl::tl&lt;&gt;&gt;::type;</a>
<a class="sourceLine" id="cb4-44" title="44"></a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>What i learned from my previous C++ TMP experience, and these benchmarks;</p>
<ul>
<li>Branching using <em>pattern matching</em> is generally <strong>faster</strong> than <code>if_else_t</code></li>
<li>Modifying <em>nested</em> type lists is generally <strong>faster</strong> than <em>variadic</em> type lists.</li>
<li>Metashell is fine for debugging C++ TMP code, but not for actual measuring</li>
</ul>
<p>I hope these insights are also useful for others!</p>]]></description>
    <pubDate>Sat, 25 Jun 2016 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2016/06/25/cpp_template_type_list_performance</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>
<item>
    <title>Generating Integer Sequences at Compile Time</title>
    <link>https://blog.galowicz.de/2016/06/24/integer_sequences_at_compile_time</link>
    <description><![CDATA[<p>In some situations, it can be useful ot generate sequences of numbers at compile time. This article shows how to generate integer sequences with C++ templates, and gives an example how to use it.</p>
<!--more-->
<h2 id="compile-time-integer-sequences">Compile Time Integer Sequences</h2>
<p>We are going to build integer sequences, which will look like the following:</p>
<p><code>sequence&lt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&gt;</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// This is the type which holds sequences</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">template</span> &lt;<span class="dt">int</span> ... Ns&gt; <span class="kw">struct</span> sequence {};</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">// First define the template signature</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">template</span> &lt;<span class="dt">int</span> ... Ns&gt; <span class="kw">struct</span> seq_gen;</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">// Recursion case</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">template</span> &lt;<span class="dt">int</span> I, <span class="dt">int</span> ... Ns&gt;</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">struct</span> seq_gen&lt;I, Ns...&gt;</a>
<a class="sourceLine" id="cb1-10" title="10">{</a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="co">// Take front most number of sequence,</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="co">// decrement it, and prepend it twice.</span></a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="co">// First I - 1 goes into the counter,</span></a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="co">// Second I - 1 goes into the sequence.</span></a>
<a class="sourceLine" id="cb1-15" title="15">    <span class="kw">using</span> type = <span class="kw">typename</span> seq_gen&lt;</a>
<a class="sourceLine" id="cb1-16" title="16">        I - <span class="dv">1</span>, I - <span class="dv">1</span>, Ns...&gt;::type;</a>
<a class="sourceLine" id="cb1-17" title="17">};</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">// Recursion abort</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="kw">template</span> &lt;<span class="dt">int</span> ... Ns&gt;</a>
<a class="sourceLine" id="cb1-21" title="21"><span class="kw">struct</span> seq_gen&lt;<span class="dv">0</span>, Ns...&gt;</a>
<a class="sourceLine" id="cb1-22" title="22">{</a>
<a class="sourceLine" id="cb1-23" title="23">    <span class="kw">using</span> type = sequence&lt;Ns...&gt;;</a>
<a class="sourceLine" id="cb1-24" title="24">};</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="kw">template</span> &lt;<span class="dt">int</span> N&gt;</a>
<a class="sourceLine" id="cb1-27" title="27"><span class="kw">using</span> <span class="dt">sequence_t</span> = <span class="kw">typename</span> seq_gen&lt;N&gt;::type;</a></code></pre></div>
<p><code>sequence_t</code>’s purpose is solely carrying number sequences. Note that it is an empty class which is actually <em>defined</em> (because it has an empty <code>{}</code> definition body). This is important, because in some use cases it is going to be instantiated.</p>
<p><code>seq_gen</code> is used to recursively generate the integer sequence.</p>
<p><code>sequence_t</code> is the <code>using</code> clause which represents the interface for the end user. Writing <code>sequence_t&lt;10&gt;</code> evaluates to the initial example with the numeric range going from 0 to 9.</p>
<h2 id="usage-example-unpacking-tuples-for-function-calls">Usage Example: Unpacking Tuples for Function Calls</h2>
<p>Imagine a function which takes a specific set of parameters with specific types:</p>
<p><code>void f(double, float, int)</code></p>
<p>…and an <code>std::tuple</code> (<a href="http://www.cplusplus.com/reference/tuple/">Link to C++ Documentation about the tuple class</a>), which carries exactly the same types:</p>
<p><code>std::tuple&lt;double, float, int&gt; tup</code>.</p>
<p>In order to call <code>f</code> with the values in <code>tup</code>, one can write the following code:</p>
<p><code>f(std::get&lt;0&gt;(tup), std::get&lt;1&gt;(tup), std::get&lt;2&gt;(tup))</code></p>
<p>This is not too nice to read, and it is error prone, because it’s possible to use wrong indices. Such mistakes would even compile, if the type at the wrong index is the same, as the type at the right index.</p>
<p>It would be nicer to have a function wrapper which has semantics like “<em>Use this function and this tuple. Then automatically take all the tuple values out of the tuple, in order call the function with them.</em>”:</p>
<p><code>unpack_and_call(f, tup);</code></p>
<p>This is indeed possible since C++11. Let’s have a look how to implement that:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">using</span> <span class="bu">std::</span>tuple;</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="at">static</span> <span class="dt">void</span> func(<span class="dt">double</span> d, <span class="dt">float</span> f, <span class="dt">int</span> i)</a>
<a class="sourceLine" id="cb2-7" title="7">{</a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="bu">std::</span>cout &lt;&lt; d &lt;&lt; <span class="st">&quot;, &quot;</span> </a>
<a class="sourceLine" id="cb2-9" title="9">              &lt;&lt; f &lt;&lt; <span class="st">&quot;, &quot;</span> </a>
<a class="sourceLine" id="cb2-10" title="10">              &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;    </a>
<a class="sourceLine" id="cb2-11" title="11">}</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">// The following code passes all parameters by </span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">// value, for the sake of simplicity </span></a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="kw">template</span> &lt;<span class="kw">typename</span> F, <span class="kw">typename</span> TUP, </a>
<a class="sourceLine" id="cb2-17" title="17">          <span class="dt">int</span> ... INDICES&gt;</a>
<a class="sourceLine" id="cb2-18" title="18"><span class="at">static</span> <span class="dt">void</span> <span class="va">tuple_call_</span>(F f, TUP tup, </a>
<a class="sourceLine" id="cb2-19" title="19">                       sequence&lt;INDICES...&gt;)</a>
<a class="sourceLine" id="cb2-20" title="20">{</a>
<a class="sourceLine" id="cb2-21" title="21">    f(<span class="bu">std::</span>get&lt;INDICES&gt;(tup) ...);   </a>
<a class="sourceLine" id="cb2-22" title="22">}</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24"><span class="kw">template</span> &lt;<span class="kw">typename</span> F, <span class="kw">typename</span> ... Ts&gt;</a>
<a class="sourceLine" id="cb2-25" title="25"><span class="at">static</span> <span class="dt">void</span> tuple_call(F f, tuple&lt;Ts...&gt; tup)</a>
<a class="sourceLine" id="cb2-26" title="26">{</a>
<a class="sourceLine" id="cb2-27" title="27">    <span class="va">tuple_call_</span>(f, tup, </a>
<a class="sourceLine" id="cb2-28" title="28">                <span class="dt">sequence_t</span>&lt;<span class="kw">sizeof</span>...(Ts)&gt;{});</a>
<a class="sourceLine" id="cb2-29" title="29">}</a>
<a class="sourceLine" id="cb2-30" title="30"></a>
<a class="sourceLine" id="cb2-31" title="31"><span class="dt">int</span> main()</a>
<a class="sourceLine" id="cb2-32" title="32">{</a>
<a class="sourceLine" id="cb2-33" title="33">    func(<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="dv">3</span>); </a>
<a class="sourceLine" id="cb2-34" title="34"></a>
<a class="sourceLine" id="cb2-35" title="35">    tuple&lt;<span class="dt">double</span>, <span class="dt">float</span>, <span class="dt">int</span>&gt; tup {<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="dv">3</span>};</a>
<a class="sourceLine" id="cb2-36" title="36">    tuple_call(func, tup); <span class="co">// same effect</span></a>
<a class="sourceLine" id="cb2-37" title="37">}</a></code></pre></div>
<p><code>func</code> is the example function with its own specific signature. It has no knowledge about tuples at all. It could even be a legacy C function.</p>
<p><code>tuple_call</code> is the helper function which automatically unwraps all values from a tuple in order to feed them directly into the function <code>func</code>. It works in two steps:</p>
<ol type="1">
<li>Using <em>pattern matching</em>, the type list of the tuple is extracted into the template parameter pack <code>Ts</code>.</li>
<li>Using <code>sizeof...(tup)</code>, the number of parameters is determined, and an integer sequence type is created from this.</li>
<li>The helper function <code>tuple_call_</code> accepts this sequence type as a parameter, which carries a sequence of rising integer values. These are used as indices to the tuple values. Note that the instantiated sequence object is not actually used - it’s only its type we are interested in.</li>
<li>The most important part comes here: <code>std::get&lt;INDICES&gt;(tup) ...</code> applies exactly the per-parameter tuple unpacking we formerly had to do by hand. <code>Do_something(TMPL PARAM PACK) ...</code> expresses “<em>Apply Do_something to each of the items of the parameter pack</em>”. That’s the magic.</li>
</ol>]]></description>
    <pubDate>Fri, 24 Jun 2016 00:00:00 UT</pubDate>
    <guid>https://blog.galowicz.de/2016/06/24/integer_sequences_at_compile_time</guid>
    <dc:creator>Jacek Galowicz</dc:creator>
</item>

    </channel>
</rss>
