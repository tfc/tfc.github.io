<!doctype html>
<html lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile">
<link type="application/atom+xml" rel="alternate" href="https://blog.galowicz.de//feed.xml" title="Jacek's Blog" />
<link rel="canonical" href="https://blog.galowicz.de/" />
<link rel="stylesheet" href="../../../../css/poole.css">
<link rel="stylesheet" href="../../../../css/syntax.css">
<link rel="stylesheet" href="../../../../css/hyde.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../images/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="../../../../images/favicon.ico">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>Jacek's Blog &middot; Filtering Unique Items from Heterogeneous Lists at Compile Time</title>
<body class="layout-reverse"><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1><a href="../../../../">Jαcεκ's <del>C++</del> Bλog</a>
</h1>
<p class="lead">Day-to-day experiences and thoughts about software engineering</p>
</div>
<nav class="sidebar-nav"><a class="sidebar-nav-item active" href="../../../../">Home</a>
<a class="sidebar-nav-item" href="../../../../about.html">About</a>
<a class="sidebar-nav-item" href="https://galowicz.de">CV Info</a>
<a class="sidebar-nav-item" href="../../../../impressum.html">Impressum/Datenschutz</a>
</nav>
<p><a href="https://linkedin.com/in/jgalowicz"><i class="fa fa-linkedin-square"></i>
</a>
<a href="https://www.xing.com/profile/Jacek_Galowicz"><i class="fa fa-xing-square"></i>
</a>
<a href="https://github.com/tfc"><i class="fa fa-github-square"></i>
</a>
<a href="https://twitter.com/jgalowicz"><i class="fa fa-twitter-square"></i>
</a>
</p>
</div>
</div>
<div class="content container"><h1>Filtering Unique Items from Heterogeneous Lists at Compile Time</h1>
<div class="post"><span class="post-date">March 20, 2022</span>
<span class="post-tags">
Tags: <a title="All pages tagged 'haskell'." href="../../../../tags/haskell.html" class="tag-link">haskell</a> <a title="All pages tagged 'meta-programming'." href="../../../../tags/meta-programming.html" class="tag-link">meta-programming</a>
</span>
<p>This article is about how to filter unique items from heterogeneous lists on
the type level in Haskell.
This example, without further context, might look a bit esoteric by itself,
but I learned a lot writing it and wanted to share the experience.</p>
<!--more-->
<p>In the last years I’ve been programming more in Haskell than in C++.
I find Haskell is super fascinating because of its mighty type system.
C++ already makes it possible to lift a lot of computation from compile time to run time (using <code>constexpr</code> and template meta programming) with the positive effect of resulting in less code in your binaries.
Less code in your binaries is great, because this means a <a href="https://en.wikipedia.org/wiki/Shift-left_testing">“shift left”</a> of bug potential on the time axis from run time to compile time.
Now Haskell makes this much more interesting because its type system is much more intelligent than the one of C++ or comparable languages.
There are many libraries that show off what’s possible.
My current favorite example because I have been using it a lot is the <a href="https://docs.servant.dev"><code>servant</code></a> library.</p>
<p>I found learning C++ template meta programming very hard in the beginning because it’s completely different than <em>normal</em> programming. But once you get there, it’s really enlightening and helps in cleaner thinking about and designing of what your programs are actually supposed to do.
Trying to do the same things and even more in Haskell, I found the following books and blog articles extremely helpful:</p>
<ul>
<li>Book: <a href="https://leanpub.com/thinking-with-types"><strong>“Thinking with Types”</strong> by Sandy Maguire</a></li>
<li>Book: <a href="https://www.packtpub.com/product/haskell-design-patterns/9781783988723"><strong>“Haskell Design Patterns”</strong> by Ryan Lemmer</a></li>
<li>Blog: <a href="https://hengchu.github.io/posts/2018-05-09-type-lists-and-type-classes.lhs.html"><strong>“Taming Heterogeneous Lists in Haskell”</strong> by Hengchu Zhang</a></li>
</ul>
<p>However, after getting some inspiration what fascinating things some libraries do at the type level, I wanted to give it a try myself and came up with some private hobby challenge that I wanted to try myself.
While trying to hack on the type level, I found the available books and blogs super helpful.
But as so often the case, books/articles often tend to explain the simple things simple, then switch to much more complicated examples, but there is quite some gap between the simple and the (maybe too) advanced examples.
I got lost there unfortunately and came up with a solution to a sub-problem of my hobby challenge that I wanted to share to fill up that gap.</p>
<p>This blog article shows how to:</p>
<ul>
<li>Define a heterogeneous list and print it (looks exactly as known from books/articles)</li>
<li>How to reverse such lists</li>
<li>How to filter out unique type items from them
<ul>
<li>both at type-level and run time because we need both</li>
</ul></li>
</ul>
<p>Let’s start with some includes and GHC extensions that we need.
The full code of this article is <a href="https://gist.github.com/tfc/a525ef630abe215d1ec1d3c50609a340">here</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes    #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds              #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts       #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances      #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs                  #-}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds              #-}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes             #-}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables    #-}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications       #-}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies           #-}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators          #-}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances   #-}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Kind</span>    (<span class="dt">Type</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">GHC.TypeLits</span> (<span class="dt">ErrorMessage</span> (<span class="dt">Text</span>), <span class="dt">TypeError</span>)</span></code></pre></div>
<h2 id="heterogeneous-lists">Heterogeneous Lists</h2>
<p>First, we need a way to create a way to describe lists of items that have different types (without polymorphy).</p>
<p>So let’s create the type <code>HList</code> (as in “<strong>H</strong>eterogeneous <strong>List</strong>”) whose GADT constructors help us constructing a list at compile time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="dt">Type</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HNil</span><span class="ot"> ::</span> <span class="dt">HList</span> '[]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:#) ::</span> x <span class="ot">-&gt;</span> <span class="dt">HList</span> xs <span class="ot">-&gt;</span> <span class="dt">HList</span> (x '<span class="op">:</span> xs)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:#</span></span></code></pre></div>
<p>Creating such a hlist now looks like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">A</span> <span class="ot">=</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">B</span> <span class="ot">=</span> <span class="dt">B</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C</span> <span class="ot">=</span> <span class="dt">C</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>abc <span class="ot">=</span> <span class="dt">A</span> <span class="dv">1</span> <span class="op">:#</span> <span class="dt">B</span> <span class="dv">2</span> <span class="op">:#</span> <span class="dt">C</span> <span class="dv">3</span> <span class="op">:#</span> <span class="dt">HNil</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">:</span><span class="kw">type</span> abc</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">abc :: HList ’[A, B, C]</span></p>
<p>Although other tutorials and books cover this topic already, let us also create at least the <code>Show</code> instance for our <code>HList</code> in order to be able to print not only their types but also their values:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">HList</span> '[]) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">HNil</span> <span class="ot">=</span> <span class="st">&quot;HNil&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Show</span> x, <span class="dt">Show</span> (<span class="dt">HList</span> xs))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">HList</span> (x '<span class="op">:</span> xs)) <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (x <span class="op">:#</span> xs) <span class="ot">=</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; :# &quot;</span> <span class="op">++</span> <span class="fu">show</span> xs</span></code></pre></div>
<p>The implementation is much simpler than the following stuff, because the return type of <code>show</code> is just <code>String</code> and that is easy to assemble from our list construction.</p>
<p>Let’s try it out:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>abc</span></code></pre></div>
<pre><code>A 1 :# B 2 :# C 3 :# HNil</code></pre>
<p>Fine. Off to the more complicated things now.</p>
<h2 id="reversing-hlists">Reversing HLists</h2>
<p>All the examples on the internet first show how to write functions on hlists: First, implement a type class and then all the relevant instances for them. These are usually not too hard to understand and write, because the output type does not really depend on the inputs - just like our <code>Show</code> instance from before.</p>
<p>Having understood that, the next thing that I found hard to achieve was <em>reversing</em> a heterogeneous list.
The reason is, that the return type of a reverse function would completely depend on the input:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">aReverserFunction ::</span> <span class="dt">Hlist</span> '[ <span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">C</span> ] <span class="ot">-&gt;</span> <span class="dt">HList</span> '[ <span class="dt">C</span>, <span class="dt">B</span>, <span class="dt">A</span> ]</span></code></pre></div>
<p>But how to express that programmatically? Implementing the type class would be easy, but I would need to programmatically calculate the output type from the input type.
Without knowing the resulting return type in advance, the type class would be of no use.
Afterward, we can implement the type class that uses this calculated type.</p>
<p>A function on the <em>type level</em> that creates a new type from some input type can be implemented in terms of a <em>type family</em>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Reverse'</span> (<span class="ot">inputList ::</span> [<span class="dt">Type</span>])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                     (<span class="ot">accumulator ::</span> [<span class="dt">Type</span>])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">                     ::</span> [<span class="dt">Type</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">where</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Reverse'</span> '[] accumulator <span class="ot">=</span> accumulator</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Reverse'</span> (i '<span class="op">:</span> is) accumulator <span class="ot">=</span> <span class="dt">Reverse'</span> is (i '<span class="op">:</span> accumulator)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reverse</span> a <span class="ot">=</span> <span class="dt">Reverse'</span> a '[]</span></code></pre></div>
<p>This function takes an input type list and accumulates the reverse of the list, item by item, on the accumulator argument.
As soon as the input list contains no items any longer, the accumulator is returned.</p>
<p>As it would be otherwise uncomfortable to provide the input list <em>and</em> the accumulator, let’s call this type-level function <code>Reverse'</code> and define a type alias <code>Reverse</code> which just accepts the input list and hides the rest of the interface for us.</p>
<p>This works as expected:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">Reverse</span> '[ <span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">C</span> ]</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">Reverse ‘[ A, B, C ] :: [*]
=’[C, B, A]</span></p>
<p>The type class <code>ReversedHList</code> will provide us a <code>rev'</code> function with just the same interface but at normal function level.
In order to hide this input-and-accumulator interface, we will later define function <code>rev</code> which hides this implementation detail from the user.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ReversedHList</span> (<span class="ot">inputList ::</span> [<span class="dt">Type</span>])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                    (<span class="ot">accumulator ::</span> [<span class="dt">Type</span>])</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                    (<span class="ot">reversedList ::</span> [<span class="dt">Type</span>])</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">where</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  rev' ::</span> <span class="dt">HList</span> inputList</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">HList</span> accumulator</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">HList</span> reversedList</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ReversedHList</span> '[] a a <span class="kw">where</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  rev' _ a <span class="ot">=</span> a</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ReversedHList</span> is (i '<span class="op">:</span> as) rs</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">ReversedHList</span> (i '<span class="op">:</span> is) as rs <span class="kw">where</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    rev' (i <span class="op">:#</span> is) as <span class="ot">=</span> rev' is (i <span class="op">:#</span> as)</span></code></pre></div>
<p>What’s most interesting here is that <code>reversedList</code> is a type that remains completely unchanged over the instances that are called one after the other.
This is the final return type that needs to be calculated before, and we have not done that, yet.</p>
<p>Our <code>rev</code> function does both hide the accumulator from the user and calculate the result type using our previously implemented <code>Reverse</code> type-level function:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rev ::</span> <span class="kw">forall</span> inputList<span class="op">.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>       <span class="dt">ReversedHList</span> inputList '[] (<span class="dt">Reverse</span> inputList)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">HList</span> inputList</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">HList</span> (<span class="dt">Reverse</span> inputList)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>rev i <span class="ot">=</span> rev' <span class="op">@</span>inputList <span class="op">@</span>'[] <span class="op">@</span>(<span class="dt">Reverse</span> inputList) i <span class="dt">HNil</span></span></code></pre></div>
<p>The strange <code>@inputList</code> notation is called <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/type_applications.html"><em>type application</em></a> and makes it easier to see which instance of function <code>rev'</code> we are calling.
Often enough such hints are not needed (in this specific case the code will compile without), but they also make it easier to read the code due to its explicitness.</p>
<p>That the output type is <code>HList (Reverse inputList)</code> is the simpler part of this function.
But that I have to write down the <code>ReversedHList inputList '[] (Reverse inputList)</code> class constraint is something that I didn’t get for a long time.
If you leave that away, the compiler will give you the following feedback:</p>
<pre><code>&lt;interactive&gt;:3:9: error:
    • No instance for (Rev inputList '[] (Reverse' inputList '[])) arising from a use of ‘rev'’
    • In the expression: rev' @inputList @'[] @(Reverse inputList) i HNil
      In an equation for ‘rev’: rev i = rev' @inputList @'[] @(Reverse inputList) i HNil</code></pre>
<p>I understand this as “Just because you’re using <code>rev'</code> does not mean that I can automatically require the user’s input types to be instances of this class. Please write down this requirement explicitly.”
Thinking about it a bit longer, it does help reading the rest of the code because it explains which type instance it will select first.</p>
<p>After all, the function works just as expected:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span><span class="kw">type</span> rev abc</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>rev abc</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">rev abc :: HList ’[C, B, A]</span></p>
<pre><code>C 3 :# B 2 :# A 1 :# HNil</code></pre>
<p>Thanks to the <code>Show</code> instance we can nicely inspect our reversed list both at the type- and value-level.</p>
<p>Now, let’s look at the next challenge.</p>
<h2 id="type-level-helper-functions">Type-Level Helper Functions</h2>
<p>In the end we are going to remove duplicate types from heterogeneous lists, but before we arrive there we need to implement some helper functions.</p>
<p>The first helper type-level function tells us if a list already contains some type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Contains</span> (<span class="ot">inputList ::</span> [<span class="dt">Type</span>]) (<span class="ot">inputType ::</span> <span class="dt">Type</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- head of the list equals the input type</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Contains</span> (x '<span class="op">:</span> _) x <span class="ot">=</span> <span class="dt">'True</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- recursion terminator: list didn't contain it</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Contains</span> '[] _ <span class="ot">=</span> <span class="dt">'False</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- current head does not equal the input type, so recurse to the next one</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Contains</span> (_ '<span class="op">:</span> xs) x <span class="ot">=</span> <span class="dt">Contains</span> xs x</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">Contains</span> '[<span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">C</span>] <span class="dt">A</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">Contains</span> '[<span class="dt">B</span>, <span class="dt">C</span>] <span class="dt">A</span></span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">Contains ’[A, B, C] A :: Bool
= ’True</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">Contains ’[B, C] A :: Bool
= ’False</span></p>
<p>This works great.</p>
<p>The next helper that we are going to need later is a type-level if function.
It accepts a bool value on the type-level, and two types of which one is returned back, depending on the boolean condition input:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">If</span> (<span class="ot">condition ::</span> <span class="dt">Bool</span>) (<span class="ot">thenCase ::</span> k) (<span class="ot">elseCase ::</span> k)<span class="ot"> ::</span> k <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">'True</span>  a _ <span class="ot">=</span> a</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">'False</span> _ b <span class="ot">=</span> b</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">If</span> <span class="dt">'True</span>  <span class="dt">A</span> <span class="dt">B</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">If</span> <span class="dt">'False</span> <span class="dt">A</span> <span class="dt">B</span></span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">If ’True A B :: *
= A</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">If ’False A B :: *
= B</span></p>
<h2 id="filtering-only-unique-items-from-a-list">Filtering Only Unique Items from a List</h2>
<p>The type-level function that immediately puts to use our new <code>Contains</code> and <code>If</code> function shall recursively traverse through an input list and return an output list that only contains the unique types of the input list:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Uniques</span> (<span class="ot">xs ::</span> [<span class="dt">Type</span>])<span class="ot"> ::</span> [<span class="dt">Type</span>] <span class="kw">where</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Uniques</span> (x '<span class="op">:</span> xs) <span class="ot">=</span> <span class="dt">If</span> (<span class="dt">Contains</span> xs x) (<span class="dt">Uniques</span> xs) (x '<span class="op">:</span> <span class="dt">Uniques</span> xs)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Uniques</span> '[] <span class="ot">=</span> '[]</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">Uniques</span> '[<span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">A</span>, <span class="dt">C</span>]</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">Uniques ‘[A, B, A, C] :: [*]
=’[B, A, C]</span></p>
<p>A helper that is going to be handy in the following is the type-level function <code>ContainsHead</code>:
It accepts two type lists as arguments and tests if the first list contains the head element of the second list.</p>
<p>We are later feeding this function into a type class parameter that then helps us selecting the right type class.
In the special case that the second list is <em>empty</em>, we return a comprehensible error message.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ContainsHead</span> (<span class="ot">listToCheckAgainst ::</span> [<span class="dt">Type</span>])</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                         (<span class="ot">listToCheck ::</span> [<span class="dt">Type</span>])</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">                         ::</span> <span class="dt">Bool</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ContainsHead</span> as (b '<span class="op">:</span> bs) <span class="ot">=</span> <span class="dt">Contains</span> as b</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ContainsHead</span> _ '[] <span class="ot">=</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">TypeError</span> (<span class="dt">'Text</span> <span class="st">&quot;ContainsHead can't take off the head of an empty list&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">ContainsHead</span> '[ <span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">C</span> ] '[ <span class="dt">B</span>, <span class="dt">C</span> ]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">ContainsHead</span> '[ <span class="dt">A</span> ] '[ <span class="dt">B</span>, <span class="dt">C</span> ]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>kind<span class="op">!</span> <span class="dt">ContainsHead</span> '[ <span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">C</span> ] '[ ]</span></code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">ContainsHead ‘[ A, B, C ]’[ B, C ] :: Bool
= ’True</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">ContainsHead ‘[ A ]’[ B, C ] :: Bool
= ’False</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning {
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error {
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">ContainsHead ‘[ A, B, C ]’[ ] :: Bool
= (TypeError …)</span></p>
<p>Now we get to the part that turned out to look really complicated:
The class <code>UniqueHList</code> provides us a function <code>ul'</code> that has a similar accumulator based interface like the reverse function.
A given input list is consumed step by step, and if the current item is already in the accumulator list, we drop it.
Otherwise, we put it into the accumulator.
After fully consuming the input list, we can return the accumulator.
The type <code>uniqueList</code> can be forecasted using our <code>Uniques</code> type-level function. It doesn’t change throughout all the instances ass they call each other and pass it from the first call to the last.</p>
<p>The most interesting addition to this interface is the <code>nextElementIsContainedAlready</code> boolean argument.
As the name suggests, one instance fills it out for the next instance so they can decide what to do with the current input list head item, as we will see in the following.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">UniqueHList</span> (<span class="ot">inList ::</span> [<span class="dt">Type</span>])</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                  (<span class="ot">accumulator ::</span> [<span class="dt">Type</span>])</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                  (<span class="ot">uniqueList ::</span> [<span class="dt">Type</span>])</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                  (<span class="ot">nextElementIsContainedAlready ::</span> <span class="dt">Bool</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">where</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  ulr' ::</span> <span class="dt">HList</span> inList</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">HList</span> accumulator</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">HList</span> uniqueList</span></code></pre></div>
<p>The recursion terminal instance is the one where the input list is empty.
In this case we simply return the accumulator.
It is not interesting what the value of the bool argument is in this special case.</p>
<p>I named the class function <code>ulr'</code> as in “<strong>u</strong>nique <strong>l</strong>ist <strong>reversed</strong>”, because due to the accumulator interface of this function, the accumulator will contain all the items in reversed order when we consumed the input list.
We will turn it around later.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">UniqueHList</span> '[] uniqueList uniqueList dontCare <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  ulr' _ x <span class="ot">=</span> x</span></code></pre></div>
<p>In all of the following instances, I used some very much abbreviated type variable names:
<code>is</code> stands for <strong>i</strong>nput item<strong>s</strong>”, <code>as</code> for “<strong>a</strong>ccumulator item<strong>s</strong>”, and <code>us</code> for “<strong>u</strong>nique item<strong>s</strong>”.</p>
<p>The <code>'False</code> value in the <code>nextElementIsContainedAlready</code> argument says that this instance is for the cases where the next input list item is not yet contained by the accumulator.
So by removing it from the input list and prepending it to the accumulator, we do the right thing.</p>
<p>The many type application <code>@</code> things here are a bit noisy, but this time the compiler needs them as a hint.
They basically replicate the class constraint that described what the next instance is.</p>
<p><code>(ContainsHead (i ': as) is)</code> is the next bool value that is put into the next class instance:
The new state of our accumulator will be <code>i ': as</code> in that next instance, so we need to check if the head of the rest of the input list is already contained in that new accumulator.
That is practically the essence of the complicated-looking <code>UniqueHList</code> instance unfolding logic.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">UniqueHList</span> is (i '<span class="op">:</span> as) us (<span class="dt">ContainsHead</span> (i '<span class="op">:</span> as) is)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">UniqueHList</span> (i '<span class="op">:</span> is) as us <span class="dt">'False</span> <span class="kw">where</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    ulr' (i <span class="op">:#</span> is) as <span class="ot">=</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        ulr' <span class="op">@</span>is <span class="op">@</span>(i '<span class="op">:</span> as) <span class="op">@</span>us <span class="op">@</span>(<span class="dt">ContainsHead</span> (i '<span class="op">:</span> as) is) is (i <span class="op">:#</span> as)</span></code></pre></div>
<p>In the cases where the next item from the input list is already contained by the accumulator, we need to drop it and then call the next instance.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">UniqueHList</span> is as us (<span class="dt">ContainsHead</span> as is)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">UniqueHList</span> (i '<span class="op">:</span> is) as us <span class="dt">'True</span> <span class="kw">where</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    ulr' (_ <span class="op">:#</span> is) as <span class="ot">=</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        ulr' <span class="op">@</span>is <span class="op">@</span>as <span class="op">@</span>us <span class="op">@</span>(<span class="dt">ContainsHead</span> as is) is as</span></code></pre></div>
<p>We can already call it for a quick test:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>ulr' <span class="op">@</span>'[<span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">A</span>, <span class="dt">C</span>] <span class="op">@</span>'[] <span class="op">@</span>(<span class="dt">Uniques</span> (<span class="dt">Reverse</span> '[<span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">A</span>, <span class="dt">C</span>])) <span class="op">@</span><span class="dt">'False</span> (<span class="dt">A</span> <span class="dv">1</span> <span class="op">:#</span> <span class="dt">B</span> <span class="dv">2</span> <span class="op">:#</span> <span class="dt">A</span> <span class="dv">3</span> <span class="op">:#</span> <span class="dt">C</span> <span class="dv">4</span> <span class="op">:#</span> <span class="dt">HNil</span>) <span class="dt">HNil</span></span></code></pre></div>
<pre><code>C 4 :# B 2 :# A 1 :# HNil</code></pre>
<p>It works, but what struck me was the fact that the output is the unique list of the reverse input list.
I am pretty sure that if I was smarter, I could construct the whole thing to work more intuitively.
After playing around with the implementation trying to make it nicer without nice results, I concluded that this may be a quest for another day.
I was already happy that it works at all, so let’s continue describing the working state.</p>
<p>Building on the working example input, the function <code>ulr</code> hides all the type hints from the user and calls our class function with the right arguments:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ulr ::</span> <span class="kw">forall</span> inputList<span class="op">.</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>       <span class="dt">UniqueHList</span> inputList '[] (<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList)) <span class="dt">'False</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">=&gt;</span> <span class="dt">HList</span> inputList</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="dt">HList</span> (<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList))</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>ulr x <span class="ot">=</span> ulr' <span class="op">@</span>inputList <span class="op">@</span>'[] <span class="op">@</span>(<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList)) <span class="op">@</span><span class="dt">'False</span> x <span class="dt">HNil</span></span></code></pre></div>
<p>As the user would not expect a reversed output list, let’s concatenate our <code>rev</code> function with the new <code>ulr</code> function to provide the expected results.</p>
<p>The implementation is really simple but writing down the types turned out a bit ugly.
It is surely somehow possible to tell the compiler that <code>Reverse (Uniques (Reverse x))</code> is really the same as <code>Uniques x</code>, but at this time I don’t know how to do it.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ul ::</span> <span class="kw">forall</span> inputList<span class="op">.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">ReversedHList</span> (<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList))</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>                    '[]</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>                    (<span class="dt">Reverse</span> (<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList)))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">UniqueHList</span> inputList '[] (<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList)) <span class="dt">'False</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">HList</span> inputList</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">HList</span> (<span class="dt">Reverse</span> (<span class="dt">Uniques</span> (<span class="dt">Reverse</span> inputList)))</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>ul <span class="ot">=</span> rev <span class="op">.</span> ulr</span></code></pre></div>
<h2 id="the-moment-of-truth">The Moment of Truth</h2>
<p>That should be it. The moment of truth - does it work?</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>abc</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>ul abc</span></code></pre></div>
<pre><code>A 1 :# B 2 :# C 3 :# HNil
A 1 :# B 2 :# C 3 :# HNil</code></pre>
<p>It doesn’t destroy a list that is already unique. Actually, it doesn’t do anything on a unique list and that’s good.</p>
<p>Let’s roll out a more complicated case:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>ababca <span class="ot">=</span> <span class="dt">A</span> <span class="dv">1</span> <span class="op">:#</span> <span class="dt">B</span> <span class="dv">2</span> <span class="op">:#</span> <span class="dt">A</span> <span class="dv">3</span> <span class="op">:#</span> <span class="dt">B</span> <span class="dv">4</span> <span class="op">:#</span> <span class="dt">C</span> <span class="dv">5</span> <span class="op">:#</span> <span class="dt">A</span> <span class="dv">6</span> <span class="op">:#</span> <span class="dt">HNil</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>ababca</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>ul ababca</span></code></pre></div>
<pre><code>A 1 :# B 2 :# A 3 :# B 4 :# C 5 :# A 6 :# HNil
A 1 :# B 2 :# C 5 :# HNil</code></pre>
<p>Happiness.</p>
<h2 id="summary">Summary</h2>
<p>This is now a big bunch of special purpose code that reinvents multiple wheels, but it really helped my personal understanding, and I hope it also helps yours.
The next step would be to use libraries which do all of this better, so we don’t need so much code.
There is for example <a href="https://hackage.haskell.org/package/HList"><code>HList</code></a> which is really elegant and is so much more comprehensible once we understand more type-level programming.</p>
<p>I’ve done a type-level programming in C++ before (have a look at the older articles in this blog) and I find it very interesting how similar it really is.
In Haskell, it is more frustrating in the beginning because the kind system is complicated.
As soon as the basic mechanisms are understood, it is nice to see that Haskell’s type system is much more intelligent than C++ templates and there’s much more control over everything.</p></div>
<div id="disqus_thread"></div>
<script>var disqus_developer = 1;
var disqus_config = function () {this.page.url = 'https://blog.galowicz.de/2022/03/20/unique-heterogeneous-typelists/';
this.page.identifier = 'nicecpp/2022/03/20/unique-heterogeneous-typelists/';};
(function() {var d = document, s = d.createElement('script');
s.src = '//nicecpp.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);})();</script>
</div>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-WZ3FX4G3XS"></script>
<script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WZ3FX4G3XS');</script>
</body>
</head>
</html>
