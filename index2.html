<!doctype html>
<html lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile">
<link type="application/atom+xml" rel="alternate" href="https://blog.galowicz.de/feed.xml" title="Jacek's Software Engineering Blog" />
<link rel="canonical" href="https://blog.galowicz.de/" />
<link rel="stylesheet" href="./css/poole.css">
<link rel="stylesheet" href="./css/syntax.css">
<link rel="stylesheet" href="./css/hyde.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
<script src="https://kit.fontawesome.com/796c2aa0a7.js" crossorigin="anonymous"></script></script>
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="./images/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="./images/favicon.ico">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>Jacek's Software Engineering Blog &middot; Posts (Page 2)</title>
<body class="layout-reverse"><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1><a href="./">Jαcεκ's Software Engineering Bλog</a>
</h1>
<p class="lead">Day-to-day experiences and thoughts about software engineering</p>
</div>
<nav class="sidebar-nav"><a class="sidebar-nav-item active" href="./">Home</a>
<a class="sidebar-nav-item" href="./about.html">About / CV</a>
<a class="sidebar-nav-item" href="./impressum.html">Impressum / Datenschutz</a>
</nav>
<p><a href="https://linkedin.com/in/jgalowicz"><i class="fa-brands fa-linkedin"></i>
</a>
<a href="https://www.xing.com/profile/Jacek_Galowicz"><i class="fa-brands fa-square-xing"></i>
</a>
<a href="https://github.com/tfc"><i class="fa-brands fa-square-github"></i>
</a>
<a href="https://twitter.com/jgalowicz"><i class="fa-brands fa-square-twitter"></i>
</a>
<a rel="me" href="https://functional.cafe/@jgalowicz"><i class="fa-brands fa-mastodon"></i>
</a>
</p>
</div>
</div>
<div class="content container"><h1>Posts (Page 2)</h1>

<div class="tagcloud">Tags: <a style="font-size: 100%" href="./tags/book.html">book</a> <a style="font-size: 100%" href="./tags/c%2B%2B.html">c++</a> <a style="font-size: 100%" href="./tags/haskell.html">haskell</a> <a style="font-size: 100%" href="./tags/meta-programming.html">meta-programming</a> <a style="font-size: 100%" href="./tags/nix.html">nix</a></div>
<hr />

<div class="posts"><div><h2><a href="./2016/11/05/python_style_printf_for_cpp">Python Style printf for C++ with pprintpp</a>
</h2>
<span class="post-tags">
<strong><small>November  5, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>The C++ STL comes with <em>stream</em> style character output, which is an alternative to the classic <code>printf</code> like format function collection of the C library.
For different reasons, some C++ programmers still stick to <code>printf</code> like formatting.
This article demonstrates the <code>pprintpp</code> <a href="https://github.com/tfc/pprintpp">(open source, and available on Github)</a> library, which tries to make <code>printf</code> use comfortable and safe while avoiding any runtime overhead.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/11/05/python_style_printf_for_cpp" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/09/11/dont_fear_recursion">Do Not Fear Recursion</a>
</h2>
<span class="post-tags">
<strong><small>September 11, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>There are a lot of algorithms which can be implemented using <em>recursive</em> or <em>iterative</em> style.
Actually, <strong>everything</strong> can be implemented in both styles.
For a lot of algorithms, the recursive version is simpler to read, write, and understand.
But nevertheless, programmers know, that recursive functions burden a lot of memory consumption, because there is usually a <code>call</code> instruction per recursive call, which puts another call frame on the stack.
Interestingly, this is not true for some special cases.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/09/11/dont_fear_recursion" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/09/04/algorithms_in_iterators">Wrapping Algorithms into Iterators</a>
</h2>
<span class="post-tags">
<strong><small>September  4, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>Sometimes there is the requirement to generate a range of numbers from some algorithm.
Be it a simple range of increasing numbers, or only odd numbers, or only primes, or whatever.
Some calculations can be optimized by <em>memorizing</em> some values for the calculation of the next number, just as this applies for <strong>fibonacci numbers</strong>.
This article shows how to wrap such calculations into <strong>iterators</strong> in order to have performant, and nicely encapsulated algorithms.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/09/04/algorithms_in_iterators" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/06/25/cpp_template_type_list_performance">Type List Compile Time Performance</a>
</h2>
<span class="post-tags">
<strong><small>June 25, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>Soon, after writing my first meta programs with C++ templates, i realized, that certain programming patterns lead to sky rocketing compile times.
I came up with rules of thumb like “<em>Prefer pattern matching over if_else_t</em>”, and “<em>Prefer nested type lists over variadic type lists</em>”.
But i did not know how much faster which pattern is, i just knew about tendencies.
Finally, i sat down to write some compile time benchmarks, and this blog posts presents the results.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/06/25/cpp_template_type_list_performance" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/06/24/integer_sequences_at_compile_time">Generating Integer Sequences at Compile Time</a>
</h2>
<span class="post-tags">
<strong><small>June 24, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>In some situations, it can be useful ot generate sequences of numbers at compile time.
This article shows how to generate integer sequences with C++ templates, and gives an example how to use it.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/06/24/integer_sequences_at_compile_time" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/06/16/cpp_template_compile_time_brainfuck_interpreter">Executing Brainfuck at Compile Time with C++ Templates</a>
</h2>
<span class="post-tags">
<strong><small>June 16, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>This article completes a series which aims at explaining how to implement a Brainfuck Interpreter as a template meta-program which runs at compile time.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/06/16/cpp_template_compile_time_brainfuck_interpreter" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/05/15/turing_tape_with_type_lists">Implementing a Turing Tape for Use at Compile Time</a>
</h2>
<span class="post-tags">
<strong><small>May 15, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>Turing Machines consist of a tape with memory cells, a tape reader like cassette drives and a program table.
Implementing the tape drive part with an array and a pointer is a trivial thing to do with imperative programming languages.
It becomes more interesting when learning purely functional programming, especially in the context of template meta programming in C++.
As a preparation for the next article, i will show how to implement a turing tape based on type lists, usable at compile time.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/15/turing_tape_with_type_lists" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/05/14/converting_between_c_strings_and_type_lists">Transformations between User Input/Output and Type Lists</a>
</h2>
<span class="post-tags">
<strong><small>May 14, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>Type lists are an important way to represent ordered and unordered sets of types at compile time.
These types can be real structure- or class types bundling runtime algorithms etc., but they can also convey actual data at compile time.
In order to apply certain compile time processing to data, this data needs to be transformed from and to other representations, which can be provided by the programmer and consumed by run time programs.
This article shows how to transform back and forth between strings and character type lists.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/14/converting_between_c_strings_and_type_lists" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/05/08/compile_time_type_lists">Type Lists</a>
</h2>
<span class="post-tags">
<strong><small>May  8, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>Homogenuous data in purely functional programs is typically managed in <em>lists</em>.
Items can be appended or prepended to lists, different lists can be concatenated.
Lists can be filtered, transformed, mapped, reduced, etc.
Having all this nice stuff as a template meta library is quite an enabler for complex compile time meta programs.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/08/compile_time_type_lists" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>

<hr>
<div><h2><a href="./2016/05/05/template_meta_programming_basics">Template Meta Programming Basics</a>
</h2>
<span class="post-tags">
<strong><small>May  5, 2016,</small>
</strong>


<strong><small>Tags: <a title="All pages tagged 'c++'." href="./tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'meta-programming'." href="./tags/meta-programming.html" class="tag-link">meta-programming</a></small>
</strong>
</span>
<!-- cSpell:disable -->
<p>C++ template meta programs are at first really hard to read.
This is because the template mechanism accidentally became turing complete, although it was invented to enable for type-agnostic programming of generic algorithms.
However, now the world knows that the C++ template part of the language <em>is</em> turing complete, people started writing full programs in it, and it enhances the power and flexibility of libraries quite a lot.
This article aims to explain some very basic things one needs to know about the C++ template meta programming language, in order to be able to do things with it, or even understand foreign programs.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/05/template_meta_programming_basics" role="button"><i class="fa-solid fa-circle-arrow-right"></i>
Read more </a>
</p>
</div>
</div>
<div class="pagination"><a class="pagination-item newer" href="./index.html">Newer</a>

<a class="pagination-item older" href="./index3.html">Older</a>
</div>
</div>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-WZ3FX4G3XS"></script>
<script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WZ3FX4G3XS');</script>
</body>
</head>
</html>
