<!doctype html>
<html lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile">
<link type="application/atom+xml" rel="alternate" href="https://blog.galowicz.de//feed.xml" title="Jacek's Blog" />
<link rel="canonical" href="https://blog.galowicz.de/" />
<link rel="stylesheet" href="./css/poole.css">
<link rel="stylesheet" href="./css/syntax.css">
<link rel="stylesheet" href="./css/hyde.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="./images/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="./images/favicon.ico">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>Jacek's Blog &middot; Posts (Page 2)</title>
<body class="layout-reverse"><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1><a href="./">Jαcεκ's <del>C++</del> Bλog</a>
</h1>
<p class="lead">Day-to-day experiences and thoughts about software engineering</p>
</div>
<nav class="sidebar-nav"><a class="sidebar-nav-item active" href="./">Home</a>
<a class="sidebar-nav-item" href="./about.html">About</a>
<a class="sidebar-nav-item" href="https://galowicz.de">CV Info</a>
<a class="sidebar-nav-item" href="./impressum.html">Impressum/Datenschutz</a>
</nav>
<p><a href="https://linkedin.com/in/jgalowicz"><i class="fa fa-linkedin-square"></i>
</a>
<a href="https://www.xing.com/profile/Jacek_Galowicz"><i class="fa fa-xing-square"></i>
</a>
<a href="https://github.com/tfc"><i class="fa fa-github-square"></i>
</a>
<a href="https://twitter.com/jgalowicz"><i class="fa fa-twitter-square"></i>
</a>
</p>
</div>
</div>
<div class="content container"><h1>Posts (Page 2)</h1>
<div class="posts"><div><h4><a href="./2016/09/04/algorithms_in_iterators">Wrapping Algorithms into Iterators</a>
</h4>
<p><strong><small>September  4, 2016</small>
</strong>
</p>

<p>Sometimes there is the requirement to generate a range of numbers from some algorithm.
Be it a simple range of increasing numbers, or only odd numbers, or only primes, or whatever.
Some calculations can be optimized by <em>memorizing</em> some values for the calculation of the next number, just as this applies for <strong>fibonacci numbers</strong>.
This article shows how to wrap such calculations into <strong>iterators</strong> in order to have performant, and nicely encapsulated algorithms.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/09/04/algorithms_in_iterators" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/06/25/cpp_template_type_list_performance">Type List Compile Time Performance</a>
</h4>
<p><strong><small>June 25, 2016</small>
</strong>
</p>

<p>Soon, after writing my first meta programs with C++ templates, i realized, that certain programming patterns lead to sky rocketing compile times.
I came up with rules of thumb like “<em>Prefer pattern matching over if_else_t</em>”, and “<em>Prefer nested type lists over variadic type lists</em>”.
But i did not know how much faster which pattern is, i just knew about tendencies.
Finally, i sat down to write some compile time benchmarks, and this blog posts presents the results.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/06/25/cpp_template_type_list_performance" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/06/24/integer_sequences_at_compile_time">Generating Integer Sequences at Compile Time</a>
</h4>
<p><strong><small>June 24, 2016</small>
</strong>
</p>

<p>In some situations, it can be useful ot generate sequences of numbers at compile time.
This article shows how to generate integer sequences with C++ templates, and gives an example how to use it.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/06/24/integer_sequences_at_compile_time" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/06/16/cpp_template_compile_time_brainfuck_interpreter">Executing Brainfuck at Compile Time with C++ Templates</a>
</h4>
<p><strong><small>June 16, 2016</small>
</strong>
</p>

<p>This article completes a series which aims at explaining how to implement a Brainfuck Interpreter as a template meta-program which runs at compile time.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/06/16/cpp_template_compile_time_brainfuck_interpreter" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/05/15/turing_tape_with_type_lists">Implementing a Turing Tape for Use at Compile Time</a>
</h4>
<p><strong><small>May 15, 2016</small>
</strong>
</p>

<p>Turing Machines consist of a tape with memory cells, a tape reader like cassette drives and a program table.
Implementing the tape drive part with an array and a pointer is a trivial thing to do with imperative programming languages.
It becomes more interesting when learning purely functional programming, especially in the context of template meta programming in C++.
As a preparation for the next article, i will show how to implement a turing tape based on type lists, usable at compile time.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/15/turing_tape_with_type_lists" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/05/14/converting_between_c_strings_and_type_lists">Transformations between User Input/Output and Type Lists</a>
</h4>
<p><strong><small>May 14, 2016</small>
</strong>
</p>

<p>Type lists are an important way to represent ordered and unordered sets of types at compile time.
These types can be real structure- or class types bundling runtime algorithms etc., but they can also convey actual data at compile time.
In order to apply certain compile time processing to data, this data needs to be transformed from and to other representations, which can be provided by the programmer and consumed by run time programs.
This article shows how to transform back and forth between strings and character type lists.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/14/converting_between_c_strings_and_type_lists" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/05/08/compile_time_type_lists">Type Lists</a>
</h4>
<p><strong><small>May  8, 2016</small>
</strong>
</p>

<p>Homogenuous data in purely functional programs is typically managed in <em>lists</em>.
Items can be appended or prepended to lists, different lists can be concatenated.
Lists can be filtered, transformed, mapped, reduced, etc.
Having all this nice stuff as a template meta library is quite an enabler for complex compile time meta programs.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/08/compile_time_type_lists" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/05/05/template_meta_programming_basics">Template Meta Programming Basics</a>
</h4>
<p><strong><small>May  5, 2016</small>
</strong>
</p>

<p>C++ template meta programs are at first really hard to read.
This is because the template mechanism accidentally became turing complete, although it was invented to enable for type-agnostic programming of generic algorithms.
However, now the world knows that the C++ template part of the language <em>is</em> turing complete, people started writing full programs in it, and it enhances the power and flexibility of libraries quite a lot.
This article aims to explain some very basic things one needs to know about the C++ template meta programming language, in order to be able to do things with it, or even understand foreign programs.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/05/05/template_meta_programming_basics" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/03/23/const_reference_to_temporary_object">Const References to Temporary Objects</a>
</h4>
<p><strong><small>March 23, 2016</small>
</strong>
</p>

<p>In both C and C++, it is not a sane idea to hold a reference (or a pointer in C) to a temporarily created object, as the reference is quickly dangling as soon as the assignment is done.
But actually, C++ provides an interesting feature, where the life time of a temporary object can be extended to the life time of the reference which points to it.</p>

<p><a class="btn btn-sm btn-primary" href="./2016/03/23/const_reference_to_temporary_object" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>

<hr>
<div><h4><a href="./2016/03/18/uncaught_exceptions_in_cpp">Uncaught Exceptions in C++</a>
</h4>
<p><strong><small>March 18, 2016</small>
</strong>
</p>

<p>What does actually happen, if an exception is thrown somewhere in the middle of a C++ program, but there is no try-catch clause which handles it?
The program gets terminated.
That is fine in general, but what happens to all objects which need to be properly destructed?</p>

<p><a class="btn btn-sm btn-primary" href="./2016/03/18/uncaught_exceptions_in_cpp" role="button">Read more 
<i class="fa fa-arrow-circle-right"></i>
</a>
</p>
</div>
</div>
<div class="pagination"><a class="pagination-item newer" href="./index.html">Newer</a>

<a class="pagination-item older" href="./index3.html">Older</a>
</div>
</div>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-28506344-2', 'auto');
ga('send', 'pageview');
gtag('config', 'UA-28506344-2', { 'anonymize_ip': true });</script>
</body>
</head>
</html>
