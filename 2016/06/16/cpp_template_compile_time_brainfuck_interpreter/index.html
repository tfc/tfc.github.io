<!doctype html>
<html lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile">
<link type="application/atom+xml" rel="alternate" href="https://blog.galowicz.de//feed.xml" title="Jacek's C++ Blog" />
<link rel="canonical" href="https://blog.galowicz.de/" />
<link rel="stylesheet" href="../../../../css/poole.css">
<link rel="stylesheet" href="../../../../css/syntax.css">
<link rel="stylesheet" href="../../../../css/hyde.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../images/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="../../../../images/favicon.ico">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>Jacek's C++ Blog &middot; Executing Brainfuck at Compile Time with C++ Templates</title>
<body class="layout-reverse"><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1><a href="../../../../">Jacek's C++ Blog</a>
</h1>
<p class="lead">Writing about daily experiences and thoughts with C++ as my main work language.</p>
</div>
<nav class="sidebar-nav"><a class="sidebar-nav-item active" href="../../../../">Home</a>
<a class="sidebar-nav-item" href="../../../../about.html">About</a>
<a class="sidebar-nav-item" href="https://galowicz.de">CV Info</a>
<a class="sidebar-nav-item" href="https://galowicz.de">Impressum/Datenschutz</a>
</nav>
<p><a href="https://linkedin.com/in/jgalowicz"><i class="fa fa-linkedin-square"></i>
</a>
<a href="https://www.xing.com/profile/Jacek_Galowicz"><i class="fa fa-xing-square"></i>
</a>
<a href="https://github.com/tfc"><i class="fa fa-github-square"></i>
</a>
<a href="https://plus.google.com/+JacekGalowicz"><i class="fa fa-google-plus-square"></i>
</a>
<a href="https://twitter.com/jgalowicz"><i class="fa fa-twitter-square"></i>
</a>
</p>
</div>
</div>
<div class="content container"><h1>Executing Brainfuck at Compile Time with C++ Templates</h1>
<div class="post"><span class="post-date">June 16, 2016</span>
<p>This article completes a series which aims at explaining how to implement a Brainfuck Interpreter as a template meta-program which runs at compile time.</p>
<!--more-->
<blockquote>
<p>The code in this article depends largely on the code in <a href="../../../../2016/05/08/compile_time_type_lists">the article about type lists</a>, <a href="../../../../2016/05/14/converting_between_c_strings_and_type_lists">the article about character type list transformations</a>, and <a href="../../../../2016/05/15/turing_tape_with_type_lists">the article about implementing a Turing tape</a>. There is also <a href="../../../../2016/05/05/template_meta_programming_basics">the article about template meta-programming 101 things</a>.</p>
</blockquote>
<h2 id="first-things-first-what-is-brainfuck">First Things First: What is Brainfuck?</h2>
<p>Brainfuck is a fun programming language and was created in 1993 by Urban MÃ¼ller. <a href="https://en.wikipedia.org/wiki/Brainfuck">Wikipedia Link</a></p>
<p>Brainfuck programs are composed of only 8 operators and assume to operate on a <em>Brainfuck Machine</em>. A Brainfuck machine looks like a Turing machine: It has a cursor which sits on a tape consisting of infinitely many memory cells.</p>
<table style="width:84%;">
<colgroup>
<col width="11%" />
<col width="72%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>+</code></td>
<td>Increment the value of the memory cell at tape cursor position</td>
</tr>
<tr class="even">
<td align="center"><code>-</code></td>
<td>Increment the value of the memory cell at tape cursor position</td>
</tr>
<tr class="odd">
<td align="center"><code>&lt;</code></td>
<td>Move the tape cursor one cell further to the left</td>
</tr>
<tr class="even">
<td align="center"><code>&gt;</code></td>
<td>Move the tape cursor one cell further to the right</td>
</tr>
<tr class="odd">
<td align="center"><code>.</code></td>
<td>Print the value at tape cursor position</td>
</tr>
<tr class="even">
<td align="center"><code>,</code></td>
<td>Read a value, and assign it to the memory cell at tape cursor position</td>
</tr>
<tr class="odd">
<td align="center"><code>[</code></td>
<td>Beginning of a loop. Execute it, if the tape cursor value is not 0. Skip the whole loop, if it is 0.</td>
</tr>
<tr class="even">
<td align="center"><code>]</code></td>
<td>End of a loop. Move program cursor to beginning of the loop.</td>
</tr>
</tbody>
</table>
<p>Any other character in a brainfuck program is ignored (spaces can be used for nicer to read indentation etc.)</p>
<h3 id="examples">Examples:</h3>
<h4 id="simple-print-loop">Simple Print Loop</h4>
<p>The following program reads a value from the user input, then prints and decrements it in a loop:</p>
<p><code>,[.-]</code></p>
<p><em>Output</em>: (Assuming the user enters the character <code>z</code>)</p>
<pre><code>zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)('&amp;%$#&quot;!</code></pre>
<h4 id="hello-world">Hello World</h4>
<p>The following program reads a value from the user, then prints and decrements it in a loop:</p>
<pre><code>++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.+++.</code></pre>
<p><em>Output</em>:</p>
<pre><code>Hello World!</code></pre>
<h2 id="implementation-in-c-template-meta-language">Implementation in C++ Template Meta Language</h2>
<p>Ok, let us implement that. We will start with adapting the <a href="../../../../2016/05/15/turing_tape_with_type_lists">Turing Tape</a> from the previous article in order to represent the state of a Brainfuck Machine.</p>
<h2 id="adapting-the-turing-tape">Adapting the Turing Tape</h2>
<p>The state of a Turing machine is based on the Turing tape it works on. We have implemented such a tape before, but need to add a little adaption:</p>
<p>When the tape is switched left or right, and a new cell is created which we did not read/write before, a new empty one is created. How an <em>empty</em> cell looks like, is not really defined, as it just contains a <code>null_t</code> type. There is no proper rule to which value a <em>formerly untouched</em> brainfuck cell shall be initialized. I decided to initialize such cells to the value <code>0</code>.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> Tape&gt;
<span class="kw">struct</span> null_to_0;

<span class="kw">template</span> &lt;<span class="kw">class</span> LList, <span class="kw">class</span> RList&gt;
<span class="kw">struct</span> null_to_0&lt;tape&lt;LList, <span class="dt">null_t</span>, RList&gt;&gt; {
    <span class="kw">using</span> type = tape&lt;LList, <span class="dt">char_t</span>&lt;<span class="dv">0</span>&gt;, RList&gt;;
};

<span class="kw">template</span> &lt;<span class="kw">class</span> Tape&gt; <span class="kw">struct</span> null_to_0 { <span class="kw">using</span> type = Tape; };

<span class="kw">template</span> &lt;<span class="kw">class</span> Tape&gt; <span class="kw">using</span> <span class="dt">null_to_0_t</span> = 
                               <span class="kw">typename</span> null_to_0&lt;Tape&gt;::type;</code></pre></td></tr></table></div>
<p>Instead of subclassing the Turing tape or similar, we will just use the function <code>null_to_0_t</code>, which transforms empty cell elements to <code>0</code> elements, and leaves others untouched. Whenever the list is altered for moving, this function is applied to it, and then this is set as the new list state.</p>
<h2 id="the-brainfuck-machine-state">The Brainfuck Machine State</h2>
<p>A Turing machine tape is enough to represent the state of the whole brainfuck machine. We define a type <code>machine</code>, which carries a tape state as template parameter, and provides functions to read and alter the state. This way the user does not need to know about any implementation details:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> Tape&gt;
<span class="kw">struct</span> machine {
    <span class="kw">using</span> move_left  = machine&lt;<span class="dt">null_to_0_t</span>&lt;
                                     <span class="dt">tt_move_left_t</span>&lt; Tape&gt;&gt;&gt;;
    <span class="kw">using</span> move_right = machine&lt;<span class="dt">null_to_0_t</span>&lt;
                                     <span class="dt">tt_move_right_t</span>&lt;Tape&gt;&gt;&gt;;

    <span class="kw">using</span> get = <span class="dt">tt_get_t</span>&lt;Tape&gt;;
    <span class="kw">template</span> &lt;<span class="dt">char</span> value&gt;
    <span class="kw">using</span> set = machine&lt;<span class="dt">tt_set_t</span>&lt;Tape, <span class="dt">char_t</span>&lt;value&gt;&gt;&gt;;

    <span class="at">static</span> <span class="at">const</span> <span class="kw">constexpr</span> <span class="dt">char</span> value {get::value};

    <span class="kw">using</span> increment = set&lt;value + <span class="dv">1</span>&gt;;
    <span class="kw">using</span> decrement = set&lt;value - <span class="dv">1</span>&gt;;
};</code></pre></td></tr></table></div>
<p><br></p>
<table style="width:79%;">
<colgroup>
<col width="20%" />
<col width="58%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Function Name</th>
<th>What It Does</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>move_left</code> / <code>move_right</code></td>
<td>Moves the tape one step to the left/right, and returns a new <code>machine</code> type with the altered state. If it reaches the end of the tape while moving, it appends a new cell. This new cell is then initialized to <code>0</code>.</td>
</tr>
<tr class="even">
<td align="center"><code>get</code></td>
<td>Returns the type at cursor position.</td>
</tr>
<tr class="odd">
<td align="center"><code>set&lt;value&gt;</code></td>
<td>Returns a new <code>machine</code> type with altered tape state. The tape is altered in that way, that it contains the new character <code>value</code> at cursor position.</td>
</tr>
<tr class="even">
<td align="center"><code>increment</code> / <code>decrement</code></td>
<td>Increments/decrements the value at cursor position and returns a new <code>machine</code> which contains this change.</td>
</tr>
</tbody>
</table>
<p>The following code only adds a wrapper for every single function we just defined. This is to make the user code shorter:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> Machine&gt;
<span class="kw">using</span> <span class="dt">move_left_t</span> = <span class="kw">typename</span> Machine::move_left;
<span class="kw">template</span> &lt;<span class="kw">typename</span> Machine&gt;
<span class="kw">using</span> <span class="dt">move_right_t</span> = <span class="kw">typename</span> Machine::move_right;

<span class="kw">template</span> &lt;<span class="kw">typename</span> Machine&gt;
<span class="kw">using</span> <span class="dt">get_t</span> = <span class="kw">typename</span> Machine::get;
<span class="kw">template</span> &lt;<span class="kw">typename</span> Machine, <span class="dt">char</span> val&gt;
<span class="kw">using</span> <span class="dt">set_t</span> = <span class="kw">typename</span> Machine::<span class="kw">template</span> set&lt;val&gt;;

<span class="kw">template</span> &lt;<span class="kw">typename</span> Machine&gt;
<span class="kw">using</span> <span class="dt">increment_t</span> = <span class="kw">typename</span> Machine::increment;
<span class="kw">template</span> &lt;<span class="kw">typename</span> Machine&gt;
<span class="kw">using</span> <span class="dt">decrement_t</span> = <span class="kw">typename</span> Machine::decrement;

<span class="kw">using</span> <span class="dt">make_t</span> = machine&lt;<span class="dt">tt_make_t</span>&lt;<span class="dt">char_t</span>&lt;<span class="dv">0</span>&gt;&gt;&gt;;</code></pre></div>
<p>Note the additional helper <code>make_t</code>, which just returns a fresh initialized brainfuck machine.</p>
<h2 id="the-brainfuck-machine-plus-io-bundle">The Brainfuck Machine plus IO Bundle</h2>
<p>By now, we have a specialized Turing tape, or letâs say <em>Brainfuck Machine Tape</em>, which can in principle perform the operations <code>+</code>, <code>-</code>, <code>&lt;</code>, <code>&gt;</code>, <code>.</code>, and <code>,</code>. The functions providing these operations, return a new Brainfuck Machine Tape. This is enough to represent a single naked Brainfuck Machine.</p>
<p>However, we still have to feed it with commands by hand. Some example lines show how to do that:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> empty_bfm    = <span class="dt">make_t</span>;

<span class="kw">using</span> a_bfm        = <span class="dt">set_t</span>&lt;empty_bfm, <span class="st">'a'</span>&gt;;

<span class="kw">using</span> b_bfm        = <span class="dt">increment_t</span>&lt;a_bfm&gt;;

<span class="kw">using</span> shifted_left = <span class="dt">move_left_t</span>&lt;b_bfm&gt;;

<span class="kw">using</span> bc_bfm       = <span class="dt">set_t</span>&lt;shifted_left, <span class="st">'c'</span>&gt;;

<span class="co">// Or in just one line:</span>
<span class="kw">using</span> bc_bfm_state = <span class="dt">set_t</span>&lt;<span class="dt">move_left_t</span>&lt;<span class="dt">increment_t</span>&lt;<span class="dt">set_t</span>&lt;<span class="dt">make_t</span>, <span class="st">'a'</span>&gt; &gt; &gt;, <span class="st">'c'</span>&gt;;</code></pre></div>
<p>What we want it to do: It shall automatically interpret a brainfuck script.</p>
<p>In order to implement that, we will couple a brainfuck machine together with input and output.</p>
<p>The input is a type list, which contains all characters which the user <em>will</em> enter. Usually, brainfuck interpreters ask for input values, when they step on a <code>,</code> operator, but as soon as the C++ compiler is running, we cannot ask for input any longer. Therefore the user character input must be defined as an input list <em>before</em> the compiler is started.</p>
<p>The output is also a type list. Before executing the brainfuck program, it is empty. After executing the program it is hopefully filled with meaningful output.</p>
<p>Operators can change any sub state in the state tuple <code>(BFM state, input, output)</code>. We will push around this bundle throughout the whole brainfuck program and alter it step by step. The output list will grow, while the program is executed (assuming it outputs something). The input list will shrink, as characters are consumed (assuming it reads from input), one-by-one.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> Inlist, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> io_bfm {
    <span class="kw">using</span> output = OutList;
    <span class="kw">using</span> state  = BFM;
};</code></pre></div>
<p>Being a purely functional programming novice, i found the fact that the state is never a structure member, but a template parameter, most unusual. Our I/O brainfuck machine bundle is represented by the tuple <code>(machine state, input program, output list)</code>, and these all are template parameters. The member type <code>using</code> clauses of struct <code>io_bfm</code> are just comfortable <em>getters</em> to the machine state and the output.</p>
<p>This is now the main vehicle for representing the state of the brainfuck machine and the remaining brainfuck program, as well with its output. The following code, which does the bulk of program interpretation, will stepwise renew this state by altering it in the right manner.</p>
<h2 id="interpreting-brainfuck-code-the-simple-part">Interpreting Brainfuck Code, the Simple Part</h2>
<p>At first, we will implement a function which accepts an <code>io_bfm</code> state as its first parameter, and one brainfuck command. Its result is the new state of the brainfuck machine, which results from applying that command. Mapping brainfuck command character mnemonics to brainfuck machine state manipulating commands is simple for most commands:</p>
<table style="width:72%;">
<colgroup>
<col width="16%" />
<col width="56%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">BF Command</th>
<th>Returns new <code>io_bfm</code> state withâ¦</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>.</code></td>
<td>â¦no changes, but the new output list has the current cursor value appended to its end.</td>
</tr>
<tr class="even">
<td align="center"><code>,</code></td>
<td>â¦the current cell set to the first input character, the input list with the first character chopped off, and an unaltered output list.</td>
</tr>
<tr class="odd">
<td align="center"><code>+</code></td>
<td>â¦the current cursor value incremented by one.</td>
</tr>
<tr class="even">
<td align="center"><code>-</code></td>
<td>â¦the current cursor value decremented by one.</td>
</tr>
<tr class="odd">
<td align="center"><code>&lt;</code></td>
<td>â¦the tape moved to the left.</td>
</tr>
<tr class="even">
<td align="center"><code>&gt;</code></td>
<td>â¦the tape moved to the right.</td>
</tr>
</tbody>
</table>
<p>This is the simple part. The <code>[</code> and <code>]</code> commands which define loop structures are missing. We will get at those just after the other command implementations:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM, <span class="dt">char</span> InputChar&gt;
<span class="kw">struct</span> interpret_step;

<span class="co">// '.' command</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, <span class="st">'.'</span>&gt; {
    <span class="kw">using</span> type = io_bfm&lt;BFM, 
                       InList, 
                       <span class="dt">append_t</span>&lt;OutList, <span class="dt">get_t</span>&lt;BFM&gt;&gt;&gt;;
};

<span class="co">// ',' command</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, <span class="st">','</span>&gt; {
    <span class="kw">using</span> type = io_bfm&lt;<span class="dt">set_t</span>&lt;BFM, <span class="dt">head_t</span>&lt;InList&gt;::value&gt;, 
                        <span class="dt">tail_t</span>&lt;InList&gt;, 
                        OutList&gt;;
};

<span class="co">// '+' command</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, <span class="st">'+'</span>&gt; {
    <span class="kw">using</span> type = io_bfm&lt;<span class="dt">increment_t</span>&lt;BFM&gt;,
                        InList, 
                        OutList&gt;;
};

<span class="co">// '-' command</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, <span class="st">'-'</span>&gt; {
    <span class="kw">using</span> type = io_bfm&lt;<span class="dt">decrement_t</span>&lt;BFM&gt;, 
                        InList, 
                        OutList&gt;;
};

<span class="co">// '&lt;' command</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, <span class="st">'&lt;'</span>&gt; {
    <span class="kw">using</span> type = io_bfm&lt;<span class="dt">move_left_t</span>&lt;BFM&gt;, 
                        InList, 
                        OutList&gt;;
};

<span class="co">// '&gt;' command</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> BFM, <span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, <span class="st">'&gt;'</span>&gt; {
    <span class="kw">using</span> type = io_bfm&lt;<span class="dt">move_right_t</span>&lt;BFM&gt;, 
                        InList, 
                        OutList&gt;;
};
<span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM, <span class="dt">char</span> InputChar&gt;
<span class="kw">using</span> <span class="dt">interpret_step_t</span> = 
          <span class="kw">typename</span> interpret_step&lt;IOBFM, InputChar&gt;::type;</code></pre></td></tr></table></div>
<p>In this lengthy list of ugly definitions you will find no if-else control structures. The function call flow is completely controlled by <em>pattern matching</em>. It would have been possible to work with <code>if_else_t</code> functions, but pattern matching is great for cases like this one. Every operator has its own function body, which nicely separates its semantics.</p>
<p>For each brainfuck command, there is one <code>struct interpret_step&lt;io_bfm&lt;BFM, InList, OutList&gt;, XXX&gt;</code> definition, where <code>XXX</code> is the command. Each command then returns, what the table before just described.</p>
<h2 id="interpreting-brainfuck-code-the-complicated-part-loops">Interpreting Brainfuck Code, the Complicated Part (Loops)</h2>
<p>Unfortunately, loops are not as simple as the other commands, because they do not lead to simple state changes. Whenever the BFM trips on a <code>[</code> command, it willâ¦</p>
<ol style="list-style-type: decimal">
<li>Check if the value at cursor position is equal to 0.</li>
<li>If it is <strong>equal</strong> to 0, then <strong>advance</strong> the whole program list to the <em>closing</em> <code>]</code> bracket.</li>
<li>If it is <strong>not equal</strong> to 0, then execute the part of the program which ends with the closing <code>]</code> bracket, then rewind back the tape to the opening <code>[</code> bracket, and go to <strong><em>1.</em></strong></li>
</ol>
<p>In this description, the term â<em>the closing <code>]</code> bracket</em>â</p>
<p>is already a high-level description of another problem:</p>
<blockquote>
<p>Given the position of an opening <code>[</code> bracket in a BF program, find the matching closing <code>]</code> bracket.</p>
</blockquote>
<h3 id="implementing-a-find-the-closing-bracket-function">Implementing a Find-The-Closing-Bracket Function</h3>
<p>Well, seems as if we need to do some homework first: Implement that <em>matching bracket finder</em>.</p>
<p>The general problem is that a brainfuck loop can contain multiple nested loops.</p>
<p>Examples:</p>
<ul>
<li><code>+++[&gt;+++[.-]&lt;]</code></li>
<li><code>+++[&gt;+++[&gt;+++[.-]&lt;]&lt;]</code></li>
</ul>
<p>Obviously, one cannot just choose the next closing <code>]</code> bracket, because that would be the closing bracket of a completely different loop. Therefore we have to <strong>count</strong>, how many loop we have seen beginning (by counting <code>[</code> commands).</p>
<p>Solution:</p>
<p>Whenever we see an opening <code>[</code> bracket, we <em>increment</em> a bracket counter, and whenever we see a closing <code>]</code> bracket, we <em>decrement</em> it again. Assuming we start at value <code>1</code>, because the first opening bracket denotes the beginning of the first loop. The next closing <code>]</code> bracket we see, while the counter is back at value <code>1</code>, is then the right loop end.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">......</span>[......[......[.....]....].....]......
      <span class="ex">1</span>      2      3     2    1     X
      
<span class="ex">position</span> X: Do not increment, but abort search. We found it.</code></pre></div>
<p>Letâs have a look at the C++ TMP implementation:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// Find the closing brace, assuming we have seen an opening </span>
<span class="co">// one already.</span>
<span class="co">//</span>
<span class="co">// InList:  The BF Program list, one element _behind_ the </span>
<span class="co">//          opening [ bracket.</span>
<span class="co">// OutList: A list which will grow with discovering all </span>
<span class="co">//          inside-loop characters. Should be empty on </span>
<span class="co">//          the initial call.</span>
<span class="co">//          inside-bracket loop part)</span>
<span class="co">// Counter: the bracket counter, which should be 1 on </span>
<span class="co">//          the initial call</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> InList, <span class="kw">class</span> OutList, <span class="dt">size_t</span> Counter&gt;
<span class="kw">struct</span> find_brace;

<span class="co">// Match: counter is 1, command is ']'</span>
<span class="co">// This is the final closing bracket.</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> InList, <span class="kw">class</span> OutList&gt;
<span class="kw">struct</span> find_brace&lt;tl&lt;<span class="dt">char_t</span>&lt;<span class="st">']'</span>&gt;, InList&gt;, 
                  OutList, 
                  <span class="dv">1</span>&gt; {
    <span class="co">// We're done. The user can now choose...</span>

    <span class="co">// ...the inner-loop program part</span>
    <span class="kw">using</span> brace_block = OutList;

    <span class="co">// ...the rest of the program behind the loop</span>
    <span class="kw">using</span> rest_prog   = InList;
};

<span class="co">// Match: counter is != 1, command is ']'</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> InList, <span class="kw">class</span> OutList, <span class="dt">size_t</span> N&gt;
<span class="kw">struct</span> find_brace&lt;tl&lt;<span class="dt">char_t</span>&lt;<span class="st">']'</span>&gt;, InList&gt;, 
                  OutList, 
                  N&gt;
    <span class="co">// Add character to outlist, decrement counter</span>
    : <span class="kw">public</span> find_brace&lt;InList, 
                       <span class="dt">append_t</span>&lt;OutList, <span class="dt">char_t</span>&lt;<span class="st">']'</span>&gt;&gt;, 
                       N - <span class="dv">1</span>&gt;
{};

<span class="co">// Match: counter is != 1, command is '['</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> InList, <span class="kw">class</span> OutList, <span class="dt">size_t</span> N&gt;
<span class="kw">struct</span> find_brace&lt;tl&lt;<span class="dt">char_t</span>&lt;<span class="st">'['</span>&gt;, InList&gt;, 
                  OutList, 
                  N&gt;
    <span class="co">// Add character to outlist, increment counter</span>
    : <span class="kw">public</span> find_brace&lt;InList, 
                        <span class="dt">append_t</span>&lt;OutList, <span class="dt">char_t</span>&lt;<span class="st">'['</span>&gt;&gt;, 
                        N + <span class="dv">1</span>&gt;
{};

<span class="co">// Match: Any yet unmatched case</span>
<span class="kw">template</span> &lt;<span class="dt">char</span> C, <span class="kw">class</span> InList, <span class="kw">class</span> OutList, <span class="dt">size_t</span> N&gt;
<span class="kw">struct</span> find_brace&lt;tl&lt;<span class="dt">char_t</span>&lt;C&gt;, InList&gt;, 
                  OutList, 
                  N&gt;
    <span class="co">// Add character to outlist</span>
    : <span class="kw">public</span> find_brace&lt;InList, 
                        <span class="dt">append_t</span>&lt;OutList, <span class="dt">char_t</span>&lt;C&gt;&gt;,
                        N&gt;
{};</code></pre></td></tr></table></div>
<p>Reading this function implementation it becomes apparent, that each implementation does not <em>return</em> some type, apart from the final case. They do rather <em>inherit</em> from the next matching function structure. I chose to do it this way, because this is a comfortable way to forward the altered <code>(in list, out list, counter)</code> states. As the final case contains <em>two</em> return values (the inner-loop program part, and the rest of the program after the loop), these are reached back as public members of the initially called structure.</p>
<p>So if <code>A</code> inherits from <code>B</code>, and <code>B</code> inherits from <code>C</code>, and <code>C</code> defines some member type definitions, these are also available in <code>A</code>. That is what is useful in this specific case, too.</p>
<h3 id="back-to-the-loop-command-implementation">Back to the Loop Command Implementation</h3>
<p>Ok, after having done the homework, we can finally implement the loop control code, maybe the most complicated part of this whole compile time brainfuck story.</p>
<p>The following code consists of two blocks:</p>
<ol style="list-style-type: decimal">
<li>The block which matches the <em>base</em> case (Line 336): one of the <code>+</code>, <code>-</code>, <code>.</code>, <code>,</code>, <code>&lt;</code>, <code>&gt;</code> commands. This is easy to handle, because we already implemented all that. For these cases, this block is just a wrapper which will apply all the BF program commands to the BFM, until the program runs empty.</li>
<li>The large, ugly block (Line 366), which is invoked whenever the current programâs head character is an opening bracket <code>[</code>.</li>
</ol>
<p>The second block is so complicated, because it contains the loop execution decision:</p>
<blockquote>
<p>If the cursor value is nonzero, execute the loop body, and then look at the beginning of the loop again, doing this decision again. If the cursor value is zero, skip the whole loop, and continue with the rest of the program.</p>
</blockquote>
<p>In order to do that decision, the interpreter will:</p>
<ol style="list-style-type: decimal">
<li>Load the cursor value and set a variable <code>loop_terminated</code> to true, if this value is zero.</li>
<li>if <code>loop_terminated</code> is true, then <code>run_tm</code> is called again on the rest of the program which begins behind the loop.</li>
<li>if <code>loop_terminated</code> is false, then it willâ¦
<ul>
<li>Take the IOBFM state, and run it on the loop body, as if it was the whole program.</li>
<li>Together with this state which resulted from a single loop operation, it is put on the same loop again</li>
</ul></li>
</ol>
<p>Armored with that workflow in your mind, have a look at the implementation:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// Execute a brainfuck machine, defined by its IO/BFM state</span>
<span class="co">//</span>
<span class="co">// IOBFM:    The initial I/O and BF machine pair.</span>
<span class="co">// ProgList: The brainfuck program</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM, <span class="kw">class</span> ProgList&gt;
<span class="kw">struct</span> run_tm;

<span class="co">// Matches: '[', Next BF command is the beginning of a loop</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM, <span class="kw">class</span> RestProg&gt;
<span class="kw">struct</span> run_tm&lt;IOBFM, ::tl::tl&lt;::<span class="dt">char_t</span>&lt;<span class="st">'['</span>&gt;, RestProg&gt;&gt; {
    <span class="co">// If the value at cursor position is zero: skip the loop</span>
    <span class="at">static</span> <span class="at">const</span> <span class="kw">constexpr</span> <span class="dt">bool</span> loop_terminated {
                 <span class="dt">get_t</span>&lt;<span class="kw">typename</span> IOBFM::state&gt;::value == <span class="dv">0</span>};

    <span class="co">// &quot;blocks&quot; gives us loop body and rest of the program</span>
    <span class="co">// after the loop.</span>
    <span class="kw">using</span> blocks = find_brace&lt;RestProg, <span class="dt">null_t</span>, <span class="dv">1</span>&gt;;

    <span class="co">// If the loop is already terminated...</span>
    <span class="kw">using</span> type = <span class="kw">typename</span> <span class="dt">if_else_t</span>&lt;loop_terminated,
        <span class="co">// ...then run the rest of the program,</span>
        <span class="co">//    which begins after the closing ']'</span>
        run_tm&lt;IOBFM, <span class="kw">typename</span> blocks::rest_prog&gt;,

        <span class="co">// ...else, execute the BFM on the loop body,</span>
        <span class="co">//    as if it was the whole program...</span>
        run_tm&lt;
            <span class="kw">typename</span> run_tm&lt;IOBFM, 
                            <span class="kw">typename</span> blocks::brace_block
                      &gt;::type,
            <span class="co">// ...and then confront it with the</span>
            <span class="co">//    same loop again.</span>
            ::tl::tl&lt;::<span class="dt">char_t</span>&lt;<span class="st">'['</span>&gt;, RestProg&gt;&gt;
    &gt;::type;
};

<span class="co">// Matches: Base case. </span>
<span class="co">// Any of the 6 _simple_ brainfuck commands.</span>
<span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM, <span class="dt">char</span> Command, <span class="kw">class</span> RestProg&gt;
<span class="kw">struct</span> run_tm&lt;IOBFM, ::tl::tl&lt;::<span class="dt">char_t</span>&lt;Command&gt;, RestProg&gt;&gt; {
    <span class="kw">using</span> type = <span class="kw">typename</span> run_tm&lt;
                      <span class="dt">interpret_step_t</span>&lt;IOBFM, Command&gt;, 
                      RestProg
                 &gt;::type;
};
<span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM&gt;
<span class="kw">struct</span> run_tm&lt;IOBFM, ::tl::<span class="dt">null_t</span>&gt; {
    <span class="kw">using</span> type = IOBFM;
};

<span class="kw">template</span> &lt;<span class="kw">class</span> IOBFM, <span class="kw">class</span> ProgList&gt;
<span class="kw">using</span> <span class="dt">run_tm_t</span> = <span class="kw">typename</span> run_tm&lt;IOBFM, ProgList&gt;::type;</code></pre></td></tr></table></div>
<h2 id="play">Play</h2>
<p>Wow, we have everything together. We can now execute brainfuck programs at compile time, and produce binaries, which already contain the programâs output, and no trace of brainfuck itself.</p>
<p>Letâs throw all the code into a .cpp file and write a <code>main()</code> function, which will print our compile time results.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// The program input is provided by a string provider.</span>
<span class="co">// The type list transformation article explains, how these work.</span>
<span class="kw">struct</span> program_str { 
    <span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> * str() { 
        <span class="co">// &quot;Hello World&quot; Brainfuck implementation from wikipedia</span>
        <span class="cf">return</span> <span class="st">&quot;++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++.&quot;</span> 
               <span class="st">&quot;.+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.+++.&quot;</span>;
    } 
};

<span class="dt">int</span> main()
{
    <span class="co">// Input is uninteresting for this program.</span>
    <span class="kw">using</span> input_list = <span class="dt">tl_null_t</span>;

    <span class="co">// Transform the program string provider into a type list</span>
    <span class="kw">using</span> prog       = <span class="dt">string_list_t</span>&lt;program_str&gt;;

    <span class="co">// Compose an initialized IOBFM from an empty BFM, and the empty input</span>
    <span class="kw">using</span> BFM = bfm::io_bfm&lt;bfm::<span class="dt">make_t</span>, input_list, tl::<span class="dt">null_t</span>&gt;;

    <span class="co">// The BFM's machine output is obtained by _running_ the IOBFM </span>
    <span class="co">// together with the brainfuck program in the run_tm function.</span>
    <span class="kw">using</span> output = bfm::<span class="dt">run_tm_t</span>&lt;BFM, prog&gt;::output;

    <span class="co">// Comment this out, to get ugly compile error messages, which</span>
    <span class="co">// contain the whole program output.</span>
    <span class="co">//debug_t&lt;output&gt; t;</span>

    <span class="co">// Generate a normal C string back from the output character typelist,</span>
    <span class="co">// and finally print it.</span>
    puts(tl_to_varlist&lt;output&gt;::str());

    <span class="cf">return</span> <span class="dv">0</span>;
};</code></pre></div>
<p>Using the compile time BFM is not as ugly as writing it. To play with it yourself, and to completely understand it, i suggest looking at the real code. I created <a href="https://github.com/tfc/cpp_template_meta_brainfuck_interpreter">a github repository which contains the whole compile time brainfuck interpreter</a>.</p>
<p>The code in the repository does encapsulate input string and program string into preprocessor define macros. This way it is possible to feed different sets of input and BF programs via the command line. In the end, it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">Jacek.Galowicz</span> ~/src/tmp_brainfuck $ g++ -o main main.cpp -std=c++14 -DPROGRAM_STR=<span class="st">'&quot;++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.+++.&quot;'</span>
<span class="ex">Jacek.Galowicz</span> ~/src/tmp_brainfuck $ ./main
<span class="ex">Hello</span> World!</code></pre></div>
<p>Printing at compile time looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">Jacek.Galowicz</span> ~/src/tmp_brainfuck $ g++ -o main main.cpp -std=c++14 -DPROGRAM_STR=<span class="st">'&quot;++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.+++.&quot;'</span>

<span class="ex">main.cpp</span>:31:51: error: implicit instantiation of undefined template 
<span class="st">'debug_t&lt;char_tl&lt;'</span><span class="ex">H</span><span class="st">', '</span>e<span class="st">', '</span>l<span class="st">', '</span>l<span class="st">', '</span>o<span class="st">', '</span> <span class="st">', '</span>W<span class="st">', '</span>o<span class="st">', '</span>r<span class="st">', '</span>l<span class="st">', '</span>d<span class="st">', '</span>!<span class="st">', '</span>\n<span class="st">', '</span>\x0D<span class="st">'&gt; &gt;'</span>
    <span class="ex">debug_t</span><span class="op">&lt;</span>typename tl_to_varlist<span class="op">&lt;</span>output<span class="op">&gt;</span>::list<span class="op">&gt;</span> t<span class="kw">;</span>
                                                  ^
<span class="ex">main.cpp</span>:6:29: note: template is declared here
<span class="ex">template</span> <span class="op">&lt;</span>typename T<span class="op">&gt;</span> class debug_t<span class="kw">;</span>
                            ^
<span class="ex">1</span> error generated.
<span class="ex">Makefile</span>:3: recipe for target <span class="st">'default'</span> failed
<span class="ex">make</span>: *** [default] Error 1</code></pre></div>
<h2 id="summary">Summary</h2>
<p>Implementing a Brainfuck Interpreter which works at compile time, is more a toy than actually a useful program. But it combines several template meta-programming techniques, and therefore i regard it as a great <em>learning vehicle</em>. And this is a nice insight into the Turing completeness of the C++ template language.</p></div>
<div id="disqus_thread"></div>
<script>var disqus_developer = 1;
var disqus_config = function () {this.page.url = 'https://blog.galowicz.de/2016/06/16/cpp_template_compile_time_brainfuck_interpreter/';
this.page.identifier = 'nicecpp/2016/06/16/cpp_template_compile_time_brainfuck_interpreter/';};
(function() {var d = document, s = d.createElement('script');
s.src = '//nicecpp.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);})();</script>
</div>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-28506344-2', 'auto');
ga('send', 'pageview');
gtag('config', 'UA-28506344-2', { 'anonymize_ip': true });</script>
</body>
</head>
</html>
