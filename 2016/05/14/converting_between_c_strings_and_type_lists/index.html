<!doctype html>
<html lang="en-us"><head><meta http-equiv="refresh" content="3; URL=https://galowicz.de/2016/05/14/converting_between_c_strings_and_type_lists">
<link href="http://gmpg.org/xfn/11" rel="profile">
<link type="application/atom+xml" rel="alternate" href="https://blog.galowicz.de/feed.xml" title="Jacek's Software Engineering Blog" />
<link rel="stylesheet" href="../../../../css/poole.css">
<link rel="stylesheet" href="../../../../css/syntax.css">
<link rel="stylesheet" href="../../../../css/hyde.css">
<script src="https://kit.fontawesome.com/796c2aa0a7.js" crossorigin="anonymous"></script></script>
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../images/apple-touch-icon-144-precomposed.png">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script></script>
<link rel="shortcut icon" href="../../../../images/favicon.ico">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title>Jacek's Blog &middot; Transformations between User Input/Output and Type Lists</title>
</head>
<body class="layout-reverse"><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1><a href="../../../../">Jacek's Blog</a>
</h1>
<p class="lead">Software Engineering Consultant</p>
</div>
<nav class="sidebar-nav"><a class="sidebar-nav-item active" href="../../../../">Home</a>
<a class="sidebar-nav-item" href="../../../../about.html">About / CV</a>
<a class="sidebar-nav-item" href="../../../../impressum.html">Impressum</a>
<a class="sidebar-nav-item" href="../../../../datenschutz.html">Datenschutz / Cookies</a>
</nav>
<p><a href="https://linkedin.com/in/jgalowicz"><i class="fa-brands fa-linkedin"></i>
</a>
<a href="https://www.xing.com/profile/Jacek_Galowicz"><i class="fa-brands fa-square-xing"></i>
</a>
<a href="https://github.com/tfc"><i class="fa-brands fa-square-github"></i>
</a>
<a href="https://twitter.com/jgalowicz"><i class="fa-brands fa-square-twitter"></i>
</a>
<a rel="me" href="https://functional.cafe/@jgalowicz"><i class="fa-brands fa-mastodon"></i>
</a>
</p>
</div>
</div>
<div class="content container"><h1>This is the old domain blog.galowicz.de. You are being redirected to <a href="https://galowicz.de/2016/05/14/converting_between_c_strings_and_type_lists">galowicz.de/2016/05/14/converting_between_c_strings_and_type_lists</a></h1>
<hr>
<h1>Transformations between User Input/Output and Type Lists</h1>
<div class="post"><span class="post-date">May 14, 2016</span>
<span class="post-tags">
Tags: <a title="All pages tagged 'c++'." href="../../../../tags/c%2B%2B.html" class="tag-link">c++</a> <a title="All pages tagged 'metaprogramming'." href="../../../../tags/metaprogramming.html" class="tag-link">metaprogramming</a>
</span>
<!-- cSpell:disable -->
<p>Type lists are an important way to represent ordered and unordered sets of types at compile time.
These types can be real structure- or class types bundling runtime algorithms etc., but they can also convey actual data at compile time.
In order to apply certain compile time processing to data, this data needs to be transformed from and to other representations, which can be provided by the programmer and consumed by run time programs.
This article shows how to transform back and forth between strings and character type lists.</p>
<!--more-->
<h2 id="wrapping-characters-into-type-lists">Wrapping characters into Type Lists</h2>
<p>At first, a type is needed which can carry one actual character, without having to instantiate it.
This is the requirement for all value-carrying types in order to be able to use them at compile time.
Using that type, it is possible to compose character type lists, which carry whole strings.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> val<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="dt">char_t</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="at">const</span> <span class="kw">constexpr</span> <span class="dt">char</span> value <span class="op">{</span>val<span class="op">};</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><code>char_t</code>‘s only template parameter is an actual character.
To carry the character ’a’, one just instanciates it like this: <code>char_t&lt;'a'&gt;</code>.
The character can now be accessed via the <code>value</code> member of the structure type, both at compile- and at run time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define the character 'a' carrying type</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> my_char <span class="op">=</span> <span class="dt">char_t</span><span class="op">&lt;</span><span class="ch">'a'</span><span class="op">&gt;;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Accessing my_char's payload character at compile time</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> next_char <span class="op">=</span> <span class="dt">char_t</span><span class="op">&lt;</span>my_char<span class="op">::</span>value <span class="op">+</span> <span class="dv">1</span><span class="op">&gt;;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">()</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Accessing it at run time</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> my_char<span class="op">::</span>value <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This type is now fundamental to character type lists.</p>
<h2 id="converting-from-strings-to-type-lists">Converting from Strings to Type Lists</h2>
<p>Using type lists, these can now easily be chained together, using the <code>make_t</code> helper from the previous article.
(Link to <a href="../../../../2016/05/08/compile_time_type_lists">the article which explains how to create type lists</a>)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> my_abc_string <span class="op">=</span> <span class="dt">make_t</span><span class="op">&lt;</span><span class="dt">char_t</span><span class="op">&lt;</span><span class="ch">'a'</span><span class="op">&gt;,</span> <span class="dt">char_t</span><span class="op">&lt;</span><span class="ch">'b'</span><span class="op">&gt;,</span> <span class="dt">char_t</span><span class="op">&lt;</span><span class="ch">'c'</span><span class="op">&gt;&gt;;</span></span></code></pre></div>
<p>Although <code>make_t</code>’s purpose is to make type list creation less clumsy, this does not look optimal.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> c<span class="op">,</span> <span class="dt">char</span> <span class="op">...</span> chars<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">struct</span> char_tl<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> c<span class="op">,</span> <span class="dt">char</span> <span class="op">...</span> chars<span class="op">&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">struct</span> char_tl <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">using</span> type <span class="op">=</span> tl<span class="op">::</span>tl<span class="op">&lt;</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>                    <span class="dt">char_t</span><span class="op">&lt;</span>c<span class="op">&gt;,</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>                    <span class="kw">typename</span> char_tl<span class="op">&lt;</span>chars<span class="op">...&gt;::</span>type</span>
<span id="cb4-9"><a href="#cb4-9"></a>                 <span class="op">&gt;;</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="op">};</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> c<span class="op">&gt;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="kw">struct</span> char_tl<span class="op">&lt;</span>c<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="kw">using</span> type <span class="op">=</span> tl<span class="op">::</span>tl<span class="op">&lt;</span><span class="dt">char_t</span><span class="op">&lt;</span>c<span class="op">&gt;,</span> tl<span class="op">::</span><span class="dt">null_t</span><span class="op">&gt;;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="op">};</span></span>
<span id="cb4-16"><a href="#cb4-16"></a></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> <span class="op">...</span> chars<span class="op">&gt;</span></span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="kw">using</span> <span class="dt">char_tl_t</span> <span class="op">=</span> <span class="kw">typename</span> char_tl<span class="op">&lt;</span>chars<span class="op">...&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p><br></p>
<ul>
<li><strong>line 2</strong> defines the general type signature of the conversion function <code>char_tl</code> which accepts a variadic character list</li>
<li><strong>line 5</strong> describes the recursion which is applied in order to <em>unroll</em> the variadic type list into a type list. It <em>wraps</em> each individual character into a <code>char_t</code> type. This new <code>char_t</code> type is then again wrapped as the head element into a new type list, and its tail is the next recursion step.</li>
<li><strong>line 11</strong> defines the recursion abort step by just wrapping the last character into a type list which is terminated just right afterwards.</li>
<li><strong>line 16</strong> is a convenient helper type alias.</li>
</ul>
<p>Character type lists can now be instantiated like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> my_abc_string <span class="op">=</span> <span class="dt">char_tl_t</span><span class="op">&lt;</span><span class="ch">'a'</span><span class="op">,</span> <span class="ch">'b'</span><span class="op">,</span> <span class="ch">'c'</span><span class="op">&gt;;</span></span></code></pre></div>
<p>This is already a significant improvement over what we had before.
Pretty nice, but the <em><strong>real</strong> optimum</em> would be a transformation from an actual C-string in the form <code>"abc"</code> to a type list.</p>
<p>Of course, that is also possible:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Str<span class="op">,</span> <span class="dt">size_t</span> Pos<span class="op">,</span> <span class="dt">char</span> C<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">struct</span> string_list<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Str<span class="op">,</span> <span class="dt">size_t</span> Pos<span class="op">,</span> <span class="dt">char</span> C<span class="op">&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">struct</span> string_list <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">using</span> next_piece <span class="op">=</span> <span class="kw">typename</span> string_list<span class="op">&lt;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>                            Str<span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>                            Pos <span class="op">+</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>                            Str<span class="op">::</span>str<span class="op">()[</span>Pos <span class="op">+</span> <span class="dv">1</span><span class="op">]</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>                        <span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">using</span> type <span class="op">=</span> tl<span class="op">::</span>tl<span class="op">&lt;</span><span class="dt">char_t</span><span class="op">&lt;</span>C<span class="op">&gt;,</span> next_piece<span class="op">&gt;;</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="op">};</span></span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Str<span class="op">,</span> <span class="dt">size_t</span> Pos<span class="op">&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="kw">struct</span> string_list<span class="op">&lt;</span>Str<span class="op">,</span> Pos<span class="op">,</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="kw">using</span> type <span class="op">=</span> tl<span class="op">::</span><span class="dt">null_t</span><span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="op">};</span></span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Str<span class="op">&gt;</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="kw">using</span> <span class="dt">string_list_t</span> <span class="op">=</span> <span class="kw">typename</span> string_list<span class="op">&lt;</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>                          Str<span class="op">,</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>                          <span class="dv">0</span><span class="op">,</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>                          Str<span class="op">::</span>str<span class="op">()[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>                      <span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p><br></p>
<ul>
<li><strong>line 2</strong> Declares our function which takes a string provider, a position index, and the character at the current position. The user will later only provide the string provider. The position index as well as the character are for internal use. <code>string_list_t</code> adds them automatically (line 20).</li>
</ul>
<p>Before continuing with the following lines of code: <strong>What</strong> is a <em>string provider?</em></p>
<p>A string, or a string pointer, cannot just be used as template parameters directly.
Therefore a type carrying a string as payload and provides static access to it is needed:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> my_string_provider <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span> str<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="st">&quot;foo bar string&quot;</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This type can now be used as a template parameter by template classes, and the template code can access its static string member.
Because of this additional, but necessary, indirection it is called a <em>string provider</em>.</p>
<ul>
<li><strong>line 5</strong> defines the recursion which advances through the string step by step, while appending each character to the result type list. This is basically the same as in the example where we used variadic character type lists, but some more mechanics are needed to iterate the string provider.</li>
<li><strong>line 15</strong> defines the recursion abort step. As soon as we trip on the zero character which terminates the string, we also terminate the list.</li>
<li><strong>line 20</strong> is the easy-to-use wrapper which is meant to be used by the user. It takes a single string provider parameter and extracts any other needed parameter from it.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> abc_string_provider <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span> str<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> my_abc_string <span class="op">=</span> <span class="dt">string_list_t</span><span class="op">&lt;</span>abc_string_provider<span class="op">&gt;;</span></span></code></pre></div>
<p>This is as easy as it gets.
Having to define a string provider around every simple string is still a lot of scaffolding, but this is still the only reasonable way to convert long C-strings into type lists.</p>
<h2 id="converting-from-type-lists-to-c-strings">Converting from Type Lists to C-Strings</h2>
<p>Imagine a type list with character payload as the result after the execution of some meta programming algorithm.</p>
<p>In some cases the wanted output form is a C-string.
This is the exact reverse operation from what we just implemented before.</p>
<p>The generic idea is to convert a type list to a variadic character template parameter list.
That variadic list can be used to initialize a character array, which can then be provided to the user:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> typelist<span class="op">,</span> <span class="dt">char</span> <span class="op">...</span> chars<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">struct</span> tl_to_vl<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> c<span class="op">,</span> <span class="kw">typename</span> restlist<span class="op">,</span> <span class="dt">char</span> <span class="op">...</span> chars<span class="op">&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">struct</span> tl_to_vl<span class="op">&lt;</span>tl<span class="op">::</span>tl<span class="op">&lt;</span><span class="dt">char_t</span><span class="op">&lt;</span>c<span class="op">&gt;,</span> restlist<span class="op">&gt;,</span> chars<span class="op">...&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="op">:</span> <span class="kw">public</span> tl_to_vl<span class="op">&lt;</span>restlist<span class="op">,</span> chars<span class="op">...,</span> c<span class="op">&gt;</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="op">{</span> <span class="op">};</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">char</span> <span class="op">...</span> chars<span class="op">&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">struct</span> tl_to_vl<span class="op">&lt;</span>tl<span class="op">::</span><span class="dt">null_t</span><span class="op">,</span> chars<span class="op">...&gt;</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="at">static</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span> <span class="at">const</span> str<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">char</span> ret<span class="op">[]</span> <span class="op">{</span>chars<span class="op">...,</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">};</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>    <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="op">}</span></span></code></pre></div>
<p><br></p>
<ul>
<li><strong>line 2</strong> defines the general function signature: It takes a character type list as first parameter, and then a variadic list of characters.</li>
<li><strong>line 5</strong> defines the recursion: The idea is to let the type list shrink stepwise, while the character, which is taken from it, is appended to the variadic character list.</li>
<li><strong>line 10</strong> is the recursion abort step. At this point, the type list is empty and the variadic character list contains the whole string. Having the whole string in the <code>chars...</code> template variable, we can define the static function <code>str()</code> which defines a static character array and returns it.</li>
</ul>
<p>This code example is different than the others before, because it relies on inheritance.
It would have been possible to implement the others with inheritance, too, or implement this one defining local <code>type</code> type variables etc., but i found this form to be the shortest and most useful one, while still being nicely readable.</p>
<p>By instanciating <code>tl_to_vl&lt;some_type_list&gt;</code>, a chain of inheriting classes is unrolled, and the last base class, which is the recursion abort type from line 10, defines the static <code>str()</code> function.
Because every member of a <code>struct</code> is public by default, the actually instantiated <em>outer</em> type <code>tl_to_vl&lt;some_type_list&gt;</code> also provides this function, which is directly callable.</p>
<p>Example of how to print a type list on the terminal, after converting it into a C-String:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> abc_string_provider <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">static</span> <span class="kw">constexpr</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span> str<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> my_abc_string <span class="op">=</span> <span class="dt">string_list_t</span><span class="op">&lt;</span>abc_string_provider<span class="op">&gt;;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> string_provider <span class="op">=</span> tl_to_vl<span class="op">&lt;</span>my_abc_string<span class="op">&gt;;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    puts<span class="op">(</span>string_provider<span class="op">::</span>str<span class="op">());</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When compiling code like this, the assembly code will still result in a function call of <code>str()</code>, which returns a pointer to the C-string, and then a call of <code>puts</code>.</p>
<p>Compiling the code <em>without</em> any optimization (clang++ [clang-703.0.29]):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">_main:</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>pushq   <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">movq</span>    <span class="op">%</span><span class="kw">rsp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>subq    <span class="op">$</span><span class="bn">0</span>x10<span class="op">,</span> <span class="op">%</span><span class="kw">rsp</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>movl    <span class="op">$</span><span class="bn">0</span>x0<span class="op">,</span> <span class="op">-</span><span class="bn">0x4</span><span class="op">(%</span><span class="kw">rbp</span><span class="op">)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a># The following line contains the function call string_provider<span class="op">::</span>str<span class="op">()</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>callq   __ZN13tl_to_varlistIN2tl6null_tEJLc72ELc101ELc108ELc108ELc111ELc32ELc87ELc111ELc114ELc108ELc100ELc33ELc10ELc13EEE3strEv <span class="op">##</span> tl_to_varlist<span class="op">&lt;</span>tl<span class="op">::</span>null_t<span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">72</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">101</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">108</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">108</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">111</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">32</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">87</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">111</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">114</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">108</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">100</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">33</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">10</span><span class="op">,</span> <span class="op">(</span>char<span class="op">)</span><span class="dv">13</span><span class="op">&gt;::</span>str<span class="op">()</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">movq</span>    <span class="op">%</span><span class="kw">rax</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a># This is the call of the puts<span class="op">()</span> procedure</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>callq   <span class="bn">0x100000f7e</span>     <span class="op">##</span> symbol stub for<span class="op">:</span> _puts</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>xorl    <span class="op">%</span><span class="kw">ecx</span><span class="op">,</span> <span class="op">%</span><span class="kw">ecx</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>movl    <span class="op">%</span><span class="kw">eax</span><span class="op">,</span> <span class="op">-</span><span class="bn">0x8</span><span class="op">(%</span><span class="kw">rbp</span><span class="op">)</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>movl    <span class="op">%</span><span class="kw">ecx</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>addq    <span class="op">$</span><span class="bn">0</span>x10<span class="op">,</span> <span class="op">%</span><span class="kw">rsp</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>popq    <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>retq</span></code></pre></div>
<p>Compiling the code <em>with</em> <code>-O1</code> or <code>-O2</code> optimization (clang++):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">_main:</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>pushq <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">movq</span>  <span class="op">%</span><span class="kw">rsp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">movq</span>  <span class="bn">0x85</span><span class="op">(%</span>rip<span class="op">),</span> <span class="op">%</span><span class="kw">rdi</span>   <span class="op">##</span> literal pool symbol address<span class="op">:</span> __ZZN13tl_to_varlistIN2tl6null_tEJLc72ELc101ELc108ELc108ELc111ELc32ELc87ELc111ELc114ELc108ELc100ELc33ELc10ELc13EEE3strEvE6string</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>callq <span class="bn">0x100000f84</span>        <span class="op">##</span> symbol stub for<span class="op">:</span> _puts</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>xorl  <span class="op">%</span><span class="kw">eax</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>popq  <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>retq</span></code></pre></div>
<p>The disassembly shows that the string is just read out of the binary, where it is available without any processing.
It is pretty nice to see that there is <em>no trace</em> of any meta programming code in the binary.
Apart from those strange and long symbol names, everything looks as if the string was hard coded into the binary by hand to its resulting form.</p>
<p>The next article will deal with template meta programs which transform character type lists in order to do useful things with them.</p></div>
</div>
<script>var url = new URL('https://galowicz.de/');
url.pathname = window.location.pathname;
window.location.replace(url.href);</script>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.1/cookieconsent.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.1/cookieconsent.min.js" data-cfasync="false"></script></script>
<script>var popup;
window.addEventListener('load', function(){window.cookieconsent.initialise({//set revokeBtn if you don't want to see a tiny pullup bar overlapping your website
//if revokeBtn is set, make sure to include a link to cookie settings in your footer
//you can open your banner again with: popup.open();
//revokeBtn: "<div class='cc-revoke'></div>",
type: "opt-in",
theme: "edgeless",
content: {message: 'Wir benutzen Cookies, um zu messen, welche Inhalte auf Interesse stoßen. Die Erlaubnis kann jederzeit rückgängig gemacht werden. / We use cookies to measure which content is of interest to you. You can revoke your approval at any time',
href: '/datenschutz.html#cookie-richtlinie',
allow: 'Cookies erlauben / Allow cookies',
deny: 'Nur technisch notwendige Cookies / Only technically necessary cookies',
link: 'Mehr dazu / Learn more',},
palette: {popup: {background: "#202020",
text: "#fff"
},button: {background: "#268bd2",
text: "#fff"
}},
onInitialise: function(status) {if(status == cookieconsent.status.allow) setCookies();},
onStatusChange: function(status) {if (this.hasConsented()) setCookies();
else deleteCookies(this.options.cookie.name)},
law: { regionalLaw: false, },
location: true,
function (p) { popup = p; }});})
//it is absolutely crucial to define gtag in the global scope
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WZ3FX4G3XS', {'anonymize_ip': true});
function setCookies() {var s = document.createElement('script');
s.type = "text/javascript"
s.async = "true";
s.src = "https://www.googletagmanager.com/gtag/js?id=G-WZ3FX4G3XS";
var x = document.getElementsByTagName('script')[0];
x.parentNode.insertBefore(s, x);};
function deleteCookies(cookieconsent_name) {var keep = [cookieconsent_name, "DYNSRV"];
document.cookie.split(';').forEach(function(c) {c = c.split('=')[0].trim();
if (!~keep.indexOf(c))document.cookie = c + '=;' + 'expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/';});};</script>
</body>
</html>
